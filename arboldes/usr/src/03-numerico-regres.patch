diff -u src55-orig/regress/lib/libc/locale/Makefile src/regress/lib/libc/locale/Makefile
--- src55-orig/regress/lib/libc/locale/Makefile	Fri Oct 18 09:22:50 2013
+++ src/regress/lib/libc/locale/Makefile	Mon Nov 11 15:25:35 2013
@@ -1,7 +1,7 @@
 # $OpenBSD: Makefile,v 1.2 2013/08/01 21:26:30 kettenis Exp $
 
 .if defined(REGRESS_FULL)
-SUBDIR+= check_isw
+SUBDIR+= check_isw check_numeric
 .endif
 
 install:
diff -ruN -x obj -x CVS -x *~ -x *orig src55-orig/regress/lib/libc/locale/check_numeric/Makefile src/regress/lib/libc/locale/check_numeric/Makefile
--- src55-orig/regress/lib/libc/locale/check_numeric/Makefile	Wed Dec 31 19:00:00 1969
+++ src/regress/lib/libc/locale/check_numeric/Makefile	Mon Nov 11 12:01:52 2013
@@ -0,0 +1,11 @@
+
+NOMAN=
+PROG=check_numeric
+
+CFLAGS=-g
+
+
+run-regress-check_numeric: ${PROG}
+	./${PROG} >/dev/null
+
+.include <bsd.regress.mk>
diff -ruN -x obj -x CVS -x *~ -x *orig src55-orig/regress/lib/libc/locale/check_numeric/check_numeric.c src/regress/lib/libc/locale/check_numeric/check_numeric.c
--- src55-orig/regress/lib/libc/locale/check_numeric/check_numeric.c	Wed Dec 31 19:00:00 1969
+++ src/regress/lib/libc/locale/check_numeric/check_numeric.c	Mon Nov 11 12:01:52 2013
@@ -0,0 +1,159 @@
+/**
+ * Public domain according to Colombian Legislation. 
+ * http://www.pasosdejesus.org/dominio_publico_colombia.html
+ * 2013. vtamara@pasosdeJesus.org
+ *
+ * $adJ$
+ */
+
+#include <langinfo.h>
+#include <locale.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+int bad;
+
+#define p(t) printf("%s:\t ",#t); \
+	if (t) { \
+		printf("\x1b[38;5;2mOK\x1b[0m\n"); \
+	} else { \
+		bad++; \
+		printf("\x1b[38;5;1mERROR\x1b[0m\n"); \
+	}
+
+/** Function adapted from lnumeric.c */
+void
+m_numericdebug(struct lconv *p) {
+	printf( "decimal_point = %s\n"
+			"thousands_sep = %s\n"
+			"grouping = %d\n",
+			p->decimal_point,
+			p->thousands_sep,
+			p->grouping[0]
+	      );
+}
+
+void test_posix()
+{
+	char nom[256];
+	char col[512];
+	char *nl;
+	char *enc[]= { "ISO8859-1", "ISO8859-15", "UTF-8" };
+	struct lconv *p;
+	int i;
+	for(i = 0; i < sizeof(enc) / sizeof(char *) ; i++) {
+		snprintf(nom, sizeof(nom), "POSIX.%s", enc[i]);
+		printf("nom=%s\n", nom);
+		nl = setlocale(LC_ALL, nom);
+		printf("locale %s\n", nl);
+		p = localeconv();
+
+		m_numericdebug(p);
+		p(strcmp(p->decimal_point, ".") == 0);
+		p(strcmp(p->thousands_sep, "") == 0);
+		p(p->grouping[0] == 127);
+
+		snprintf(col, sizeof(col), "%f", 1000000.01);
+		p(strcmp(col, "1000000.010000") == 0);
+		snprintf(col, sizeof(col), "%'d", 1000000);
+		printf("col=%s\n", col);
+		p(strcmp(col, "1000000") == 0);
+		snprintf(col, sizeof(col), "%'f", 1000000.01);
+		printf("col=%s\n", col);
+		p(strcmp(col, "1000000.010000") == 0);
+		p(strcmp(nl_langinfo(RADIXCHAR), ".") == 0);
+		p(strcmp(nl_langinfo(THOUSEP), "") == 0);
+	}
+}
+
+// Locales where radix symbol is command, and there is grouping
+// of thousands separated by dot
+// Not sure if any of es_CR, es_MX, es_PR, es_SV should be here
+// http://es.wikipedia.org/wiki/Separador_decimal#cite_note-ref_duplicada_1-3
+void test_radixcomma_thousandsdot()
+{
+	char *c[] = { 
+		"es_AR", "es_BO", "es_CL", "es_CO", "es_DO", "es_EC", 
+		"es_ES", "es_GT", "es_HN", "es_NI", "es_PA", "es_PE", 
+		"es_PY", "es_UY", "es_VE", "pt_BR"
+	};
+	char *enc[]= { "ISO8859-1", "ISO8859-15", "UTF-8" };
+	struct lconv *p;
+	char nom[256];
+	char col[512];
+	char *nl;
+	int i, j;
+
+	for(i = 0; i < sizeof(enc) / sizeof(char *) ; i++) {
+		for(j = 0; j < sizeof(c) / sizeof(char *) ; j++) {
+			snprintf(nom, sizeof(nom), "%s.%s", c[j], enc[i]);
+			printf("nom=%s\n", nom);
+			nl = setlocale(LC_ALL, nom);
+			printf("locale %s\n", nl);
+			p = localeconv();
+
+			p(strcmp(p->decimal_point, ",") == 0);
+			p(strcmp(p->thousands_sep, ".") == 0);
+			p(p->grouping[0] == 3);
+
+			snprintf(col, sizeof(col), "%f", 1000000.01);
+			p(strcmp(col, "1000000,010000") == 0);
+			snprintf(col, sizeof(col), "%'d", 1000000);
+			printf("col=%s\n", col);
+			p(strcmp(col, "1.000.000") == 0);
+			snprintf(col, sizeof(col), "%'f", 1000000.01);
+			printf("col=%s\n", col);
+			p(strcmp(col, "1.000.000,010000") == 0);
+			p(strcmp(nl_langinfo(RADIXCHAR), ",") == 0);
+			p(strcmp(nl_langinfo(THOUSEP), ".") == 0);
+		}
+	}
+}
+
+void test_radixdot_thousandscomma() 
+{
+	char *c[] = { 
+		"en", "es_CR", "es_MX", "es_PR", "es_SV", "es_US"
+	};
+	char *enc[]= { "ISO8859-1", "ISO8859-15", "UTF-8" };
+	struct lconv *p;
+	char nom[256];
+	char col[512];
+	char *nl;
+	int i, j;
+
+	for(i = 0; i < sizeof(enc) / sizeof(char *) ; i++) {
+		for(j = 0; j < sizeof(c) / sizeof(char *) ; j++) {
+			snprintf(nom, sizeof(nom), "%s.%s", c[j], enc[i]);
+			printf("nom=%s\n", nom);
+			nl = setlocale(LC_ALL, nom);
+			printf("locale %s\n", nl);
+			p = localeconv();
+
+			p(strcmp(p->decimal_point, ".") == 0);
+			p(strcmp(p->thousands_sep, ",") == 0);
+			p(p->grouping[0] == 3);
+
+			snprintf(col, sizeof(col), "%f", 1000000.01);
+			p(strcmp(col, "1000000.010000") == 0);
+			snprintf(col, sizeof(col), "%'d", 1000000);
+			printf("col=%s\n", col);
+			p(strcmp(col, "1,000,000") == 0);
+			snprintf(col, sizeof(col), "%'f", 1000000.01);
+			printf("col=%s\n", col);
+			p(strcmp(col, "1,000,000.010000") == 0);
+			p(strcmp(nl_langinfo(RADIXCHAR), ".") == 0);
+			p(strcmp(nl_langinfo(THOUSEP), ",") == 0);
+		}
+	}
+}
+
+int main()
+{
+	test_posix();
+	test_radixcomma_thousandsdot();
+	test_radixdot_thousandscomma();
+	
+	return bad != 0;
+}
