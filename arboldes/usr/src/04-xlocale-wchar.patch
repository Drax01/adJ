diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/Makefile.inc src/lib/libc/locale/Makefile.inc
--- src53collation/lib/libc/locale/Makefile.inc	Mon Apr  1 08:25:36 2013
+++ src/lib/libc/locale/Makefile.inc	Thu Apr  4 05:27:02 2013
@@ -12,15 +12,19 @@
 	wcstombs.c wctob.c wctomb.c wcstof.c wcstod.c wcstold.c wcstol.c \
 	wcstoul.c wcstoll.c wcstoull.c wcstoimax.c wcstoumax.c \
 	setrunelocale.c runeglue.c rune.c runetable.c ___runetype_mb.c \
-	_wctrans.c wcsxfrm.c collate.c
+	_wctrans.c wcsxfrm.c \
+	collate.c none.c xlocale.c
 
 MAN+=	nl_langinfo.3 setlocale.3 iswalnum.3 towlower.3 \
 	btowc.3 mblen.3 mbrlen.3 mbrtowc.3 mbsinit.3 mbsrtowcs.3 \
 	mbstowcs.3 mbtowc.3 wcrtomb.3 wcsrtombs.3 wcstod.3 wcstol.3 \
 	wcstombs.3 wctob.3 wctomb.3 \
-	wctype.3 iswctype.3 wctrans.3 towctrans.3 wcwidth.3
-MLINKS+=setlocale.3 localeconv.3 \
-	iswalnum.3 iswalpha.3 \
+	wctype.3 iswctype.3 wctrans.3 towctrans.3 wcwidth.3 \
+	duplocale.3  \
+	freelocale.3 newlocale.3 nextwctype.3 \
+	querylocale.3 uselocale.3 wcscoll.3 wcsxfrm.3 xlocale.3
+
+MLINKS+= iswalnum.3 iswalpha.3 \
 	iswalnum.3 iswblank.3 \
 	iswalnum.3 iswcntrl.3 \
 	iswalnum.3 iswdigit.3 \
@@ -31,7 +35,15 @@
 	iswalnum.3 iswspace.3 \
 	iswalnum.3 iswupper.3 \
 	iswalnum.3 iswxdigit.3 \
+	mblen.3 mblen_l.3\
+	mbrtowc.3 mbrtowc_l.3\
+	mbsinit.3 mbsinit_l.3\
+	mbstowcs.3 mbstowcs_l.3\
+	mbtowc.3 mbtowc_l.3\
+	setlocale.3 localeconv.3 \
+	towlower.3 towlower_l.3 \
 	towlower.3 towupper.3 \
+	towlower.3 towupper_l.3 \
 	wcstod.3 wcstof.3 \
 	wcstod.3 wcstold.3 \
 	wcstol.3 wcstoul.3 \
@@ -39,8 +51,15 @@
 	wcstol.3 wcstoull.3 \
 	wcstol.3 wcstoimax.3 \
 	wcstol.3 wcstoumax.3 \
+	wcstombs.3 wcstombs_l.3 \
+	wctob.3 wctob_l.3 \
+	wctomb.3 wctomb_l.3 \
 	mbsrtowcs.3 mbsnrtowcs.3 \
-	wcsrtombs.3 wcsnrtombs.3
+	mbsrtowcs.3 mbsnrtowcs_l.3 \
+	mbsrtowcs.3 mbsrtowcs_l.3 \
+	wcsrtombs.3 wcsnrtombs.3 \
+	wcsrtombs.3 wcsrtombs_l.3 \
+	wcsrtombs.3 wcsnrtombs_l.3
 
 CFLAGS+=-I${.CURDIR} -I${LIBCSRCDIR}/citrus -DCOLLATE_DEBUG
-CFLAGS+=-DLOCALE_CHARSETS="\"${LOCALECHARSETS}\""
+CFLAGS+=-D__NO_TLS -DLOCALE_CHARSETS="\"${LOCALECHARSETS}\""
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/btowc.c src/lib/libc/locale/btowc.c
--- src53collation/lib/libc/locale/btowc.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/btowc.c	Wed Apr  3 11:15:27 2013
@@ -29,9 +29,11 @@
 #include <stdio.h>
 #include <string.h>
 #include <wchar.h>
+#include <xlocale.h>
+#include "xlocale_private.h"
 
 wint_t
-btowc(int c)
+btowc_l(int c, locale_t loc)
 {
 	mbstate_t mbs;
 	char cc;
@@ -46,7 +48,14 @@
 	 */
 	memset(&mbs, 0, sizeof(mbs));
 	cc = (char)c;
-	if (mbrtowc(&wc, &cc, 1, &mbs) > 1)
+	if (mbrtowc_l(&wc, &cc, 1, &mbs, loc) > 1)
 		return (WEOF);
 	return (wc);
+}
+
+
+wint_t
+btowc(int c)
+{
+	return btowc_l(c, __get_locale());
 }
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/collate.c src/lib/libc/locale/collate.c
--- src53collation/lib/libc/locale/collate.c	Mon Apr  1 08:25:36 2013
+++ src/lib/libc/locale/collate.c	Wed Apr  3 06:29:38 2013
@@ -66,32 +66,44 @@
 int __collate_load_error;
 
 
-struct __collate __global_collate = {
-	1, 0
+struct xlocale_collate __xlocale_global_collate = {
+	{{0}, "C"}, 1, 0
 };
 
-struct __collate __C_collate = {
-	1, 0
+struct xlocale_collate __xlocale_C_collate = {
+	{{0}, "C"}, 1, 0
 };
 
 int
-__collate_load_tables_l(const char *encoding, struct __collate *table);
+__collate_load_tables_l(const char *encoding, struct xlocale_collate *table);
 
+
+static void
+destruct_collate(void *t)
+{
+	struct xlocale_collate *table = t;
+	if (table->__collate_chain_pri_table) {
+		free(table->__collate_chain_pri_table);
+	}
+	free(t);
+}
+
 /*
  * Allocates space and loads collation table for the given locale and 
  * returns it
  */
 void *
-__collate_load(const char *encoding)
+__collate_load(const char *encoding, locale_t unused)
 {
-	struct __collate *table;
+	struct xlocale_collate *table;
 
 	if (strcmp(encoding, "C") == 0 || strcmp(encoding, "POSIX") == 0) {
-		return &__C_collate;
+		return &__xlocale_C_collate;
 	}
-	table = calloc(sizeof(struct __collate), 1);
+	table = calloc(sizeof(struct xlocale_collate), 1);
+	table->header.header.destructor = destruct_collate;
 	if (__collate_load_tables_l(encoding, table) != _LDP_LOADED) {
-		free(table);
+		xlocale_release(table);
 		return NULL;
 	}
 
@@ -104,9 +116,9 @@
 int
 __collate_load_tables(const char *encoding)
 {
-	int ret = __collate_load_tables_l(encoding, &__global_collate);
+	int ret = __collate_load_tables_l(encoding, &__xlocale_global_collate);
 
-	__collate_load_error = __global_collate.__collate_load_error;
+	__collate_load_error = __xlocale_global_collate.__collate_load_error;
 	return ret;
 }
 
@@ -136,7 +148,7 @@
  * 		before the 4 bytes of the integer prim.
  */
 int
-__collate_load_tables_l(const char *locname, struct __collate *table)
+__collate_load_tables_l(const char *locname, struct xlocale_collate *table)
 {
 	FILE *fp = NULL;
 	int i, saverr, chains, len;
@@ -294,7 +306,7 @@
  * table applied to the wide string s.
  */
 wchar_t *
-__collate_substitute_w(struct __collate *table, const wchar_t *wcs)
+__collate_substitute_w(struct xlocale_collate *table, const wchar_t *wcs)
 {
 	int dest_len, len, nlen;
 	size_t delta = wcslen(wcs);
@@ -362,7 +374,7 @@
  * beginning in t. In len returns the amount of characters of t processed.
  */
 void
-__collate_lookup_w(struct __collate *table, const wchar_t *t, int *len, 
+__collate_lookup_w(struct xlocale_collate *table, const wchar_t *t, int *len, 
 		int *prim, int *sec)
 {
 	struct __collate_st_chain_pri *p2;
@@ -385,13 +397,13 @@
 
 #ifdef COLLATE_DEBUG
 void
-__collate_print_tables(struct __collate *table)
+__collate_print_tables(struct xlocale_collate *table)
 {
 	int i;
 	struct __collate_st_chain_pri *p2;
 
 	if (table == NULL) {
-		table = &__global_collate;
+		table = &__xlocale_global_collate;
  	}
 
 	printf("Substitute table:\n");
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/collate.h src/lib/libc/locale/collate.h
--- src53collation/lib/libc/locale/collate.h	Mon Apr  1 08:25:36 2013
+++ src/lib/libc/locale/collate.h	Wed Apr  3 06:20:57 2013
@@ -64,9 +64,12 @@
 
 #include <sys/cdefs.h>
 #include <sys/types.h>
+
 #include <limits.h>
 #include <wchar.h>
 
+#include "xlocale_private.h"
+
 #define COLLATE_MAX_STR_LEN 10
 #define COLLATE_VERSION1_2 "1.2\n"
 
@@ -78,7 +81,8 @@
 	int prim, sec;
 };
 
-struct __collate {
+struct xlocale_collate {
+	struct xlocale_component header;
 	int __collate_load_error;
 	int __collate_substitute_nontrivial;
 
@@ -89,15 +93,15 @@
 
 
 /* Current LC_COLLATE */
-struct __collate __global_collate;
+struct xlocale_collate __xlocale_global_collate;
 
 __BEGIN_DECLS
-wchar_t *__collate_substitute_w(struct __collate *table, const wchar_t *s);
-void 	__collate_lookup_w(struct __collate *table, const wchar_t *t, int *len, int *prim, int *sec);
+wchar_t *__collate_substitute_w(struct xlocale_collate *table, const wchar_t *s);
+void 	__collate_lookup_w(struct xlocale_collate *table, const wchar_t *t, int *len, int *prim, int *sec);
 int	__collate_load_tables(const char *);
-int	__collate_range_cmp(struct __collate *, int, int);
+int	__collate_range_cmp(struct xlocale_collate *, int, int);
 #ifdef COLLATE_DEBUG
-void	__collate_print_tables(struct __collate *);
+void	__collate_print_tables(struct xlocale_collate *);
 #endif
 int 	strncmp_wc(wchar_t *ws, char *cs, size_t l);
 wchar_t *__dup_as_wcs_l(const char *s);
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/duplocale.3 src/lib/libc/locale/duplocale.3
--- src53collation/lib/libc/locale/duplocale.3	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/duplocale.3	Tue Apr  2 06:11:30 2013
@@ -0,0 +1,79 @@
+.\" Copyright (c) 2011 The FreeBSD Foundation
+.\" All rights reserved.
+.\"
+.\" This documentation was written by David Chisnall under sponsorship from
+.\" the FreeBSD Foundation.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD: src/lib/libc/locale/duplocale.3,v 1.6 2012/11/17 01:49:29 svnexp Exp $
+.\"
+.Dd September 17 2011
+.Dt DUPLOCALE 3
+.Os
+.Sh NAME
+.Nm duplocale
+.Nd duplicate an locale
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.In xlocale.h
+.Ft locale_t
+.Fn duplocale "locale_t locale"
+.Sh DESCRIPTION
+Duplicates an existing
+.Fa locale_t
+returning a new
+.Fa locale_t
+that refers to the same locale values but has an independent internal state.
+Various functions, such as
+.Xr mblen 3
+require a persistent state.
+These functions formerly used static variables and calls to them from multiple
+threads had undefined behavior.
+They now use fields in the
+.Fa locale_t
+associated with the current thread by
+.Xr uselocale 3 .
+These calls are therefore only thread safe on threads with a unique per-thread
+locale.
+The locale returned by this call must be freed with
+.Xr freelocale 3 .
+.Sh SEE ALSO
+.Xr freelocale 3 ,
+.Xr localeconv 3 ,
+.Xr newlocale 3 ,
+.Xr querylocale 3 ,
+.Xr uselocale 3 ,
+.Xr xlocale 3
+.Sh STANDARDS
+This function, conforms to
+.St -p1003.1-2008
+.Sh BUGS
+Ideally,
+.Xr uselocale 3
+should make a copy of the
+.Fa locale_t
+implicitly to ensure thread safety,
+and a copy of the global locale should be installed lazily on each thread.
+The FreeBSD implementation does not do this,
+for compatibility with Darwin.
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/freelocale.3 src/lib/libc/locale/freelocale.3
--- src53collation/lib/libc/locale/freelocale.3	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/freelocale.3	Tue Apr  2 06:11:30 2013
@@ -0,0 +1,61 @@
+.\" Copyright (c) 2011 The FreeBSD Foundation
+.\" All rights reserved.
+.\"
+.\" This documentation was written by David Chisnall under sponsorship from
+.\" the FreeBSD Foundation.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD: src/lib/libc/locale/freelocale.3,v 1.4 2012/11/17 01:49:29 svnexp Exp $
+.Dd September 17 2011
+.Dt FREELOCALE 3
+.Os
+.Sh NAME
+.Nm freelocale
+.Nd Frees a locale created with
+.Xr duplocale 3
+or
+.Xr newlocale 3
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.In xlocale.h
+.Ft int
+.Fn freelocale "locale_t locale"
+.Sh DESCRIPTION
+Frees a
+.Fa locale_t .
+This relinquishes any resources held exclusively by this locale.
+Note that locales share reference-counted components,
+so a call to this function is not guaranteed to free all of the components.
+.Sh RETURN VALUES
+Returns 0 on success or -1 on error.
+.Sh SEE ALSO
+.Xr duplocale 3 ,
+.Xr localeconv 3 ,
+.Xr newlocale 3 ,
+.Xr querylocale 3 ,
+.Xr uselocale 3 ,
+.Xr xlocale 3
+.Sh STANDARDS
+This function, conforms to
+.St -p1003.1-2008 .

diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/mblen.3 src/lib/libc/locale/mblen.3
--- src53collation/lib/libc/locale/mblen.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/mblen.3	Wed Apr  3 11:15:27 2013
@@ -31,21 +31,26 @@
 .\" ----------------------------------------------------------------------
 .Sh NAME
 .Nm mblen
+.Nm mblen_l
 .Nd get number of bytes in a multibyte character
 .\" ----------------------------------------------------------------------
 .Sh SYNOPSIS
 .In stdlib.h
 .Ft int
 .Fn mblen "const char *s" "size_t n"
+.Ft int
+.Fn mblen_l "const char *s" "size_t n" "locale_t l"
 .\" ----------------------------------------------------------------------
 .Sh DESCRIPTION
-The
+The functions
 .Fn mblen
-function usually determines the number of bytes in
+and
+.Fn mblen_l
+usually determines the number of bytes in
 a multibyte character pointed to by
 .Fa s
-and returns it.
-This function shall only examine max n bytes of the array beginning from
+and return it.
+These functions shall only examine max n bytes of the array beginning from
 .Fa s .
 .Pp
 In state-dependent encodings,
@@ -93,7 +98,10 @@
 .Fn mblen
 is affected by the
 .Dv LC_CTYPE
-category of the current locale.
+category of the current locale.  The funcion
+.Fn mblen_l
+allows you to provide a different locale, see
+.Xr xlocale 3
 .Pp
 There are special cases:
 .Bl -tag -width 0123456789
@@ -170,6 +178,7 @@
 .Xr mbrlen 3 ,
 .Xr mbtowc 3 ,
 .Xr setlocale 3
+.Xr xlocale 3
 .\" ----------------------------------------------------------------------
 .Sh STANDARDS
 The
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/mblen.c src/lib/libc/locale/mblen.c
--- src53collation/lib/libc/locale/mblen.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/mblen.c	Wed Apr  3 11:15:27 2013
@@ -29,9 +29,12 @@
 #include <stdlib.h>
 #include <string.h>
 #include <wchar.h>
+#include <xlocale.h>
+#include "../locale/xlocale_private.h"
 
+
 int
-mblen(const char *s, size_t n)
+mblen_l(const char *s, size_t n, locale_t loc)
 {
 	static mbstate_t mbs;
 	size_t rval;
@@ -41,8 +44,15 @@
 		memset(&mbs, 0, sizeof(mbs));
 		return (0);
 	}
-	rval = mbrtowc(NULL, s, n, &mbs);
+	rval = mbrtowc_l(NULL, s, n, &mbs, loc);
 	if (rval == (size_t)-1 || rval == (size_t)-2)
 		return (-1);
 	return ((int)rval);
+}
+
+
+int
+mblen(const char *s, size_t n)
+{
+	return mblen_l(s, n, __get_locale());
 }
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/mblocal.h src/lib/libc/locale/mblocal.h
--- src53collation/lib/libc/locale/mblocal.h	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/mblocal.h	Tue Apr  2 13:42:13 2013
@@ -0,0 +1,79 @@
+/*-
+ * Copyright (c) 2004 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Copyright (c) 2011 The FreeBSD Foundation
+ * All rights reserved.
+ * Portions of this software were developed by David Chisnall
+ * under sponsorship from the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * From FreeBSD
+ */
+
+#ifndef _MBLOCAL_H_
+#define	_MBLOCAL_H_
+
+#include "runetype.h"
+#include "xlocale_private.h"
+
+
+/*
+ * Conversion function pointers for current encoding.
+ */
+struct xlocale_ctype {
+	struct xlocale_component header;
+	_RuneLocale *runes;
+	size_t (*__mbrtowc)(wchar_t * __restrict, const char * __restrict,
+		size_t, mbstate_t * __restrict);
+	int (*__mbsinit)(const mbstate_t *);
+	size_t (*__mbsnrtowcs)(wchar_t * __restrict, const char ** __restrict,
+		size_t, size_t, mbstate_t * __restrict);
+	size_t (*__wcrtomb)(char * __restrict, wchar_t, mbstate_t * __restrict);
+	size_t (*__wcsnrtombs)(char * __restrict, const wchar_t ** __restrict,
+		size_t, size_t, mbstate_t * __restrict);
+	int __mb_cur_max;
+	int __mb_sb_limit;
+};
+#define XLOCALE_CTYPE(x) ((struct xlocale_ctype*)(x)->components[XLC_CTYPE])
+extern struct xlocale_ctype __xlocale_global_ctype;
+
+/*
+ * Rune initialization function prototypes.
+ */
+int	_none_init(struct xlocale_ctype *, _RuneLocale *);
+int	_ascii_init(struct xlocale_ctype *, _RuneLocale *);
+int	_UTF8_init(struct xlocale_ctype *, _RuneLocale *);
+int	_EUC_init(struct xlocale_ctype *, _RuneLocale *);
+int	_GB18030_init(struct xlocale_ctype *, _RuneLocale *);
+int	_GB2312_init(struct xlocale_ctype *, _RuneLocale *);
+int	_GBK_init(struct xlocale_ctype *, _RuneLocale *);
+int	_BIG5_init(struct xlocale_ctype *, _RuneLocale *);
+int	_MSKanji_init(struct xlocale_ctype *, _RuneLocale *);
+
+extern size_t __mbsnrtowcs_std(wchar_t * __restrict, const char ** __restrict,
+	size_t, size_t, mbstate_t * __restrict);
+extern size_t __wcsnrtombs_std(char * __restrict, const wchar_t ** __restrict,
+	size_t, size_t, mbstate_t * __restrict);
+
+#endif	/* _MBLOCAL_H_ */
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/mbrlen.c src/lib/libc/locale/mbrlen.c
--- src53collation/lib/libc/locale/mbrlen.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/mbrlen.c	Wed Apr  3 11:15:27 2013
@@ -27,13 +27,23 @@
  */
 
 #include <wchar.h>
+#include <locale.h>
+#include "../locale/xlocale_private.h"
 
 size_t
-mbrlen(const char * __restrict s, size_t n, mbstate_t * __restrict ps)
+mbrlen_l(const char * __restrict s, size_t n, mbstate_t * __restrict ps,
+		locale_t loc)
 {
 	static mbstate_t mbs;
 
+	memset(&mbs, 0, sizeof(mbs)); 
 	if (ps == NULL)
 		ps = &mbs;
-	return (mbrtowc(NULL, s, n, ps));
+	return (mbrtowc_l(NULL, s, n, ps, loc));
+}
+
+size_t
+mbrlen(const char * __restrict s, size_t n, mbstate_t * __restrict ps)
+{
+	return mbrlen_l(s, n, ps, __get_locale());
 }
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53/lib/libc/locale/mbrtowc.3 src/lib/libc/locale/mbrtowc.3
--- src53/lib/libc/locale/mbrtowc.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/mbrtowc.3	Tue Apr  9 09:45:12 2013
@@ -29,21 +29,27 @@
 .Dt MBRTOWC 3
 .Os
 .Sh NAME
-.Nm mbrtowc
-.Nd converts a multibyte character to a wide character (restartable)
+.Nm mbrtowc ,
+.Nm mbrtowc_l
+.Nd convert a multibyte character to a wide character (restartable)
 .Sh SYNOPSIS
 .In wchar.h
 .Ft size_t
 .Fn mbrtowc "wchar_t * restrict wc" "const char * restrict s" "size_t n" \
 "mbstate_t * restrict mbs"
+.Ft size_t
+.Fn mbrtowc_l "wchar_t * restrict wc" "const char * restrict s" "size_t n" \
+"mbstate_t * restrict mbs" "locale_t l"
 .Sh DESCRIPTION
-The
+The functions
 .Fn mbrtowc
-function examines at most
+and
+.Fn mbrtowc_l
+examine at most
 .Fa n
 bytes of the multibyte character byte string pointed to by
 .Fa s ,
-converts those bytes to a wide character, and stores the wide character
+convert those bytes to a wide character, and store the wide character
 in the wchar_t object pointed to by
 .Fa wc
 if
@@ -59,9 +65,10 @@
 .Fa mbs .
 The mbstate_t object must be initialized to zero before the application's
 first call to
-.Fn mbrtowc .
-If the previous call to
 .Fn mbrtowc
+or
+.Fn mbrtowc_l .
+If the previous call to the function
 did not return (size_t)-1, the mbstate_t object can safely be reused
 without reinitialization.
 .Pp
@@ -69,7 +76,12 @@
 .Fn mbrtowc
 is affected by the
 .Dv LC_CTYPE
-category of the current locale.
+category of the current locale, while the behavior of
+.Fn mbrtowc_l
+is affected by the
+.Dv LC_CTYPE
+category of the locale provided as parameter, see
+.Xr xlocale 3
 If the locale is changed without reinitialization of the mbstate_t object
 pointed to by
 .Fa mbs ,
@@ -238,12 +250,14 @@
 .Sh SEE ALSO
 .Xr mbrlen 3 ,
 .Xr mbtowc 3 ,
-.Xr setlocale 3
+.Xr setlocale 3,
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn mbrtowc
 function conforms to
 .\" .St -isoC-amd1 .
+POSIX 2008,
 ISO/IEC 9899/AMD1:1995
 .Pq Dq ISO C90, Amendment 1 .
 The restrict qualifier is added at
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/mbsinit.3 src/lib/libc/locale/mbsinit.3
--- src53collation/lib/libc/locale/mbsinit.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/mbsinit.3	Wed Apr  3 11:15:27 2013
@@ -30,20 +30,32 @@
 .Os
 .\" ----------------------------------------------------------------------
 .Sh NAME
-.Nm mbsinit
-.Nd determines whether the state object is in initial state
+.Nm mbsinit ,
+.Nm mbsinit_l
+.Nd determine whether the state object is in initial state
 .\" ----------------------------------------------------------------------
 .Sh SYNOPSIS
 .In wchar.h
 .Ft int
 .Fn mbsinit "const mbstate_t *ps"
+.In xlocale.h
+.Ft int
+.Fn mbsinit_l "const mbstate_t *ps" "locale_t"
 .\" ----------------------------------------------------------------------
 .Sh DESCRIPTION
 .Fn mbsinit
-determines whether the state object pointed to by
+and
+.Fn mbsinit_l
+determine whether the state object pointed to by
 .Fa ps
 is in initial conversion state, or not.
 .Pp
+The behavior of
+.Fn mbsinit
+depends on the current locale, while the behavior of
+.Fn mbsinit_l
+depends on the locale provided as parameter, see
+.Xr xlocale 3 .
 .Fa ps
 may be a
 .Dv NULL
@@ -74,5 +86,6 @@
 .Fn mbsinit
 conforms to
 .\" .St -isoC-amd1 .
+POSIX 2008,
 ISO/IEC 9899/AMD1:1995
 .Pq Dq ISO C90, Amendment 1 .
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/mbsrtowcs.3 src/lib/libc/locale/mbsrtowcs.3
--- src53collation/lib/libc/locale/mbsrtowcs.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/mbsrtowcs.3	Wed Apr  3 11:15:27 2013
@@ -31,7 +31,9 @@
 .\" ----------------------------------------------------------------------
 .Sh NAME
 .Nm mbsrtowcs ,
-.Nm mbsnrtowcs
+.Nm mbsrtowcs_l ,
+.Nm mbsnrtowcs ,
+.Nm mbsnrtowcs_l
 .Nd converts a multibyte character string to a wide-character string \
 (restartable)
 .\" ----------------------------------------------------------------------
@@ -39,15 +41,21 @@
 .Fd #include <wchar.h>
 .Ft size_t
 .Fn mbsrtowcs "wchar_t * restrict dst" "const char ** restrict src" "size_t len" \
-"mbstate_t * restrict ps"
 .Ft size_t
+.Fn mbsrtowcs_l "wchar_t * restrict dst" "const char ** restrict src" "size_t len" \
+"mbstate_t * restrict ps" "locale_t l"
+.Ft size_t
 .Fn mbsnrtowcs "wchar_t * restrict dst" "const char ** restrict src" "size_t nmc" \
-"size_t len" "mbstate_t * restrict ps"
+.Ft size_t
+.Fn mbsnrtowcs_l "wchar_t * restrict dst" "const char ** restrict src" "size_t nmc" \
+"size_t len" "mbstate_t * restrict ps" "locale_t l"
 .\" ----------------------------------------------------------------------
 .Sh DESCRIPTION
-The
+The functions
 .Fn mbsrtowcs
-function converts the multibyte character string indirectly pointed to by
+and
+.Fn mbsrtowcs_l
+convert the multibyte character string indirectly pointed to by
 .Fa src
 to the corresponding wide-character string and stores it in the
 array pointed to by
@@ -66,10 +74,12 @@
 .El
 .Pp
 The
-.Fn mbsnrtowcs
-function is equivalent to
+.Fn mbsnrtowcs 
+and
+.Fn mbsnrtowcs_l
+functions are equivalent to
 .Fn mbsrtowcs
-except that it will additionally stop the conversion after processing
+except that they will additionally stop the conversion after processing
 .Fa nmc
 bytes.
 .Pp
@@ -100,7 +110,15 @@
 .Fn mbsnrtowcs
 functions is affected by the
 .Dv LC_CTYPE
-category of the current locale.
+category of the current locale, while the
+behaviour of the
+.Fn mbsrtowcs_l
+and
+.Fn mbsnrtowcs_l
+functions is affected by the
+.Dv LC_CTYPE
+category of the locale provided as parameter, see 
+.Xr xlocale 3
 .Pp
 There are two special cases:
 .Bl -tag -width 012345678901
@@ -113,10 +131,7 @@
 .Fa len
 is ignored.
 .It "ps == NULL"
-The
-.Fn mbsrtowcs
-and
-.Fn mbsnrtowcs
+These functions
 functions use their own internal state objects to keep the conversion state,
 instead of
 .Fa ps
@@ -130,9 +145,10 @@
 .\" ----------------------------------------------------------------------
 .Sh RETURN VALUES
 The
-.Fn mbsrtowcs
-and
-.Fn mbsnrtowcs
+.Fn mbsrtowcs ,
+.Fn mbsrtowcs_l ,
+.Fn mbsnrtowcs ,
+.Fn mbsnrtowcs_l
 functions return:
 .Bl -tag -width 012345678901
 .It 0 or positive
@@ -160,10 +176,7 @@
 .El
 .\" ----------------------------------------------------------------------
 .Sh ERRORS
-The
-.Fn mbsrtowcs
-and
-.Fn mbsnrtowcs
+These
 functions may return the following errors:
 .Bl -tag -width Er
 .It Bq Er EILSEQ
@@ -179,12 +192,14 @@
 .Xr mbrtowc 3 ,
 .Xr mbstowcs 3 ,
 .Xr setlocale 3
+.Xr xlocale 3
 .\" ----------------------------------------------------------------------
 .Sh STANDARDS
 The
 .Fn mbsrtowcs
 function conforms to
 .\" .St -isoC-amd1 .
+POSIX 2008,
 ISO/IEC 9899/AMD1:1995
 .Pq Dq ISO C90, Amendment 1 .
 The restrict qualifier is added at
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/mbstowcs.3 src/lib/libc/locale/mbstowcs.3
--- src53collation/lib/libc/locale/mbstowcs.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/mbstowcs.3	Wed Apr  3 11:15:27 2013
@@ -30,23 +30,30 @@
 .Os
 .\" ----------------------------------------------------------------------
 .Sh NAME
-.Nm mbstowcs
-.Nd converts a multibyte character string to a wide-character string
+.Nm mbstowcs ,
+.Nm mbstowcs_l
+.Nd convert a multibyte character string to a wide-character string
 .\" ----------------------------------------------------------------------
 .Sh SYNOPSIS
 .In stdlib.h
 .Ft size_t
 .Fn mbstowcs "wchar_t * restrict pwcs" "const char * restrict s" "size_t n"
+.In xlocale.h
+.Ft size_t
+.Fn mbstowcs_l "wchar_t * restrict pwcs" "const char * restrict s" "size_t n" "locale_t l"
+.\" ----------------------------------------------------------------------
 .\" ----------------------------------------------------------------------
 .Sh DESCRIPTION
-The
+The functions
 .Fn mbstowcs
-converts a null-terminated multibyte character string pointed to by
+and
+.Fn mbstowcs_l
+convert a null-terminated multibyte character string pointed to by
 .Fa s
-to the corresponding wide-character string and stores it in the array
+to the corresponding wide-character string and store it in the array
 pointed to by
 .Fa pwcs .
-This function may modify the first at most
+These functions may modify the first at most
 .Fa n
 elements of the array pointed to by
 .Fa pwcs .
@@ -56,6 +63,13 @@
 .Xr mbtowc 3
 will not be affected.
 .Pp
+The funcion
+.Fn mbstowcs
+uses the current locale, while
+.Fn mbstowcs_l
+uses the locale provided, see
+.Xr xlocale 3
+.Pp
 For state-dependent encoding,
 .Fn mbstowcs
 implies the multibyte character string pointed to by
@@ -117,7 +131,8 @@
 .\" ----------------------------------------------------------------------
 .Sh SEE ALSO
 .Xr mbtowc 3 ,
-.Xr setlocale 3
+.Xr setlocale 3 ,
+.Xr xlocale 3
 .\" ----------------------------------------------------------------------
 .Sh STANDARDS
 The
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/mbstowcs.c src/lib/libc/locale/mbstowcs.c
--- src53collation/lib/libc/locale/mbstowcs.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/mbstowcs.c	Wed Apr  3 11:15:27 2013
@@ -31,14 +31,25 @@
 #include <stdlib.h>
 #include <string.h>
 #include <wchar.h>
+#include <xlocale.h>
+#include "xlocale_private.h"
 
+
+
 size_t
-mbstowcs(wchar_t * __restrict pwcs, const char * __restrict s, size_t n)
+mbstowcs_l(wchar_t * __restrict pwcs, const char * __restrict s, size_t n, 
+		locale_t l)
 {
 	mbstate_t mbs;
 	const char *sp;
 
 	memset(&mbs, 0, sizeof(mbs));
 	sp = s;
-	return (mbsrtowcs(pwcs, &sp, n, &mbs));
+	return (mbsrtowcs_l(pwcs, &sp, n, &mbs, l));
+}
+
+size_t
+mbstowcs(wchar_t * __restrict pwcs, const char * __restrict s, size_t n)
+{
+	return mbstowcs_l(pwcs, s, n, __get_locale());
 }
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/mbtowc.3 src/lib/libc/locale/mbtowc.3
--- src53collation/lib/libc/locale/mbtowc.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/mbtowc.3	Wed Apr  3 11:15:27 2013
@@ -30,26 +30,33 @@
 .Os
 .\" ----------------------------------------------------------------------
 .Sh NAME
-.Nm mbtowc
-.Nd converts a multibyte character to a wide character
+.Nm mbtowc ,
+.Nm mbtowc_l
+.Nd convert a multibyte character to a wide character
 .\" ----------------------------------------------------------------------
 .Sh SYNOPSIS
 .In stdlib.h
 .Ft int
 .Fn mbtowc "wchar_t * restrict pwc" "const char * restrict s" "size_t n"
+.In xlocale.h
+.Ft int
+.Fn mbtowc_l "wchar_t * restrict pwc" "const char * restrict s" "size_t n" "locale_t l"
 .Sh DESCRIPTION
-The
+.Sh DESCRIPTION
+The functions
 .Fn mbtowc
-usually converts the multibyte character pointed to by
+and 
+.Fn mbtowc_l
+usually convert the multibyte character pointed to by
 .Fa s
-to a wide character, and stores it in the wchar_t object pointed to by
+to a wide character, and store it in the wchar_t object pointed to by
 .Fa pwc
 if
 .Fa pwc
 is non-null and
 .Fa s
 points to a valid character.
-This function may inspect at most n bytes of the array beginning from
+These functions may inspect at most n bytes of the array beginning from
 .Fa s .
 .Pp
 In state-dependent encodings,
@@ -88,7 +95,10 @@
 .Fn mbtowc
 is affected by the
 .Dv LC_CTYPE
-category of the current locale.
+category of the current locale, while
+.Fn mbtowc_l
+uses the locale provided as parameter, see
+.Xr xlocale 3
 .Pp
 These are the special cases:
 .Bl -tag -width 012345678901
@@ -166,7 +176,8 @@
 .Sh SEE ALSO
 .Xr mblen 3 ,
 .Xr mbrtowc 3 ,
-.Xr setlocale 3
+.Xr setlocale 3 ,
+.Xr xlocale 3
 .\" ----------------------------------------------------------------------
 .Sh STANDARDS
 The
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/mbtowc.c src/lib/libc/locale/mbtowc.c
--- src53collation/lib/libc/locale/mbtowc.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/mbtowc.c	Wed Apr  3 11:15:27 2013
@@ -31,9 +31,12 @@
 #include <string.h>
 #include <wchar.h>
 #include <errno.h>
+#include <locale.h>
+#include "../locale/xlocale_private.h"
 
 int
-mbtowc(wchar_t * __restrict pwc, const char * __restrict s, size_t n)
+mbtowc_l(wchar_t * __restrict pwc, const char * __restrict s, size_t n, 
+		locale_t loc)
 {
 	static mbstate_t mbs;
 	size_t rval;
@@ -43,8 +46,15 @@
 		memset(&mbs, 0, sizeof(mbs));
 		return (0);
 	}
-	rval = mbrtowc(pwc, s, n, &mbs);
+	rval = mbrtowc_l(pwc, s, n, &mbs, loc);
 	if (rval == (size_t)-1 || rval == (size_t)-2)
 		return (-1);
 	return ((int)rval);
+}
+
+
+int
+mbtowc(wchar_t * __restrict pwc, const char * __restrict s, size_t n)
+{
+	return mbtowc_l(pwc, s, n, __get_locale());
 }
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/multibyte_citrus.c src/lib/libc/locale/multibyte_citrus.c
--- src53collation/lib/libc/locale/multibyte_citrus.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/multibyte_citrus.c	Wed Apr  3 11:35:50 2013
@@ -31,13 +31,18 @@
 #include <errno.h>
 #include <limits.h>
 #include <wchar.h>
+#include <xlocale.h>
+#include "runetype.h"
 
 #include "citrus_ctype.h"
 #include "rune.h"
 #include "multibyte.h"
+#include "mblocal.h"
+#include "xlocale_private.h"
 
+
 int
-mbsinit(const mbstate_t *ps)
+mbsinit_l(const mbstate_t *ps, locale_t loc)
 {
 	struct _citrus_ctype_rec *cc;
 	_RuneLocale *rl;
@@ -46,80 +51,140 @@
 		return 1;
 
 	rl = _ps_to_runelocale(ps);
-	if (rl == NULL)
-		rl = _CurrentRuneLocale;
+	if (rl == NULL) {
+		FIX_LOCALE(loc);
+		rl = XLOCALE_CTYPE(loc)->runes;
+	}
 	cc = rl->rl_citrus_ctype;
 	return (*cc->cc_ops->co_mbsinit)(ps);
 }
 
+int
+mbsinit(const mbstate_t *ps)
+{
+       return mbsinit_l(ps, __get_locale());
+}
+
 size_t
-mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
+mbrtowc_l(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps, locale_t l)
 {
 	static mbstate_t mbs;
 	struct _citrus_ctype_rec *cc;
 
 	if (ps == NULL)
 		ps = &mbs;
-	cc = _CurrentRuneLocale->rl_citrus_ctype;
+	FIX_LOCALE(l);
+	_RuneLocale *rl = XLOCALE_CTYPE(l)->runes;
+	cc = rl->rl_citrus_ctype;
 	return (*cc->cc_ops->co_mbrtowc)(pwc, s, n, _ps_to_private(ps));
 }
 
 size_t
+mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
+{
+	return mbrtowc_l(pwc, s, n, ps, __get_locale());
+}
+
+size_t
 mbsrtowcs(wchar_t *dst, const char **src, size_t len, mbstate_t *ps)
 {
 	static mbstate_t mbs;
 
 	if (ps == NULL)
 		ps = &mbs;
-	return (mbsnrtowcs(dst, src, SIZE_MAX, len, ps));
+	return (mbsnrtowcs_l(dst, src, SIZE_MAX, len, ps, __get_locale()));
 }
 
 size_t
-mbsnrtowcs(wchar_t *dst, const char **src, size_t nmc, size_t len,
-    mbstate_t *ps)
+mbsrtowcs_l(wchar_t *dst, const char **src, size_t len, mbstate_t *ps,
+    locale_t l)
 {
 	static mbstate_t mbs;
+
+	if (ps == NULL)
+		ps = &mbs;
+	return (mbsnrtowcs_l(dst, src, SIZE_MAX, len, ps, l));
+}
+
+size_t
+mbsnrtowcs_l(wchar_t *dst, const char **src, size_t nmc, size_t len,
+    mbstate_t *ps, locale_t l)
+{
+	static mbstate_t mbs;
 	struct _citrus_ctype_rec *cc;
 
 	if (ps == NULL)
 		ps = &mbs;
-	cc = _CurrentRuneLocale->rl_citrus_ctype;
+	FIX_LOCALE(l);
+	_RuneLocale *rl = XLOCALE_CTYPE(l)->runes;
+	cc = rl->rl_citrus_ctype;
 	return (*cc->cc_ops->co_mbsnrtowcs)(dst, src, nmc, len,
 	    _ps_to_private(ps));
 }
 
 size_t
-wcrtomb(char *s, wchar_t wc, mbstate_t *ps)
+mbsnrtowcs(wchar_t *dst, const char **src, size_t nmc, size_t len,
+    mbstate_t *ps)
 {
+	return mbsnrtowcs_l(dst, src, nmc, len, ps, __get_locale());
+}
+
+size_t
+wcrtomb_l(char *s, wchar_t wc, mbstate_t *ps, locale_t l)
+{
 	static mbstate_t mbs;
 	struct _citrus_ctype_rec *cc;
 
 	if (ps == NULL)
 		ps = &mbs;
-	cc = _CurrentRuneLocale->rl_citrus_ctype;
+	FIX_LOCALE(l);
+	_RuneLocale *rl = XLOCALE_CTYPE(l)->runes;
+	cc = rl->rl_citrus_ctype;
 	return (*cc->cc_ops->co_wcrtomb)(s, wc, _ps_to_private(ps));
 }
 
 size_t
-wcsrtombs(char *dst, const wchar_t **src, size_t len, mbstate_t *ps)
+wcrtomb(char *s, wchar_t wc, mbstate_t *ps)
 {
+	return wcrtomb_l(s, wc, ps, __get_locale());
+}
+
+size_t
+wcsrtombs_l(char *dst, const wchar_t **src, size_t len, mbstate_t *ps,
+    locale_t l)
+{
 	static mbstate_t mbs;
 
 	if (ps == NULL)
 		ps = &mbs;
-	return (wcsnrtombs(dst, src, SIZE_MAX, len, ps));
+	return (wcsnrtombs_l(dst, src, SIZE_MAX, len, ps, l));
 }
 
 size_t
-wcsnrtombs(char *dst, const wchar_t **src, size_t nwc, size_t len,
-    mbstate_t *ps)
+wcsrtombs(char *dst, const wchar_t **src, size_t len, mbstate_t *ps)
 {
+	return wcsrtombs_l(dst, src, len, ps, __get_locale());
+}
+
+size_t
+wcsnrtombs_l(char *dst, const wchar_t **src, size_t nwc, size_t len,
+    mbstate_t *ps, locale_t l)
+{
 	static mbstate_t mbs;
 	struct _citrus_ctype_rec *cc;
 
 	if (ps == NULL)
 		ps = &mbs;
-	cc = _CurrentRuneLocale->rl_citrus_ctype;
+	FIX_LOCALE(l);
+	_RuneLocale *rl = XLOCALE_CTYPE(l)->runes;
+	cc = rl->rl_citrus_ctype;
 	return (*cc->cc_ops->co_wcsnrtombs)(dst, src, nwc, len,
 	    _ps_to_private(ps));
+}
+
+size_t
+wcsnrtombs(char *dst, const wchar_t **src, size_t nwc, size_t len,
+    mbstate_t *ps)
+{
+	return wcsnrtombs_l(dst, src, nwc, len, ps, __get_locale());
 }
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/newlocale.3 src/lib/libc/locale/newlocale.3
--- src53collation/lib/libc/locale/newlocale.3	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/newlocale.3	Tue Apr  2 06:11:30 2013
@@ -0,0 +1,112 @@
+.\" Copyright (c) 2011 The FreeBSD Foundation
+.\" All rights reserved.
+.\"
+.\" This documentation was written by David Chisnall under sponsorship from
+.\" the FreeBSD Foundation.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" From FreeBSD src/lib/libc/locale/newlocale.3,v 1.8 2012/11/17 01:49:30 svnexp Exp 
+.Dd September 17 2011
+.Dt NEWLOCALE 3
+.Os
+.Sh NAME
+.Nm newlocale
+.Nd Creates a new locale
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.In xlocale
+.Ft locale_t
+.Fn newlocale "int mask" "const char * locale" "locale_t base"
+.Sh DESCRIPTION
+Creates a new locale, inheriting some properties from an existing locale.
+The
+.Fa mask
+defines the components that the new locale will have set to the locale with the
+name specified in the
+.Fa locale
+parameter.
+Any other components will be inherited from
+.Fa base .
+The
+.Fa mask
+is either
+.Fa LC_ALL_MASK ,
+indicating all possible locale components,
+or the logical OR of some combination of the following:
+.Bl -tag -width "LC_MESSAGES_MASK" -offset indent
+.It LC_COLLATE_MASK
+The locale for string collation routines.
+This controls alphabetic ordering in
+.Xr strcoll 3
+and
+.Xr strxfrm 3 .
+.It LC_CTYPE_MASK
+The locale for the
+.Xr ctype 3
+and
+.Xr multibyte 3
+functions.
+This controls recognition of upper and lower case, alphabetic or
+non-alphabetic characters, and so on.
+.It LC_MESSAGES_MASK
+Set a locale for message catalogs, see
+.Xr catopen 3
+function.
+.It LC_MONETARY_MASK
+Set a locale for formatting monetary values; this affects
+the
+.Xr localeconv 3
+function.
+.It LC_NUMERIC_MASK
+Set a locale for formatting numbers.
+This controls the formatting of decimal points in input and output of floating
+point numbers in functions such as
+.Xr printf 3
+and
+.Xr scanf 3 ,
+as well as values returned by
+.Xr localeconv 3 .
+.It LC_TIME_MASK
+Set a locale for formatting dates and times using the
+.Xr strftime 3
+function.
+.El
+This function uses the same rules for loading locale components as
+.Xr setlocale 3 .
+.Sh RETURN VALUES
+Returns a new, valid,
+.Fa locale_t
+or NULL if an error occurs.
+You must free the returned locale with
+.Xr freelocale 3 .
+.Sh SEE ALSO
+.Xr duplocale 3 ,
+.Xr freelocale 3 ,
+.Xr localeconv 3 ,
+.Xr querylocale 3 ,
+.Xr uselocale 3 ,
+.Xr xlocale 3
+.Sh STANDARDS
+This function, conforms to
+.St -p1003.1-2008
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/nextwctype.3 src/lib/libc/locale/nextwctype.3
--- src53collation/lib/libc/locale/nextwctype.3	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/nextwctype.3	Tue Apr  2 06:11:30 2013
@@ -0,0 +1,67 @@
+.\"
+.\" Copyright (c) 2004 Tim J. Robbins
+.\" All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" From FreeBSD
+.\"
+.Dd July 21, 2005
+.Dt NEXTWCTYPE 3
+.Os
+.Sh NAME
+.Nm nextwctype
+.Nd "iterate through character classes"
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.In wctype.h
+.Ft wint_t
+.Fn nextwctype "wint_t ch" "wctype_t wct"
+.Sh DESCRIPTION
+The
+.Fn nextwctype
+function determines the next character after
+.Fa ch
+that is a member of character class
+.Fa wct .
+If
+.Fa ch
+is \-1, the search begins at the first member of
+.Fa wct .
+.Sh RETURN VALUES
+The
+.Fn nextwctype
+function returns the next character, or \-1 if there are no more.
+.Sh COMPATIBILITY
+This function is a non-standard
+.Fx
+extension and should not be used where the standard
+.Fn iswctype
+function would suffice.
+.Sh SEE ALSO
+.Xr wctype 3
+.Sh HISTORY
+The
+.Fn nextwctype
+function appeared in
+.Fx 5.4 .
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/none.c src/lib/libc/locale/none.c
--- src53collation/lib/libc/locale/none.c	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/none.c	Tue Apr  2 14:07:41 2013
@@ -0,0 +1,122 @@
+/*-
+ * Copyright (c) 2002-2004 Tim J. Robbins. All rights reserved.
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Paul Borman at Krystal Technologies.
+ *
+ * Copyright (c) 2011 The FreeBSD Foundation
+ * All rights reserved.
+ * Portions of this software were developed by David Chisnall
+ * under sponsorship from the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * http://svnweb.freebsd.org/base/head/lib/libc/locale/none.c?revision=227753&view=markup
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)none.c	8.1 (Berkeley) 6/4/93";
+#endif /* LIBC_SCCS and not lint */
+
+#include <sys/cdefs.h>
+
+#include <errno.h>
+#include <limits.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <wchar.h>
+
+#include "mblocal.h"
+#include "rune.h"
+#include "runetype.h"
+
+size_t	_citrus_none_ctype_mbrtowc(wchar_t * __restrict, 
+    const char * __restrict, size_t, mbstate_t * __restrict);
+int	_citrus_none_ctype_mbsinit(const mbstate_t *);
+size_t	_citrus_none_ctype_mbsnrtowcs(wchar_t * __restrict dst,
+    const char ** __restrict src, size_t nms, size_t len,
+    mbstate_t * __restrict ps __unused);
+size_t	_citrus_none_ctype_wcrtomb(char * __restrict, wchar_t,
+    mbstate_t * __restrict);
+size_t	_citrus_none_ctype_wcsnrtombs(char * __restrict, 
+    const wchar_t ** __restrict, size_t, size_t, mbstate_t * __restrict);
+
+/* setup defaults */
+
+//int __mb_cur_max = 1;
+int __mb_sb_limit = 256; /* Expected to be <= _CACHED_RUNES */
+
+int
+_none_init(struct xlocale_ctype *l, _RuneLocale *rl)
+{
+
+	l->__mbrtowc = _citrus_none_ctype_mbrtowc;
+	l->__mbsinit = _citrus_none_ctype_mbsinit;
+	l->__mbsnrtowcs = _citrus_none_ctype_mbsnrtowcs;
+	l->__wcrtomb = _citrus_none_ctype_wcrtomb;
+	l->__wcsnrtombs = _citrus_none_ctype_wcsnrtombs;
+	l->runes = rl;
+	l->__mb_cur_max = 1;
+	l->__mb_sb_limit = 256;
+	return(0);
+}
+
+size_t (*__mbrtowc)(wchar_t * __restrict, const char * __restrict, size_t,
+    mbstate_t * __restrict) = _citrus_none_ctype_mbrtowc;
+int (*__mbsinit)(const mbstate_t *) = _citrus_none_ctype_mbsinit;
+size_t (*__mbsnrtowcs)(wchar_t * __restrict, const char ** __restrict,
+    size_t, size_t, mbstate_t * __restrict) = _citrus_none_ctype_mbsnrtowcs;
+size_t (*__wcrtomb)(char * __restrict, wchar_t, mbstate_t * __restrict) =
+    _citrus_none_ctype_wcrtomb;
+size_t (*__wcsnrtombs)(char * __restrict, const wchar_t ** __restrict,
+    size_t, size_t, mbstate_t * __restrict) = _citrus_none_ctype_wcsnrtombs;
+
+struct xlocale_ctype __xlocale_global_ctype = {
+	{{0}, "C"},
+	(_RuneLocale*)&_DefaultRuneLocale,
+	_citrus_none_ctype_mbrtowc,
+	_citrus_none_ctype_mbsinit,
+	_citrus_none_ctype_mbsnrtowcs,
+	_citrus_none_ctype_wcrtomb,
+	_citrus_none_ctype_wcsnrtombs,
+	1, /* __mb_cur_max, */
+	256 /* __mb_sb_limit */
+};
+
+const struct xlocale_ctype __xlocale_C_ctype = {
+	{{0}, "C"},
+	(_RuneLocale*)&_DefaultRuneLocale,
+	_citrus_none_ctype_mbrtowc,
+	_citrus_none_ctype_mbsinit,
+	_citrus_none_ctype_mbsnrtowcs,
+	_citrus_none_ctype_wcrtomb,
+	_citrus_none_ctype_wcsnrtombs,
+	1, /* __mb_cur_max, */
+	256 /* __mb_sb_limit */
+};
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/querylocale.3 src/lib/libc/locale/querylocale.3
--- src53collation/lib/libc/locale/querylocale.3	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/querylocale.3	Tue Apr  2 06:11:30 2013
@@ -0,0 +1,57 @@
+.\" Copyright (c) 2011 The FreeBSD Foundation
+.\" All rights reserved.
+.\"
+.\" This documentation was written by David Chisnall under sponsorship from
+.\" the FreeBSD Foundation.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" From FreeBSD: src/lib/libc/locale/querylocale.3,v 1.4 2012/11/17 01:49:30 svnexp Exp 
+.\"
+.Dd September 17 2011
+.Dt QUERYLOCALE 3
+.Os
+.Sh NAME
+.Nm querylocale
+.Nd Look up the locale name for a specified category
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.In xlocale.h
+.Ft const char *
+.Fn querylocale "int mask" "locale_t locale"
+.Sh DESCRIPTION
+Returns the name of the locale for the category specified by
+.Fa mask .
+This possible values for the mask are the same as those in
+.Xr newlocale 3 .
+If more than one bit in the mask is set, the returned value is undefined.
+.Sh SEE ALSO
+.Xr duplocale 3 ,
+.Xr freelocale 3 ,
+.Xr localeconv 3 ,
+.Xr newlocale 3 ,
+.Xr uselocale 3 ,
+.Xr xlocale 3
+.Sh STANDARDS
+This function, conforms to
+.St -p1003.1-2008
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/rune.h src/lib/libc/locale/rune.h
--- src53collation/lib/libc/locale/rune.h	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/rune.h	Tue Apr  2 06:24:51 2013
@@ -74,7 +74,7 @@
  * global variables
  */
 extern size_t __mb_len_max_runtime;
-extern _RuneLocale _DefaultRuneLocale;
-extern _RuneLocale *_CurrentRuneLocale;
+extern const _RuneLocale _DefaultRuneLocale;
+extern const _RuneLocale *_CurrentRuneLocale;
 
 #endif	/*! _RUNE_H_ */
diff -u src55-orig/lib/libc/locale/runetable.c src/lib/libc/locale/runetable.c
--- src55-orig/lib/libc/locale/runetable.c	Sat Feb  9 14:26:52 2013
+++ src/lib/libc/locale/runetable.c	Wed Oct 23 06:27:50 2013
@@ -45,7 +45,7 @@
 #include "citrus_none.h"
 #include <stdlib.h>
 
-_RuneLocale _DefaultRuneLocale = {
+const _RuneLocale _DefaultRuneLocale = {
     _RUNE_MAGIC_1,
     "NONE",
     _DEFAULT_INVALID_RUNE,
@@ -400,4 +400,4 @@
     NULL
 };
 
-_RuneLocale *_CurrentRuneLocale = &_DefaultRuneLocale;
+const _RuneLocale *_CurrentRuneLocale = &_DefaultRuneLocale;
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/runetype.h src/lib/libc/locale/runetype.h
--- src53collation/lib/libc/locale/runetype.h	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/runetype.h	Tue Apr  2 06:24:51 2013
@@ -40,7 +40,10 @@
 #include <sys/types.h>
 #include "ctype_private.h"
 
+#ifndef _RUNE_T_DEFINED
+#define _RUNE_T_DEFINED
 typedef uint32_t	rune_t;
+#endif
 typedef uint64_t	__runepad_t;
 
 
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/setlocale.c src/lib/libc/locale/setlocale.c
--- src53collation/lib/libc/locale/setlocale.c	Mon Apr  1 08:25:36 2013
+++ src/lib/libc/locale/setlocale.c	Wed Apr  3 06:41:58 2013
@@ -43,6 +43,7 @@
 #include "collate.h"
 #include "rune.h"
 #include "rune_local.h"
+#include "xlocale_private.h"
 /*
  * Category names for getenv()
  */
@@ -80,7 +81,7 @@
 static void revert_to_default(int);
 static int load_locale_sub(int, const char *, int);
 static char	*loadlocale(int);
-static const char *__get_locale_env(int);
+const char *__get_locale_env(int);
 
 char *
 setlocale(int category, const char *locale)
@@ -199,6 +200,9 @@
 	case LC_CTYPE:
 		(void)_xpg4_setrunelocale("C");
 		__install_currentrunelocale_ctype();
+		(void)strlcpy(__xlocale_global_locale.components[category-1]->locale, 
+		    "C", 
+		    sizeof(__xlocale_global_locale.components[category-1]->locale) );
 		break;
 	case LC_MESSAGES:
 		break;
@@ -206,6 +210,10 @@
  		if (__collate_load_tables("C")) {
 			return;
 		}
+		(void)strlcpy(__xlocale_global_locale.components[category-1]->locale, 
+		    "C", 
+		    sizeof(__xlocale_global_locale.components[category-1]->locale) );
+
 		break;
 	case LC_MONETARY:
 	case LC_NUMERIC:
@@ -262,6 +270,9 @@
 		if (_xpg4_setrunelocale(locname))
 			return -1;
 		__install_currentrunelocale_ctype();
+		(void)strlcpy(__xlocale_global_locale.components[category-1]->locale, 
+			locname, 
+			sizeof(__xlocale_global_locale.components[category-1]->locale) );
 		break;
 
 	case LC_MESSAGES:
@@ -271,6 +282,10 @@
 		if (__collate_load_tables(locname)) {
 			return -1;
 		}       
+		(void)strlcpy(__xlocale_global_locale.components[category-1]->locale, 
+			locname, 
+			sizeof(__xlocale_global_locale.components[category-1]->locale) );
+
 		break;
 
 	case LC_MONETARY:
@@ -289,7 +304,7 @@
 	    current_categories[category]) == 0)
 		return (current_categories[category]);
 
-	if (!load_locale_sub(category, new_categories[category], 0)) {
+	if (load_locale_sub(category, new_categories[category], 0) == 0) {
 		(void)strlcpy(current_categories[category],
 		    new_categories[category], sizeof(current_categories[category]));
 		return current_categories[category];
@@ -298,7 +313,7 @@
 	}
 }
 
-static const char *
+const char *
 __get_locale_env(int category)
 {
 	const char *env;
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/setrunelocale.c src/lib/libc/locale/setrunelocale.c
--- src53collation/lib/libc/locale/setrunelocale.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/setrunelocale.c	Wed Apr  3 06:46:51 2013
@@ -98,10 +98,13 @@
 #include <stddef.h>
 #include <string.h>
 #include <unistd.h>
+#include <xlocale.h>
 
 #include "citrus_ctype.h"
+#include "mblocal.h"
 #include "rune.h"
 #include "rune_local.h"
+#include "xlocale_private.h"
 
 struct localetable {
 	char path[PATH_MAX];
@@ -173,11 +176,27 @@
 int
 _xpg4_setrunelocale(const char *locname)
 {
+
+	int rv = xlocale_setrunelocale(&__xlocale_global_ctype, locname);
+	if (rv == 0) {
+		_CurrentRuneLocale = __xlocale_global_ctype.runes;
+	}
+	return rv;
+}
+
+int
+xlocale_setrunelocale(struct xlocale_ctype *xc, const char *locname)
+{
 	char path[PATH_MAX];
 	_RuneLocale *rl;
 	int error, len;
 	const char *dot, *encoding;
 
+	if (xc == NULL || locname == NULL) {
+		rl = &_DefaultRuneLocale;
+		goto found;
+	}
+
 	if (!strcmp(locname, "C") || !strcmp(locname, "POSIX")) {
 		rl = &_DefaultRuneLocale;
 		goto found;
@@ -206,7 +225,43 @@
 
 found:
 	_CurrentRuneLocale = rl;
+	xc->runes = rl;
+	xc->__mbrtowc = (void *)(rl->rl_citrus_ctype->cc_ops->co_mbrtowc);
+	xc->__mbsinit = (void *)(rl->rl_citrus_ctype->cc_ops->co_mbsinit);
+	xc->__mbsnrtowcs = (void *)rl->rl_citrus_ctype->cc_ops->co_mbsnrtowcs;
+	xc->__wcrtomb = (void *)rl->rl_citrus_ctype->cc_ops->co_wcrtomb;
+	xc->__wcsnrtombs = (void *)rl->rl_citrus_ctype->cc_ops->co_wcsnrtombs;
+	xc->__mb_cur_max = rl->rl_citrus_ctype->cc_mb_cur_max;
 	__mb_cur_max = rl->rl_citrus_ctype->cc_mb_cur_max;
 
 	return 0;
 }
+
+
+void
+destruct_ctype(void *t)
+{
+	/* We don't free runes, because they are in the cache starting at
+	 * localerunes_head */
+	if (t != NULL) {
+		free(t);
+	}
+}
+
+
+/** Based on __collate_load */
+void *
+__ctype_load(const char *locname, locale_t unused)
+{
+	struct xlocale_ctype *l = calloc(sizeof(struct xlocale_ctype), 1);
+
+	l->header.header.destructor = destruct_ctype;
+	if (xlocale_setrunelocale(l, locname))
+	{
+		xlocale_release(l);
+		return NULL;
+	}
+	return l;
+}
+
+
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/uselocale.3 src/lib/libc/locale/uselocale.3
--- src53collation/lib/libc/locale/uselocale.3	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/uselocale.3	Tue Apr  2 06:11:30 2013
@@ -0,0 +1,60 @@
+.\" Copyright (c) 2011 The FreeBSD Foundation
+.\" All rights reserved.
+.\"
+.\" This documentation was written by David Chisnall under sponsorship from
+.\" the FreeBSD Foundation.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD: src/lib/libc/locale/uselocale.3,v 1.4 2012/11/17 01:49:30 svnexp Exp $
+.\"
+.Dd September 17 2011
+.Dt USELOCALE 3
+.Os
+.Sh NAME
+.Nm uselocale
+.Nd Sets a thread-local locale
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.In xlocale.h
+.Ft locale_t
+.Fn uselocale "locale_t locale"
+.Sh DESCRIPTION
+Specifies the locale for this thread to use.
+Specifying
+.Fa LC_GLOBAL_LOCALE
+disables the per-thread locale,
+while NULL returns the current locale without setting a new one.
+.Sh RETURN VALUES
+Returns the previous locale,
+or LC_GLOBAL_LOCALE if this thread has no locale associated with it.
+.Sh SEE ALSO
+.Xr duplocale 3 ,
+.Xr freelocale 3 ,
+.Xr localeconv 3 ,
+.Xr newlocale 3 ,
+.Xr querylocale 3 ,
+.Xr xlocale 3
+.Sh STANDARDS
+This function conforms to
+.St -p1003.1-2008
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/wcscoll.c src/lib/libc/locale/wcscoll.c
--- src53collation/lib/libc/locale/wcscoll.c	Mon Apr  1 08:25:36 2013
+++ src/lib/libc/locale/wcscoll.c	Tue Apr  2 09:01:58 2013
@@ -72,8 +72,8 @@
 	wint_t prim1, prim2, sec1, sec2;
 	const wchar_t *t1, *t2;
 	wchar_t *tt1, *tt2;
-	struct __collate *table;
-	table = (struct __collate *)&__global_collate;
+	struct xlocale_collate *table;
+	table = (struct xlocale_collate *)&__xlocale_global_collate;
 
 	if (table->__collate_load_error)
 		return wcscmp(s1, s2);
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/wcsrtombs.3 src/lib/libc/locale/wcsrtombs.3
--- src53collation/lib/libc/locale/wcsrtombs.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/wcsrtombs.3	Wed Apr  3 11:15:27 2013
@@ -31,7 +31,9 @@
 .\" ----------------------------------------------------------------------
 .Sh NAME
 .Nm wcsrtombs ,
-.Nm wcsnrtombs
+.Nm wcsrtombs_l ,
+.Nm wcsnrtombs ,
+.Nm wcsnrtombs_l
 .Nd converts a wide-character string to a multibyte character string \
 (restartable)
 .\" ----------------------------------------------------------------------
@@ -39,15 +41,21 @@
 .Fd #include <wchar.h>
 .Ft size_t
 .Fn wcsrtombs "const char * restrict dst" "const wchar_t ** restrict src" \
-"size_t len" "mbstate_t * restrict ps"
 .Ft size_t
+.Fn wcsrtombs_l "const char * restrict dst" "const wchar_t ** restrict src" \
+"size_t len" "mbstate_t * restrict ps" "locale_t l"
+.Ft size_t
 .Fn wcsnrtombs "const char * restrict dst" "const wchar_t ** restrict src" \
-"size_t nwc" "size_t len" "mbstate_t * restrict ps"
+.Ft size_t
+.Fn wcsnrtombs "const char * restrict dst" "const wchar_t ** restrict src" \
+"size_t nwc" "size_t len" "mbstate_t * restrict ps" "locale_t l"
 .\" ----------------------------------------------------------------------
 .Sh DESCRIPTION
 The
 .Fn wcsrtombs
-function converts the wide-character string indirectly pointed to by
+and
+.Fn wcsrtombs_l
+functions convert the wide-character string indirectly pointed to by
 .Fa src
 to the corresponding multibyte character string
 and stores it to the array pointed to by
@@ -68,9 +76,11 @@
 .Pp
 The
 .Fn wcsnrtombs
-function is equivalent to
+and
+.Fn wcsnrtombs_l
+functions are equivalent to
 .Fn wcsrtombs
-except that it additionally stops the conversion after processing
+except that they additionally stops the conversion after processing
 .Fa nwc
 wide characters.
 .Pp
@@ -103,7 +113,16 @@
 .Fn wcsnrtombs
 functions is affected by the
 .Dv LC_CTYPE
-category of the current locale.
+category of the current locale, while
+the behaviour of the
+.Fn wcsrtombs_l
+and
+.Fn wcsnrtombs_l
+functions is affected by the
+.Dv LC_CTYPE
+category of the locale provided as parameter, see
+.Xr xlocale 3
+
 .Pp
 There are two special cases:
 .Bl -tag -width 012345678901
@@ -115,10 +134,7 @@
 .Fa len
 is ignored.
 .It "ps == NULL"
-The
-.Fn wcsrtombs
-and
-.Fn wcsnrtombs
+These
 functions use their own internal state objects to keep the conversion state,
 instead of
 .Fa ps
@@ -131,10 +147,7 @@
 .El
 .\" ----------------------------------------------------------------------
 .Sh RETURN VALUES
-The
-.Fn wcsrtombs
-and
-.Fn wcsnrtombs
+These
 functions return:
 .Bl -tag -width 012345678901
 .It 0 or positive
@@ -160,10 +173,7 @@
 .El
 .\" ----------------------------------------------------------------------
 .Sh ERRORS
-The
-.Fn wcsrtombs
-and
-.Fn wcsnrtombs
+These
 functions may return the following errors:
 .Bl -tag -width Er
 .It Bq Er EILSEQ
@@ -178,11 +188,14 @@
 .Xr setlocale 3 ,
 .Xr wcrtomb 3 ,
 .Xr wcstombs 3
+.Xr setlocale 3
+.Xr xlocale 3
 .\" ----------------------------------------------------------------------
 .Sh STANDARDS
 The
 .Fn wcsrtombs
 function conforms to
+POSIX 2008,
 .St -ansiC .
 The restrict qualifier is added at
 .\" .St -isoC99 .
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/wcstombs.3 src/lib/libc/locale/wcstombs.3
--- src53collation/lib/libc/locale/wcstombs.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/wcstombs.3	Wed Apr  3 11:15:27 2013
@@ -30,22 +30,29 @@
 .Os
 .\" ----------------------------------------------------------------------
 .Sh NAME
-.Nm wcstombs
-.Nd converts a wide-character string to a multibyte character string
+.Nm wcstombs ,
+.Nm wcstombs_l
+.Nd convert a wide-character string to a multibyte character string
 .\" ----------------------------------------------------------------------
 .Sh SYNOPSIS
 .In stdlib.h
 .Ft size_t
 .Fn wcstombs "char * restrict s" "const wchar_t * restrict pwcs" "size_t n"
+.In xlocale.h
+.Ft size_t
+.Fn wcstombs_l "char * restrict s" "const wchar_t * restrict pwcs" "size_t n" "locale_t l"
 .\" ----------------------------------------------------------------------
 .Sh DESCRIPTION
+The functions
 .Fn wcstombs
-converts the null-terminated wide-character string pointed to by
+and
+.Fn wcstombs_l
+convert the null-terminated wide-character string pointed to by
 .Fa pwcs
 to the corresponding multibyte character string,
-and stores it in the array pointed to by
+and store it in the array pointed to by
 .Fa s .
-This function may modify the first at most
+These functions may modify the first at most
 .Fa n
 bytes of the array pointed to by
 .Fa s .
@@ -57,6 +64,8 @@
 .Pp
 For state-dependent encoding, the
 .Fn wcstombs
+and
+.Fn wcstombs_l
 implies the result multibyte character string pointed to by
 .Fa s
 always to begin with an initial state.
@@ -65,7 +74,10 @@
 .Fn wcstombs
 is affected by the
 .Dv LC_CTYPE
-category of the current locale.
+category of the current locale, while the behavior of
+.Fn wcstombs_l
+depends on the locale provided as parameter, see
+.Xr xlocale 3
 .Pp
 There are special cases:
 .Bl -tag -width 012345678901
@@ -119,7 +131,8 @@
 .\" ----------------------------------------------------------------------
 .Sh SEE ALSO
 .Xr setlocale 3 ,
-.Xr wctomb 3
+.Xr wctomb 3 ,
+.Xr xlocale 3
 .\" ----------------------------------------------------------------------
 .Sh STANDARDS
 The
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/wcstombs.c src/lib/libc/locale/wcstombs.c
--- src53collation/lib/libc/locale/wcstombs.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/wcstombs.c	Wed Apr  3 11:15:27 2013
@@ -30,14 +30,23 @@
 #include <stdlib.h>
 #include <string.h>
 #include <wchar.h>
+#include <locale.h>
+#include "xlocale_private.h"
 
 size_t
-wcstombs(char * __restrict s, const wchar_t * __restrict pwcs, size_t n)
+wcstombs_l(char * __restrict s, const wchar_t * __restrict pwcs, size_t n, 
+		locale_t locale)
 {
 	mbstate_t mbs;
 	const wchar_t *pwcsp;
 
 	memset(&mbs, 0, sizeof(mbs));
 	pwcsp = pwcs;
-	return (wcsrtombs(s, &pwcsp, n, &mbs));
+	return (wcsrtombs_l(s, &pwcsp, n, &mbs, locale));
+}
+
+size_t
+wcstombs(char * __restrict s, const wchar_t * __restrict pwcs, size_t n)
+{
+	return wcstombs_l(s, pwcs, n, __get_locale());
 }
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/wcsxfrm.c src/lib/libc/locale/wcsxfrm.c
--- src53collation/lib/libc/locale/wcsxfrm.c	Mon Apr  1 08:25:36 2013
+++ src/lib/libc/locale/wcsxfrm.c	Tue Apr  2 09:02:06 2013
@@ -79,8 +79,8 @@
 	int l;
 	size_t slen;
 	wchar_t *s, *ss;
-	struct __collate *table;
-	table = (struct __collate *)&__global_collate;
+	struct xlocale_collate *table;
+	table = (struct xlocale_collate *)&__xlocale_global_collate;
 
 	if (*src == L'\0') {
 		if (len > 0 && dest != NULL)
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/wctob.3 src/lib/libc/locale/wctob.3
--- src53collation/lib/libc/locale/wctob.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/wctob.3	Wed Apr  3 11:15:27 2013
@@ -30,32 +30,44 @@
 .Os
 .\" ----------------------------------------------------------------------
 .Sh NAME
-.Nm wctob
+.Nm wctob ,
+.Nm wctob_l
 .Nd convert a wide character to a single byte character
 .\" ----------------------------------------------------------------------
 .Sh SYNOPSIS
 .In wchar.h
 .Ft int
 .Fn wctob "wint_t wc"
+.Ft int
+.Fn wctob_l "wint_t wc" "locale_t l"
 .\" ----------------------------------------------------------------------
 .Sh DESCRIPTION
 The
 .Fn wctob
-function converts a wide character
+and
+.Fn wctob_l
+functions converts a wide character
 .Fa wc
 to a corresponding single byte character in the initial shift state of
-the current locale.
+the current locale in the case of 
+.Fn wctob
+or of the locale provided as parameter to 
+.Fn wctob_l ,
+see
+.Xr xlocale 3
 .Pp
 The behaviour of the
 .Fn wctob
 is affected by the
 .Dv LC_CTYPE
-category of the current locale.
+category of the current locale. While the behavior of
+.Fn wctob_l
+depends on the 
+.Dv LC_CTYPE
+category of the provided locale.
 .\" ----------------------------------------------------------------------
 .Sh RETURN VALUES
-The
-.Fn wctob
-function returns:
+These functions return:
 .Bl -tag -width 012345678901
 .It Dv EOF
 if
@@ -77,9 +89,8 @@
 .Xr btowc 3 ,
 .Xr setlocale 3 ,
 .Xr wcrtomb 3
+.Xr xlocale 3
 .\" ----------------------------------------------------------------------
 .Sh STANDARDS
-The
-.Fn wctob
-function conforms to
-.St -isoC-amd1 .
+These
+functions conforms to POSIX 2008.
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/wctob.c src/lib/libc/locale/wctob.c
--- src53collation/lib/libc/locale/wctob.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/wctob.c	Wed Apr  3 11:15:27 2013
@@ -29,15 +29,23 @@
 #include <stdio.h>
 #include <string.h>
 #include <wchar.h>
+#include <xlocale.h>
+#include "xlocale_private.h"
 
 int
-wctob(wint_t c)
+wctob_l(wint_t c, locale_t loc)
 {
 	mbstate_t mbs;
 	char buf[MB_LEN_MAX];
 
 	memset(&mbs, 0, sizeof(mbs));
-	if (c == WEOF || wcrtomb(buf, c, &mbs) != 1)
+	if (c == WEOF || wcrtomb_l(buf, c, &mbs, loc) != 1)
 		return (EOF);
 	return ((unsigned char)*buf);
+}
+
+int
+wctob(wint_t c)
+{
+	return wctob_l(c, __get_locale());
 }
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/wctomb.3 src/lib/libc/locale/wctomb.3
--- src53collation/lib/libc/locale/wctomb.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/wctomb.3	Wed Apr  3 11:15:27 2013
@@ -29,27 +29,37 @@
 .Dt WCTOMB 3
 .Os
 .Sh NAME
-.Nm wctomb
-.Nd converts a wide character to a multibyte character
+.Nm wctomb ,
+.Nm wctomb_l
+.Nd convert a wide character to a multibyte character
 .Sh SYNOPSIS
 .In stdlib.h
 .Ft int
 .Fn wctomb "char * s" "const wchar_t wchar"
+.In xlocale.h
+.Ft int
+.Fn wctomb_l "char * s" "const wchar_t wchar" "locale_t l"
 .Sh DESCRIPTION
-The
+The functions
 .Fn wctomb
-converts the wide character
+and
+.Fn wctomb_l
+convert the wide character
 .Fa wchar
-to the corresponding multibyte character, and stores it in the array
+to the corresponding multibyte character, and store it in the array
 pointed to by
 .Fa s .
 .Fn wctomb
+and
+.Fn wctomb_l
 may store at most
 .Dv MB_CUR_MAX
 bytes in the array.
 .Pp
 In state-dependent encoding,
 .Fn wctomb
+and
+.Fn wctomb_l
 may store the special sequence to change the conversion state
 before an actual multibyte character into the array pointed to by
 .Fa s .
@@ -57,13 +67,15 @@
 .Fa wchar
 is a null wide character
 .Pq Sq \e0 ,
-this function places its own internal state to an initial conversion state.
+theses functions place its own internal state to an initial conversion state.
 .Pp
 Calling any other functions in
 .Em libc
 never change the internal
 state of
-.Fn wctomb ,
+.Fn wctomb 
+and
+.Fn wctomb_l ,
 except for calling
 .Xr setlocale 3
 with the
@@ -77,7 +89,10 @@
 .Fn wctomb
 is affected by
 .Dv LC_CTYPE
-category of the current locale.
+category of the current locale, while the behavior of
+.Fn wctomb_l
+depends on the locale provided as parameter, see
+.Xr xlocale 3
 .Pp
 There is a special case:
 .Bl -tag -width 012345678901
@@ -123,7 +138,8 @@
 .Sh ERRORS
 No errors are defined.
 .Sh SEE ALSO
-.Xr setlocale 3
+.Xr setlocale 3 ,
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn wctomb
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/wctomb.c src/lib/libc/locale/wctomb.c
--- src53collation/lib/libc/locale/wctomb.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/wctomb.c	Wed Apr  3 11:15:27 2013
@@ -29,9 +29,11 @@
 #include <stdlib.h>
 #include <string.h>
 #include <wchar.h>
+#include <locale.h>
+#include "../locale/xlocale_private.h"
 
 int
-wctomb(char *s, wchar_t wchar)
+wctomb_l(char *s, wchar_t wchar, locale_t loc)
 {
 	static mbstate_t mbs;
 	size_t rval;
@@ -41,7 +43,13 @@
 		memset(&mbs, 0, sizeof(mbs));
 		return (0);
 	}
-	if ((rval = wcrtomb(s, wchar, &mbs)) == (size_t)-1)
+	if ((rval = wcrtomb_l(s, wchar, &mbs, loc)) == (size_t)-1)
 		return (-1);
 	return ((int)rval);
+}
+
+int
+wctomb(char *s, wchar_t wchar)
+{
+	return wctomb_l(s, wchar, __get_locale());
 }
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/xlocale.3 src/lib/libc/locale/xlocale.3
--- src53collation/lib/libc/locale/xlocale.3	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/xlocale.3	Tue Apr  2 06:11:30 2013
@@ -0,0 +1,369 @@
+.\" Copyright (c) 2011 The FreeBSD Foundation
+.\" All rights reserved.
+.\"
+.\" This documentation was written by David Chisnall under sponsorship from
+.\" the FreeBSD Foundation.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD: src/lib/libc/locale/xlocale.3,v 1.6 2012/11/17 01:49:31 svnexp Exp $
+.\"
+.Dd January 25 2013
+.Dt XLOCALE 3
+.Os
+.Sh NAME
+.Nm xlocale
+.Nd Extended locale support for collations and ctype
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.In xlocale.h
+.Sh DESCRIPTION
+The extended locale support for collations and ctype includes 
+convenience functions for performing locale-aware calls with a 
+specified locale.
+.Pp
+The core of the xlocale API is the
+.Fa locale_t
+type.
+This is an opaque type encapsulating a locale.
+Instances of this can be either set as the locale or passed directly to the
+.Fa _l
+suffixed variants of various standard C functions.
+Two special
+.Fa locale_t
+values are available:
+.Bl -bullet -offset indent
+.It
+NULL refers to the current locale 
+.It
+LC_GLOBAL_LOCALE refers to the global locale.
+.El
+.Pp
+The global locale is the locale set with the
+.Xr setlocale 3
+function.
+.Sh SEE ALSO
+.Xr duplocale 3 ,
+.Xr freelocale 3 ,
+.Xr localeconv 3 ,
+.Xr newlocale 3 ,
+.Xr querylocale 3 ,
+.Xr uselocale 3 ,
+.Sh CONVENIENCE FUNCTIONS
+The xlocale API includes a number of
+.Fa _l
+suffixed convenience functions.
+These are variants of standard C functions
+that have been modified to take an explicit
+.Fa locale_t
+parameter as the final argument or, in the case of variadic functions,
+as an additional argument directly before the format string.
+Each of these functions accepts either NULL or LC_GLOBAL_LOCALE.
+In these functions, NULL refers to the C locale,
+rather than the thread's current locale.
+If you wish to use the current locale,
+then use the unsuffixed version of the function.
+.Pp
+These functions are exposed by including
+.In xlocale.h
+.Em after
+including the relevant headers for the standard variant.
+For example, the
+.Xr iswalnum_l 3
+function is exposed by including
+.In xlocale.h
+after
+.In wctype.h ,
+which defines
+.Xr iswalnum 3 .
+.Pp
+For reference,
+a complete list of the locale-aware functions that are available in this form,
+along with the headers that expose them, is provided here:
+.Bl -tag -width "<monetary.h> "
+.It In wctype.h
+.Xr iswalnum_l 3 ,
+.Xr iswalpha_l 3 ,
+.Xr iswcntrl_l 3 ,
+.Xr iswctype_l 3 ,
+.Xr iswdigit_l 3 ,
+.Xr iswgraph_l 3 ,
+.Xr iswlower_l 3 ,
+.Xr iswprint_l 3 ,
+.Xr iswpunct_l 3 ,
+.Xr iswspace_l 3 ,
+.Xr iswupper_l 3 ,
+.Xr iswxdigit_l 3 ,
+.Xr towlower_l 3 ,
+.Xr towupper_l 3 ,
+.Xr wctype_l 3 ,
+.It In ctype.h
+.Xr digittoint_l 3 ,
+.Xr isalnum_l 3 ,
+.Xr isalpha_l 3 ,
+.Xr isblank_l 3 ,
+.Xr iscntrl_l 3 ,
+.Xr isdigit_l 3 ,
+.Xr isgraph_l 3 ,
+.Xr ishexnumber_l 3 ,
+.Xr isideogram_l 3 ,
+.Xr islower_l 3 ,
+.Xr isnumber_l 3 ,
+.Xr isphonogram_l 3 ,
+.Xr isprint_l 3 ,
+.Xr ispunct_l 3 ,
+.Xr isrune_l 3 ,
+.Xr isspace_l 3 ,
+.Xr isspecial_l 3 ,
+.Xr isupper_l 3 ,
+.Xr isxdigit_l 3 ,
+.Xr tolower_l 3 ,
+.Xr toupper_l 3
+.\".It In inttypes.h
+.\".Xr strtoimax_l 3 ,
+.\".Xr strtoumax_l 3 ,
+.\".Xr wcstoimax_l 3 ,
+.\".Xr wcstoumax_l 3
+.\".It In langinfo.h
+.\".Xr nl_langinfo_l 3
+.\".It In monetary.h
+.\".Xr strfmon_l 3
+.\".It In stdio.h
+.\".Xr asprintf_l 3 ,
+.\".Xr fprintf_l 3 ,
+.\".Xr fscanf_l 3 ,
+.\".Xr printf_l 3 ,
+.\".Xr scanf_l 3 ,
+.\".Xr snprintf_l 3 ,
+.\".Xr sprintf_l 3 ,
+.\".Xr sscanf_l 3 ,
+.\".Xr vasprintf_l 3 ,
+.\".Xr vfprintf_l 3 ,
+.\".Xr vfscanf_l 3 ,
+.\".Xr vprintf_l 3 ,
+.\".Xr vscanf_l 3 ,
+.\".Xr vsnprintf_l 3 ,
+.\".Xr vsprintf_l 3 ,
+.\".Xr vsscanf_l 3
+.It In stdlib.h
+.\".Xr atof_l 3 ,
+.\".Xr atoi_l 3 ,
+.\".Xr atol_l 3 ,
+.\".Xr atoll_l 3 ,
+.Xr mblen_l 3 ,
+.Xr mbstowcs_l 3 ,
+.Xr mbtowc_l 3 ,
+.\".Xr strtod_l 3 ,
+.\".Xr strtof_l 3 ,
+.\".Xr strtol_l 3 ,
+.\".Xr strtold_l 3 ,
+.\".Xr strtoll_l 3 ,
+.\".Xr strtoq_l 3 ,
+.\".Xr strtoul_l 3 ,
+.\".Xr strtoull_l 3 ,
+.\".Xr strtouq_l 3 ,
+.Xr wcstombs_l 3 ,
+.Xr wctomb_l 3
+.It In string.h
+.Xr strcoll_l 3 ,
+.Xr strxfrm_l 3 ,
+.Xr strcasecmp_l 3 ,
+.Xr strcasestr_l 3 ,
+.Xr strncasecmp_l 3
+.\".It In time.h
+.\".Xr strftime_l 3
+.\".Xr strptime_l 3
+.It In wchar.h
+.Xr btowc_l 3 ,
+.\".Xr fgetwc_l 3 ,
+.\".Xr fgetws_l 3 ,
+.\".Xr fputwc_l 3 ,
+.\".Xr fputws_l 3 ,
+.\".Xr fwprintf_l 3 ,
+.\".Xr fwscanf_l 3 ,
+.\".Xr getwc_l 3 ,
+.\".Xr getwchar_l 3 ,
+.Xr mbrlen_l 3 ,
+.Xr mbrtowc_l 3 ,
+.Xr mbsinit_l 3 ,
+.Xr mbsnrtowcs_l 3 ,
+.Xr mbsrtowcs_l 3 ,
+.\".Xr putwc_l 3 ,
+.\".Xr putwchar_l 3 ,
+.\".Xr swprintf_l 3 ,
+.\".Xr swscanf_l 3 ,
+.\".Xr ungetwc_l 3 ,
+.\".Xr vfwprintf_l 3 ,
+.\".Xr vfwscanf_l 3 ,
+.\".Xr vswprintf_l 3 ,
+.\".Xr vswscanf_l 3 ,
+.\".Xr vwprintf_l 3 ,
+.\".Xr vwscanf_l 3 ,
+.Xr wcrtomb_l 3 ,
+.Xr wcscasecmp_l 3
+.Xr wcscoll_l 3 ,
+.\".Xr wcsftime_l 3 ,
+.Xr wcsncasecmp_l 3
+.Xr wcsnrtombs_l 3 ,
+.Xr wcsrtombs_l 3 ,
+.\".Xr wcstod_l 3 ,
+.\".Xr wcstof_l 3 ,
+.\".Xr wcstol_l 3 ,
+.\".Xr wcstold_l 3 ,
+.\".Xr wcstoll_l 3 ,
+.\".Xr wcstoul_l 3 ,
+.\".Xr wcstoull_l 3 ,
+.Xr wcswidth_l 3 ,
+.Xr wcsxfrm_l 3 ,
+.Xr wctob_l 3 ,
+.Xr wcwidth_l 3 ,
+.\".Xr wprintf_l 3 ,
+.\".Xr wscanf_l 3
+.It In wctype.h
+.Xr iswblank_l 3 ,
+.Xr iswhexnumber_l 3 ,
+.Xr iswideogram_l 3 ,
+.Xr iswnumber_l 3 ,
+.Xr iswphonogram_l 3 ,
+.Xr iswrune_l 3 ,
+.Xr iswspecial_l 3 ,
+.Xr nextwctype_l 3 ,
+.Xr towctrans_l 3 ,
+.Xr wctrans_l 3
+.El
+.Sh STANDARDS
+The functions
+follow 
+.St -p1003.1-2008 
+except in thread safety.
+.Sh HISTORY
+The xlocale APIs first appeared in Darwin 8.0.
+David Chisnall implemented it for FreeBSD 9.1
+under sponsorship from the FreeBSD Foundation.
+For adJ 5.2, vtamara@pasosdeJesus.org mixed the collation support of 
+such implementation with the existing locale support of OpenBSD 5.2.
+.Sh CAVEATS
+Due to the lack of _Thread_local storage, this implementation still
+is not thread safe, all the threads share the same global locale.
+Better use the 
+.Fa _l
+suffixed versions of the functions.
+.Pp
+We have implemented only functions related with 
+.In ctype.h
+,
+.In wctype.h
+and collations. 
+The convenience functions that still has not been implemented are:
+.Bl -tag -width "<monetary.h> "
+.It In inttypes.h
+.Xr strtoimax_l 3 ,
+.Xr strtoumax_l 3 ,
+.Xr wcstoimax_l 3 ,
+.Xr wcstoumax_l 3
+.It In langinfo.h
+.Xr nl_langinfo_l 3
+.It In monetary.h
+.Xr strfmon_l 3
+.It In stdio.h
+.Xr asprintf_l 3 ,
+.Xr fprintf_l 3 ,
+.Xr fscanf_l 3 ,
+.Xr printf_l 3 ,
+.Xr scanf_l 3 ,
+.Xr snprintf_l 3 ,
+.Xr sprintf_l 3 ,
+.Xr sscanf_l 3 ,
+.Xr vasprintf_l 3 ,
+.Xr vfprintf_l 3 ,
+.Xr vfscanf_l 3 ,
+.Xr vprintf_l 3 ,
+.Xr vscanf_l 3 ,
+.Xr vsnprintf_l 3 ,
+.Xr vsprintf_l 3 ,
+.Xr vsscanf_l 3
+.It In stdlib.h
+.Xr atof_l 3 ,
+.Xr atoi_l 3 ,
+.Xr atol_l 3 ,
+.Xr atoll_l 3 ,
+.Xr strtod_l 3 ,
+.Xr strtof_l 3 ,
+.Xr strtol_l 3 ,
+.Xr strtold_l 3 ,
+.Xr strtoll_l 3 ,
+.Xr strtoq_l 3 ,
+.Xr strtoul_l 3 ,
+.Xr strtoull_l 3 ,
+.Xr strtouq_l 3 ,
+.It In string.h
+.It In time.h
+.Xr strftime_l 3
+.Xr strptime_l 3
+.It In wchar.h
+.Xr fgetwc_l 3 ,
+.Xr fgetws_l 3 ,
+.Xr fputwc_l 3 ,
+.Xr fputws_l 3 ,
+.Xr fwprintf_l 3 ,
+.Xr fwscanf_l 3 ,
+.Xr getwc_l 3 ,
+.Xr getwchar_l 3 ,
+.Xr putwc_l 3 ,
+.Xr putwchar_l 3 ,
+.Xr swprintf_l 3 ,
+.Xr swscanf_l 3 ,
+.Xr ungetwc_l 3 ,
+.Xr vfwprintf_l 3 ,
+.Xr vfwscanf_l 3 ,
+.Xr vswprintf_l 3 ,
+.Xr vswscanf_l 3 ,
+.Xr vwprintf_l 3 ,
+.Xr vwscanf_l 3 ,
+.Xr wcsftime_l 3 ,
+.Xr wcstod_l 3 ,
+.Xr wcstof_l 3 ,
+.Xr wcstol_l 3 ,
+.Xr wcstold_l 3 ,
+.Xr wcstoll_l 3 ,
+.Xr wcstoul_l 3 ,
+.Xr wcstoull_l 3 ,
+.Xr wprintf_l 3 ,
+.It In xlocale.h
+.Xr localeconv_l 3
+.El
+.
+.\"The
+.\".Xr setlocale 3
+.\"function, and others in the family, refer to the global locale.
+.\"Other functions that depend on the locale, however,
+.\"will take the thread-local locale if one has been set.
+.\"This means that the idiom of setting the locale using
+.\".Xr setlocale 3 ,
+.\"calling a locale-dependent function,
+.\"and then restoring the locale will not
+.\"have the expected behavior if the current thread has had a locale set using
+.\".Xr uselocale 3 .
+.\"You should avoid this idiom and prefer to use the
+.\".Fa _l
+.\"suffixed versions instead.
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/xlocale.c src/lib/libc/locale/xlocale.c
--- src53collation/lib/libc/locale/xlocale.c	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/xlocale.c	Wed Apr  3 11:04:42 2013
@@ -0,0 +1,437 @@
+/*-
+ * Copyright (c) 2011 The FreeBSD Foundation
+ * All rights reserved.
+ *
+ * This software was developed by David Chisnall under sponsorship from
+ * the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/libc/locale/xlocale.c,v 1.6 2012/11/17 01:49:31 svnexp Exp $
+ */
+
+#include <pthread.h>
+#include <stdio.h>
+#include <string.h>
+#include "runetype.h"
+#include "xlocale_private.h"
+
+/**
+ * Each locale loader declares a global component.  This is used by setlocale()
+ * and also by xlocale with LC_GLOBAL_LOCALE..
+ */
+extern struct xlocale_component __xlocale_global_collate;
+extern struct xlocale_component __xlocale_global_ctype;
+extern struct xlocale_component __xlocale_global_monetary;
+extern struct xlocale_component __xlocale_global_numeric;
+extern struct xlocale_component __xlocale_global_time;
+extern struct xlocale_component __xlocale_global_messages;
+/*
+ * And another version for the statically-allocated C locale.  We only have
+ * components for the parts that are expected to be sensible.
+ */
+extern struct xlocale_component __xlocale_C_collate;
+extern struct xlocale_component __xlocale_C_ctype;
+
+
+#ifndef __NO_TLS
+/*
+ * The locale for this thread.
+ */
+_Thread_local locale_t __thread_locale;
+#endif
+
+/*
+ * Flag indicating that one or more per-thread locales exist.
+ */
+int __has_thread_locale;
+/*
+ * Private functions in setlocale.c.
+ */
+const char *
+__get_locale_env(int category);
+
+struct _xlocale __xlocale_global_locale = {
+	{0},
+	{
+		&__xlocale_global_collate,
+		&__xlocale_global_ctype, 0, 0, 0, 0
+		/* FIXME
+		&__xlocale_global_monetary,
+		&__xlocale_global_numeric,
+		&__xlocale_global_time,
+		&__xlocale_global_messages */
+	},
+	1,
+	0,
+	1,
+	0
+};
+
+struct _xlocale __xlocale_C_locale = {
+	{0},
+	{
+		&__xlocale_C_collate,
+		&__xlocale_C_ctype,
+		0, 0, 0, 0
+	},
+	1,
+	0,
+	1,
+	0
+};
+
+
+void *
+__numeric_load(const char *locale, locale_t unused)
+{
+	return NULL;
+}
+
+void *
+__monetary_load(const char *locale, locale_t unused)
+{
+	return NULL;
+}
+	
+
+void *
+__time_load(const char *locale, locale_t unused)
+{
+	return NULL;
+}
+
+void *
+__messages_load(const char *locale, locale_t unused)
+{
+	return NULL;
+}
+
+static void*(*constructors[])(const char*, locale_t) =
+{
+	__collate_load,
+	__ctype_load , 
+	__monetary_load,
+	__numeric_load,
+	__time_load,
+	__messages_load 
+};
+
+static pthread_key_t locale_info_key; 
+static int fake_tls;
+static locale_t thread_local_locale = NULL;
+
+static void init_key(void)
+{
+/*
+	pthread_key_create(&locale_info_key, xlocale_release);
+	pthread_setspecific(locale_info_key, (void*)42);
+	if (pthread_getspecific(locale_info_key) == (void*)42) {
+		pthread_setspecific(locale_info_key, 0);
+	} else {
+		fake_tls = 1;
+	} */
+	fake_tls = 1;
+	/* At least one per-thread locale has now been set. */
+	__has_thread_locale = 1;
+}
+
+static pthread_once_t once_control = PTHREAD_ONCE_INIT;
+
+/* Single threaded pthread_once(3).  libc won't have to -lpthread. 
+ *
+ * @author Martin Pelikan <martin.pelikan@gmail.com>
+ */
+static int
+_once(pthread_once_t *o, void (*init_routine)(void))
+{
+	if (o->state == PTHREAD_DONE_INIT)
+		return (0);
+	init_routine();
+	o->state = PTHREAD_DONE_INIT;
+	return (0);
+}
+
+
+static locale_t
+get_thread_locale(void)
+{
+
+	_once(&once_control, init_key);
+
+	if (thread_local_locale == NULL) {
+		thread_local_locale = &__xlocale_global_locale;	
+	}
+
+	return thread_local_locale;	
+/* FIXME	return (fake_tls ? thread_local_locale :
+		pthread_getspecific(locale_info_key)); */
+}
+
+inline locale_t __get_locale(void)
+{
+#ifndef __NO_TLS
+	if (!__has_thread_locale) {
+		return (&__xlocale_global_locale);
+	}
+	return (__thread_locale ? __thread_locale : &__xlocale_global_locale);
+#else
+	static locale_t l;
+        l = get_thread_locale();
+	return (l ? l : &__xlocale_global_locale);
+#endif
+}
+
+
+static void
+set_thread_locale(locale_t loc)
+{
+	_once(&once_control, init_key);
+	
+	if (NULL != loc) {
+		xlocale_retain((struct xlocale_refcounted*)loc);
+	}
+
+	thread_local_locale = loc;	
+}
+
+/**
+ * Clean up a locale, once its reference count reaches zero.  This function is
+ * called by xlocale_release(), it should not be called directly.
+ */
+static void
+destruct_locale(void *l)
+{
+	locale_t loc = l;
+	int type;
+	for (type=0 ; type<XLC_LAST ; type++) {
+		if (loc->components[type]) {
+			xlocale_release(loc->components[type]);
+		}
+	}
+	if (loc->csym) {
+		free(loc->csym);
+	}
+	free(l);
+}
+
+/**
+ * Allocates a new, uninitialised, locale.
+ */
+static locale_t
+alloc_locale(void)
+{
+	locale_t new = calloc(sizeof(struct _xlocale), 1);
+
+	new->header.destructor = destruct_locale;
+	new->monetary_locale_changed = 1;
+	new->numeric_locale_changed = 1;
+	return (new);
+}
+static void
+copyflags(locale_t new, locale_t old)
+{
+	new->using_monetary_locale = old->using_monetary_locale;
+	new->using_numeric_locale = old->using_numeric_locale;
+	new->using_time_locale = old->using_time_locale;
+	new->using_messages_locale = old->using_messages_locale;
+}
+
+static int dupcomponent(int type, locale_t base, locale_t new) 
+{
+	/* Always copy from the global locale, since it has mutable components.
+	 */
+	struct xlocale_component *src = base->components[type];
+
+	if (&__xlocale_global_locale == base && src != NULL) {
+		new->components[type] = constructors[type](src->locale, new);
+		if (new->components[type]) {
+			strncpy(new->components[type]->locale, src->locale,
+			    ENCODING_LEN);
+		}
+	} else if (base->components[type]) {
+		new->components[type] = xlocale_retain(base->components[type]);
+	} else {
+		/* If the component was NULL, return success - if base is a
+		 * valid locale then the flag indicating that this isn't
+		 * present should be set.  If it isn't a valid locale, then
+		 * we're stuck anyway. */
+		return 1;
+	}
+	return (0 != new->components[type]);
+}
+
+/*
+ * Public interfaces.  These are the five public functions described by the
+ * xlocale interface.  
+ */
+
+locale_t newlocale(int mask, const char *locale, locale_t base)
+{
+	int type;
+	const char *realLocale = locale;
+	int useenv = 0;
+	int success = 1;
+
+	_once(&once_control, init_key);
+
+	locale_t new = alloc_locale();
+	if (NULL == new) {
+		return (NULL);
+	}
+
+	FIX_LOCALE(base);
+	copyflags(new, base);
+
+	if (NULL == locale) {
+		realLocale = "C";
+	} else if ('\0' == locale[0]) {
+		useenv = 1;
+	}
+
+	
+	for (type=0 ; type<XLC_LAST ; type++) {
+		if (mask & 1) {
+			if (useenv) {
+				realLocale = __get_locale_env(type);
+			}
+			new->components[type] =
+			     constructors[type](realLocale, new);
+			if (new->components[type]) {
+				strncpy(new->components[type]->locale,
+				     realLocale, ENCODING_LEN);
+			} else {
+				success = 0;
+				break;
+			}
+		} else {
+			if (!dupcomponent(type, base, new)) {
+				success = 0;
+				break;
+			}
+		}
+		mask >>= 1;
+	}
+	if (0 == success) {
+		xlocale_release(new);
+		new = NULL;
+	}
+
+	return (new);
+}
+
+locale_t duplocale(locale_t base)
+{
+	locale_t new = alloc_locale();
+	int type;
+
+	_once(&once_control, init_key); 
+
+	if (NULL == new) {
+		return (NULL);
+	}
+	
+	FIX_LOCALE(base);
+	copyflags(new, base);
+
+	for (type=0 ; type<XLC_LAST ; type++) {
+		dupcomponent(type, base, new);
+	}
+
+	return (new);
+}
+
+/*
+ * Free a locale_t.  This is quite a poorly named function.  It actually
+ * disclaims a reference to a locale_t, rather than freeing it.  
+ */
+int
+freelocale(locale_t loc)
+{
+	/* Fail if we're passed something that isn't a locale. */
+	if ((NULL == loc) || (LC_GLOBAL_LOCALE == loc)) {
+		return (-1);
+	}
+	/* If we're passed the global locale, pretend that we freed it but don't
+	 * actually do anything. */
+	if (&__xlocale_global_locale == loc) {
+		return (0);
+	}
+	xlocale_release(loc);
+	return (0);
+}
+
+/*
+ * Returns the name of the locale for a particular component of a locale_t.
+ */
+const char *querylocale(int mask, locale_t loc)
+{
+	int type = ffs(mask) - 1;
+	FIX_LOCALE(loc);
+	if (type >= XLC_LAST)
+		return (NULL);
+	if (loc->components[type])
+		return (loc->components[type]->locale);
+	return ("C");
+}
+
+/*
+ * Installs the specified locale_t as this thread's locale.
+ */
+locale_t uselocale(locale_t loc)
+{
+	locale_t old = get_thread_locale();
+	if (NULL != loc) {
+		if (LC_GLOBAL_LOCALE == loc) {
+			loc = NULL;
+		}
+		set_thread_locale(loc);
+	}
+	return (old ? old : LC_GLOBAL_LOCALE);
+}
+
+void
+__print_locale(void *l)
+{
+	locale_t loc = l;
+	int type;
+	printf("Locale: %p\nFlags: ", l);
+	printf("using_monetary_locale=%i ", loc->using_monetary_locale);
+	printf("using_numeric_locale=%i ", loc->using_numeric_locale);
+	printf("using_time_locale=%i\n", loc->using_time_locale);
+	printf("using_messages_locale=%i ", loc->using_messages_locale);
+	printf("monetary_locale_changed=%i", loc->monetary_locale_changed);
+	printf("numeric_locale_changed=%i\n", loc->numeric_locale_changed);
+	printf("header.retain_count=%i ", loc->header.retain_count);
+	printf("header.destructor=%p ", loc->header.destructor);
+	printf("mblen=%p\n", loc->mblen);
+
+	for (type=0 ; type<XLC_LAST ; type++) {
+		printf("t=%i, %p", type, loc->components[type]);
+		if (loc->components[type] != NULL) {
+			printf(" %s", loc->components[type]->locale);
+		}
+		printf("\n");
+	}
+	printf("csym=%p\n", loc->csym);
+}
+
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/locale/xlocale_private.h src/lib/libc/locale/xlocale_private.h
--- src53collation/lib/libc/locale/xlocale_private.h	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/xlocale_private.h	Tue Apr  2 21:28:01 2013
@@ -0,0 +1,226 @@
+/*-
+ * Copyright (c) 2011 The FreeBSD Foundation
+ * All rights reserved.
+ *
+ * This software was developed by David Chisnall under sponsorship from
+ * the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/libc/locale/xlocale_private.h,v 1.7 2012/11/17 01:49:31 svnexp Exp $
+ */
+
+#ifndef _XLOCALE_PRIVATE__H_
+#define _XLOCALE_PRIVATE__H_
+
+#include <xlocale.h>
+#include <locale.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <machine/atomic.h>
+
+
+#define ENCODING_LEN 31
+
+#define __NO_TLS
+
+enum {
+	XLC_COLLATE = 0,
+	XLC_CTYPE,
+	XLC_MONETARY,
+	XLC_NUMERIC,
+	XLC_TIME,
+	XLC_MESSAGES,
+	XLC_LAST
+};
+
+
+/**
+ * Header used for objects that are reference counted.  Objects may optionally
+ * have a destructor associated, which is responsible for destroying the
+ * structure.  Global / static versions of the structure should have no
+ * destructor set - they can then have their reference counts manipulated as
+ * normal, but will not do anything with them.
+ *
+ * The header stores a retain count - objects are assumed to have a reference
+ * count of 1 when they are created, but the retain count is 0.  When the
+ * retain count is less than 0, they are freed.
+ */
+struct xlocale_refcounted {
+	/** Number of references to this component.  */
+	long retain_count;
+	/** Function used to destroy this component, if one is required*/
+	void(*destructor)(void*);
+};
+
+/**
+ * Header for a locale component.  All locale components must begin with this
+ * header.
+ */
+struct xlocale_component {
+	struct xlocale_refcounted header;
+	/** Name of the locale used for this component. */
+	char locale[ENCODING_LEN+1];
+};
+
+/**
+ * xlocale structure, stores per-thread locale information.  
+ */
+struct _xlocale {
+	struct xlocale_refcounted header;
+	/** Components for the locale.  */
+	struct xlocale_component *components[XLC_LAST];
+	/** Flag indicating if components[XLC_MONETARY] has changed since the
+	 * last call to localeconv_l() with this locale. */
+	int monetary_locale_changed;
+	/** Flag indicating whether this locale is actually using a locale for
+	 * LC_MONETARY (1), or if it should use the C default instead (0). */
+	int using_monetary_locale;
+	/** Flag indicating if components[XLC_NUMERIC] has changed since the
+	 * last call to localeconv_l() with this locale. */
+	int numeric_locale_changed;
+	/** Flag indicating whether this locale is actually using a locale for
+	 * LC_NUMERIC (1), or if it should use the C default instead (0). */
+	int using_numeric_locale;
+	/** Flag indicating whether this locale is actually using a locale for
+	 * LC_TIME (1), or if it should use the C default instead (0). */
+	int using_time_locale;
+	/** Flag indicating whether this locale is actually using a locale for
+	 * LC_MESSAGES (1), or if it should use the C default instead (0). */
+	int using_messages_locale;
+	/** The structure to be returned from localeconv_l() for this locale. */
+	struct lconv lconv;
+	/** Persistent state used by mblen() calls. */
+	__mbstate_t mblen;
+	/** Persistent state used by mbrlen() calls. */
+	__mbstate_t mbrlen;
+	/** Persistent state used by mbrtowc() calls. */
+	__mbstate_t mbrtowc;
+	/** Persistent state used by mbsnrtowcs() calls. */
+	__mbstate_t mbsnrtowcs;
+	/** Persistent state used by mbsrtowcs() calls. */
+	__mbstate_t mbsrtowcs;
+	/** Persistent state used by mbtowc() calls. */
+	__mbstate_t mbtowc;
+	/** Persistent state used by wcrtomb() calls. */
+	__mbstate_t wcrtomb;
+	/** Persistent state used by wcsnrtombs() calls. */
+	__mbstate_t wcsnrtombs;
+	/** Persistent state used by wcsrtombs() calls. */
+	__mbstate_t wcsrtombs;
+	/** Persistent state used by wctomb() calls. */
+	__mbstate_t wctomb;
+	/** Buffer used by nl_langinfo_l() */
+	char *csym;
+};
+
+/**
+ * Increments the reference count of a reference-counted structure.
+ */
+__attribute__((unused)) static void*
+xlocale_retain(void *val)
+{
+	struct xlocale_refcounted *obj = val;
+	/** FIXME should be atomic 
+	atomic_add_long(&(obj->retain_count), 1); */
+	obj->retain_count++;
+	return (val);
+}
+
+/**
+ * Decrements the reference count of a reference-counted structure, freeing it
+ * if this is the last reference, calling its destructor if it has one.
+ */
+__attribute__((unused)) static void
+xlocale_release(void *val)
+{
+	struct xlocale_refcounted *obj = val;
+	obj->retain_count--;
+/* FIXME long count = atomic_fetchadd_long(&(obj->retain_count), -1) - 1;*/
+	long count = obj->retain_count;
+	if (count < 0) {
+		if (obj->destructor != NULL) {
+			obj->destructor(obj);
+		}
+	}
+}
+
+/**
+ * Load functions.  Each takes the name of a locale and a pointer to the data
+ * to be initialised as arguments.  Two special values are allowed for the 
+ */
+extern void* __collate_load(const char*, locale_t);
+extern void* __ctype_load(const char*, locale_t);
+extern void* __messages_load(const char*, locale_t);
+extern void* __monetary_load(const char*, locale_t);
+extern void* __numeric_load(const char*, locale_t);
+extern void* __time_load(const char*, locale_t);
+
+extern struct _xlocale __xlocale_global_locale;
+extern struct _xlocale __xlocale_C_locale;
+
+/**
+ * Caches the rune table in TLS for fast access.
+ */
+void __set_thread_rune_locale(locale_t loc);
+
+/**
+ * Flag indicating whether a per-thread locale has been set.  If no per-thread
+ * locale has ever been set, then we always use the global locale.
+ */
+extern int __has_thread_locale;
+
+#ifndef __NO_TLS
+/**
+ * The per-thread locale.  Avoids the need to use pthread lookup functions when
+ * getting the per-thread locale.
+ */
+extern _Thread_local locale_t __thread_locale;
+#endif
+
+inline locale_t __get_locale(void);
+
+/**
+ * Two magic values are allowed for locale_t objects.  NULL and -1.  This
+ * function maps those to the real locales that they represent.
+ */
+static inline locale_t get_real_locale(locale_t locale)
+{
+	switch ((intptr_t)locale) {
+		case 0: return (&__xlocale_C_locale);
+		case -1: return (&__xlocale_global_locale);
+		default: return (locale);
+	}
+}
+
+/**
+ * Replace a placeholder locale with the real global or thread-local locale_t.
+ */
+#define FIX_LOCALE(l) (l = get_real_locale(l))
+
+
+#define ENCODING_LEN 31
+#define CATEGORY_LEN 11
+
+
+#endif
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/lib/libc/string/Makefile.inc src/lib/libc/string/Makefile.inc
--- src53collation/lib/libc/string/Makefile.inc	Mon Mar 25 18:28:28 2013
+++ src/lib/libc/string/Makefile.inc	Wed Apr  3 11:15:27 2013
@@ -9,7 +9,8 @@
 	strsignal.c strtok.c strxfrm.c \
 	wcscat.c wcschr.c wcscmp.c wcscpy.c wcscspn.c wcslcat.c wcslcpy.c \
 	wcslen.c wcsncat.c wcsncmp.c wcsncpy.c wcspbrk.c wcsrchr.c wcsspn.c \
-	wcsstr.c wcstok.c wcswcs.c wcswidth.c wmemchr.c wmemcmp.c wmemcpy.c \
+	wcsstr.c wcstok.c wcswcs.c wcswidth.c \
+	wmemchr.c wmemcmp.c wmemcpy.c \
 	wmemmove.c wmemset.c wcsdup.c \
 	timingsafe_bcmp.c wcscasecmp.c
 
@@ -124,7 +125,7 @@
 	memcmp.3 memcpy.3 memmove.3 memset.3 stpcpy.3 strcasecmp.3 strcat.3 \
 	strchr.3 strcmp.3 strcoll.3 strcpy.3 strcspn.3 strerror.3 \
 	string.3 strlen.3 strmode.3 strdup.3 strpbrk.3 strrchr.3 strsep.3 \
-	strsignal.3 strspn.3 strstr.3 strtok.3 strxfrm.3 swab.3 strlcpy.3 \
+	strsignal.3 strspn.3 strstr.3 strtok.3 swab.3 strxfrm.3 strlcpy.3 \
 	wcscasecmp.3 wcscat.3 wcschr.3 wcscmp.3 wcscpy.3 wcscspn.3 wcsdup.3 \
 	wcslcpy.3 wcslen.3 wcspbrk.3 wcsrchr.3 wcsspn.3 wcsstr.3 wcstok.3 \
 	wcswidth.3 wmemchr.3 wmemcmp.3 wmemcpy.3 wmemmove.3 wmemset.3
@@ -135,14 +136,19 @@
 MLINKS+=strchr.3 index.3
 MLINKS+=strrchr.3 rindex.3
 MLINKS+=strcasecmp.3 strncasecmp.3
+MLINKS+=strcasecmp.3 strcasecmp_l.3
+MLINKS+=strcasecmp.3 strncasecmp_l.3
 MLINKS+=strcat.3 strncat.3
 MLINKS+=strcmp.3 strncmp.3
+MLINKS+=strcoll.3 strncoll_l.3
 MLINKS+=strcpy.3 strncpy.3
 MLINKS+=strdup.3 strndup.3
 MLINKS+=strlcpy.3 strlcat.3
 MLINKS+=strlen.3 strnlen.3
 MLINKS+=strstr.3 strcasestr.3
+MLINKS+=strstr.3 strcasestr_l.3
 MLINKS+=strtok.3 strtok_r.3
+MLINKS+=strxfrm.3 strxfrm_l.3
 MLINKS+=strerror.3 strerror_r.3
 MLINKS+=wcscasecmp.3 wcsncasecmp.3
 MLINKS+=wcscat.3 wcsncat.3
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/regress/lib/libc/locale/Makefile src/regress/lib/libc/locale/Makefile
--- src53collation/regress/lib/libc/locale/Makefile	Mon Apr  1 08:25:36 2013
+++ src/regress/lib/libc/locale/Makefile	Wed Apr  3 12:49:00 2013
@@ -1,7 +1,7 @@
 # $OpenBSD: Makefile,v 1.2 2013/08/01 21:26:30 kettenis Exp $
 
 .if defined(REGRESS_FULL)
-SUBDIR+= check_isw check_collate
+SUBDIR+= check_isw check_collate check_xlocale
 .endif
 
 install:
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/regress/lib/libc/locale/check_xlocale/Makefile src/regress/lib/libc/locale/check_xlocale/Makefile
--- src53collation/regress/lib/libc/locale/check_xlocale/Makefile	Wed Dec 31 19:00:00 1969
+++ src/regress/lib/libc/locale/check_xlocale/Makefile	Tue Apr  2 21:37:08 2013
@@ -0,0 +1,12 @@
+#	$OpenBSD: Makefile,v 1.1 2005/08/11 21:57:02 espie Exp $
+
+NOMAN=
+PROG=check_xlocale
+
+CFLAGS=-g
+
+
+run-regress-check_xlocale: ${PROG}
+	./${PROG} >/dev/null
+
+.include <bsd.regress.mk>
diff -ruN -x obj -x CVS -x *rej -x *orig -x *~ src53collation/regress/lib/libc/locale/check_xlocale/check_xlocale.c src/regress/lib/libc/locale/check_xlocale/check_xlocale.c
--- src53collation/regress/lib/libc/locale/check_xlocale/check_xlocale.c	Wed Dec 31 19:00:00 1969
+++ src/regress/lib/libc/locale/check_xlocale/check_xlocale.c	Wed Apr  3 12:47:22 2013
@@ -0,0 +1,408 @@
+/**
+ * Public domain according to Colombian Legislation. 
+ * http://www.pasosdejesus.org/dominio_publico_colombia.html
+ * 2013. vtamara@pasosdeJesus.org.
+ */
+
+#include <xlocale.h>
+#include <ctype.h>
+#include <inttypes.h>
+#include <langinfo.h>
+#include <locale.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <wchar.h>
+#include <wctype.h>
+
+int bad;
+
+#define p(t) printf("%s:\t ",#t); \
+	if (t) { \
+		printf("\x1b[38;5;2mOK\x1b[0m\n"); \
+	} else { \
+		bad++; \
+		printf("\x1b[38;5;1mERROR\x1b[0m\n"); \
+	}
+
+
+void
+__print_locale(void *l);
+
+locale_t
+__get_locale(void);
+
+void __print_ctypetable();
+
+#define dpl(__l) printf("%s ", #__l); __print_locale(__l);
+
+void test_xlocale() {
+	static locale_t cl;
+	cl = __get_locale();
+	printf("%p\n", cl);
+	dpl((void *)cl);
+	char *nl = setlocale(LC_ALL, "es_CO.UTF-8");
+	dpl((void *)__get_locale());
+	printf("locale %s\n", nl);
+	locale_t es_CO_UTF_8 = uselocale(NULL);
+	dpl(es_CO_UTF_8);
+	char *r;
+	p(strcmp((r = (char *)querylocale(LC_CTYPE, es_CO_UTF_8)), "es_CO.UTF-8") == 0);
+	printf("r=%s\n", r);
+	p(strcmp((r = (char *)querylocale(LC_COLLATE, es_CO_UTF_8)), "es_CO.UTF-8") == 0);
+
+	p(es_CO_UTF_8 != NULL);
+	locale_t esp = newlocale(LC_CTYPE_MASK | LC_COLLATE_MASK, "es_CO.UTF-8", NULL);
+	p(es_CO_UTF_8 != esp);
+//	p(iswlower_l(L'ñ', esp));
+//	p(!iswlower_l(L'Ñ', esp));
+
+	//__print_ctypetable();
+	locale_t esp2 = duplocale(es_CO_UTF_8);
+	locale_t esp3 = duplocale(esp2);
+	locale_t esp4 = duplocale(esp3);
+	locale_t esp5 = duplocale(esp3);
+	locale_t esp6 = duplocale(esp3);
+	//__collate_print_tables(NULL);
+	p(es_CO_UTF_8 != esp2);
+	p(freelocale(esp) == 0);
+	p(freelocale(esp2) == 0);
+	p(freelocale(esp3) == 0);
+	p(freelocale(esp4) == 0);
+	p(freelocale(esp5) == 0);
+	p(freelocale(esp6) == 0);
+}
+
+void test_wchar() {
+	char *mb = "ñ"; // Source must be in UTF8
+	char *mbs = "ñoño"; // Una cadena multibyte 
+	char *nl = setlocale(LC_ALL, "C");  
+	size_t s;
+	printf("locale %s\n", nl);
+	p(sizeof(mb) == 8);
+	p((s = mblen(mb, 10)) == 1); 
+	printf("s=%i\n", s);
+	p((s = mbrlen(mb, 10, NULL)) == 1);
+	printf("s=%i\n", s);
+	p((s = mblen(mbs, 10)) == 1);
+	printf("s=%i\n", s);
+	nl = setlocale(LC_ALL, "es_CO.ISO8859-1");
+	locale_t l = uselocale(NULL);
+	printf("locale %s\n", nl);
+	p(mblen_l(mb, 3, l) == 1);
+	p(mbrlen_l(mb, 3, NULL, l) == 1);
+	p(mblen_l(mbs, 10, l) == 1);
+	p(mbrlen_l(mbs, 10, NULL, l) == 1);
+	nl = setlocale(LC_ALL, "es_CO.UTF-8");
+	printf("locale %s\n", nl);
+	p(mblen(mb, 3) == 2);
+	p(mbrlen(mb, 3, NULL) == 2);
+	p(mblen(mbs, 10) == 2);
+	p(mbrlen(mbs, 10, NULL) == 2);
+	wchar_t ws[100];
+	p((s = mbtowc_l(ws, mb, 3, l)) == 2);
+	p((s = mbtowc(ws, mb, 3)) == 2);
+	p((s = mbtowc_l(ws, mbs, 5, l)) == 2);
+	unsigned char bp[1000];
+	snprintf(bp, 1000, "%lc", *ws);
+	p(bp[0]==195 && bp[1]==177 && bp[2]==0)
+
+	wchar_t w = L'á';
+	char mb3[10];
+	p((s = wctomb_l(mb3, w, l)) == 2);
+	mb3[s] = '\0';
+	p((s = mbstowcs_l(ws, mb3, 10, l)) == 1);
+	p((s = wcstombs_l(mb3, L"uña", 10, l)) == 4);
+	mb3[s] = '\0';
+	snprintf(bp, 1000, "%s", mb3);
+	//printf("bp=%s, bp[0]=%i && bp[1]==%i && bp[2]==%i && bp[3]==%i && bp[4]==%i\n", bp, bp[0], bp[1], bp[2], bp[3], bp[4]);
+	p(bp[0]=117 && bp[1]==195 && bp[2]==177 && bp[3]==97);
+
+//	printf("ws(s)=%s\n", ws);
+//	printf("ws(ls)=%ls \n", ws);
+//	printf("*ws(lc)=%lc \n", *ws);
+	p(btowc_l('a', l) == L'a');	
+	mbstate_t mbst;
+        bzero(&mbst, sizeof(mbst));
+	p(mbsinit_l(&mbst, l));
+	p((s = mbrtowc_l(&w, "ñ", 3, &mbst, l)) == 2);
+	p(mbsinit_l(&mbst, l));
+	bp[0] = 0xf8;
+	bp[1] = 0x1a;
+	bp[2] = 0;
+	p((s = mbrtowc_l(&w, "ñ", 1, &mbst, l)) == -2);
+	p((s = mbrtowc_l(&w, bp, 1, &mbst, l)) == -1);
+	p((s = mbsrtowcs_l(ws, (const char **)&mbs, 7, &mbst, l)) > 0);
+	p((s = mbsnrtowcs_l(ws, (const char **)&mbs, 7, 5, &mbst, l)) > 0);
+	p((s = wcrtomb_l(bp, L'ñ', &mbst, l)) > 0);
+	p((s = mbstowcs_l(ws, "niño", 10, l)) > 0 && wcsncmp(ws, L"niño", 10) == 0);
+	p((s = wcsrtombs_l(mb3, (const wchar_t **)&ws, 10, &mbst, l)) > 0);
+	p((s = wcsnrtombs_l(bp, (const wchar_t **)&ws, 10, 10, &mbst, l)) > 0);
+	p(wctob_l(L'a', l) == 'a');
+
+}
+
+#if 0
+void test_ctype() {
+	char *nl = setlocale(LC_ALL, "es_CO.UTF-8");
+	printf("locale %s\n", nl);
+	locale_t es_CO_UTF_8 = uselocale(NULL);
+
+	size_t s;
+	wchar_t ws[100];
+	p((s = wcswidth_l(ws, 10, es_CO_UTF_8)) == 4);
+	p((s = wcwidth_l(L'a', es_CO_UTF_8)) == 1);
+	p(wctype("lower") == wctype_l("lower", es_CO_UTF_8));
+	p(iswctype(L'ñ', wctype("lower")));
+	p(iswctype_l(L'ñ', wctype("lower"), es_CO_UTF_8));
+	p(!iswctype_l(L'Ñ', wctype("lower"), es_CO_UTF_8));
+	p(isalnum_l('a', es_CO_UTF_8));
+	p(isalnum_l('1', es_CO_UTF_8));
+	p(iswalnum_l(L'ñ', es_CO_UTF_8));
+	p(iswalnum_l(L'1', es_CO_UTF_8));
+	p(!iswalnum_l(L' ', es_CO_UTF_8));
+	p(isalpha_l('a', es_CO_UTF_8));
+	p(!isalpha_l('1', es_CO_UTF_8));
+	p(iswalpha_l(L'ñ', es_CO_UTF_8));
+	p(!iswalpha_l(L'1', es_CO_UTF_8));
+	p(iscntrl_l('\n', es_CO_UTF_8));
+	p(!iscntrl_l(' ', es_CO_UTF_8));
+	p(iswcntrl(L'\n'));
+	p(iswcntrl_l(L'\n', es_CO_UTF_8));
+	p(!iswcntrl_l(L'n', es_CO_UTF_8));
+	p(isdigit_l('1', es_CO_UTF_8));
+	p(!isdigit_l(' ', es_CO_UTF_8));
+	p(iswdigit_l(L'1', es_CO_UTF_8));
+	p(!iswdigit_l(L'ñ', es_CO_UTF_8));
+	p(isgraph_l('a', es_CO_UTF_8));
+	p(!isgraph_l('\0', es_CO_UTF_8));
+	p(iswgraph_l(L'ñ', es_CO_UTF_8));
+	p(!iswgraph_l(L'\0', es_CO_UTF_8));
+	p(islower_l('a', es_CO_UTF_8));
+	p(!islower_l('A', es_CO_UTF_8));
+	p(iswlower_l(L'ñ', es_CO_UTF_8));
+	p(!iswlower_l(L'Ñ', es_CO_UTF_8));
+	p(iswprint_l(L'ñ', es_CO_UTF_8));
+	p(!iswprint_l(L'\0', es_CO_UTF_8));
+	p(ispunct_l('.', es_CO_UTF_8));
+	p(!ispunct_l(' ', es_CO_UTF_8));
+	p(iswpunct_l(L'.', es_CO_UTF_8));
+	p(iswpunct_l(L'.', es_CO_UTF_8));
+	p(!iswpunct_l(L'ñ', es_CO_UTF_8));
+	p(isspace_l(' ', es_CO_UTF_8));
+	p(!isspace_l('n', es_CO_UTF_8));
+	p(iswspace_l(L' ', es_CO_UTF_8));
+	p(!iswspace_l(L'ñ', es_CO_UTF_8));
+	p(isupper_l('N', es_CO_UTF_8));
+	p(!isupper_l('n', es_CO_UTF_8));
+	p(iswupper_l(L'Ñ', es_CO_UTF_8));
+	p(iswupper_l(L'Ñ', es_CO_UTF_8));
+	p(!iswupper_l(L'ñ', es_CO_UTF_8));
+	p(iswxdigit_l(L'a', es_CO_UTF_8));
+	p(iswxdigit_l(L'1', es_CO_UTF_8));
+	p(iswxdigit_l(L'f', es_CO_UTF_8));
+	p(!iswxdigit_l(L'g', es_CO_UTF_8));
+	p(isxdigit_l('f', es_CO_UTF_8));
+	p(!isxdigit_l('g', es_CO_UTF_8));
+	p(digittoint_l(L'1', es_CO_UTF_8) == 1);
+	p(isblank_l(' ', es_CO_UTF_8));
+	p(!isblank_l('a', es_CO_UTF_8));
+	p(iswblank_l(L'\t', es_CO_UTF_8));
+	p(!iswblank_l(L'ñ', es_CO_UTF_8));
+	p(ishexnumber_l('a', es_CO_UTF_8));
+	p(!ishexnumber_l(' ', es_CO_UTF_8));
+	p(iswhexnumber_l(L'a', es_CO_UTF_8));
+	p(!iswhexnumber_l(L' ', es_CO_UTF_8));
+	p(!isideogram_l(' ', es_CO_UTF_8));
+	p(iswideogram_l(0x3006, es_CO_UTF_8));
+	p(!iswideogram_l(L' ', es_CO_UTF_8));
+	p(isnumber_l('1', es_CO_UTF_8));
+	p(!isnumber_l(' ', es_CO_UTF_8));
+	p(iswnumber_l(L'1', es_CO_UTF_8));
+	p(!iswnumber_l(L' ', es_CO_UTF_8));
+	p(!isphonogram_l(' ', es_CO_UTF_8));
+	p(iswphonogram_l(0x0f00, es_CO_UTF_8));
+	p(!iswphonogram_l(L' ', es_CO_UTF_8));
+	p(isprint_l('1', es_CO_UTF_8));
+	p(!isprint_l('\0', es_CO_UTF_8));
+	p(isrune_l('1', es_CO_UTF_8));
+	p(!isrune_l(EOF, es_CO_UTF_8));
+	p(iswrune_l(L'1', es_CO_UTF_8));
+	p(!iswrune_l(WEOF, es_CO_UTF_8));
+	p(!isspecial_l('a', es_CO_UTF_8));
+	p(iswspecial_l(0x00b2, es_CO_UTF_8));
+	p(!iswspecial_l(L'\0', es_CO_UTF_8));
+	p(nextwctype(-1, wctype("graph")) > 0);
+	p(tolower_l('A', es_CO_UTF_8) == 'a');
+	p(_tolower_l('A', es_CO_UTF_8) == 'a');
+	p(tolower('A') == 'a');
+	p(_tolower('A') == 'a');
+	p(towlower_l(L'Á', es_CO_UTF_8) == L'á');
+	p(towupper_l(L'á', es_CO_UTF_8) == L'Á');
+	p(toupper_l('a', es_CO_UTF_8) == 'A');
+	p(toupper('a') == 'A');
+	p(_toupper_l('a', es_CO_UTF_8) == 'A');
+	p(_toupper('a') == 'A');
+	p(wctrans_l("invalido", es_CO_UTF_8) == 0);
+	wchar_t lu[7][2] = {{ L'ñ', L'Ñ'},
+		{L'á', L'Á'},
+		{L'é', L'É'},
+		{L'í', L'Í'},
+		{L'ó', L'Ó'},
+		{L'ú', L'Ú'},
+		{L'ü', L'Ü'}
+	};
+	wctrans_t tl;
+	p((tl = wctrans_l("tolower", es_CO_UTF_8)) != 0);
+	wctrans_t tu;
+	p((tu = wctrans_l("toupper", es_CO_UTF_8)) != 0);
+	int c;
+	for(c=0; c<7; c++) {
+		p(towctrans_l(lu[c][1], tl, es_CO_UTF_8) == lu[c][0]);
+		p(towlower_l(lu[c][1], es_CO_UTF_8) == lu[c][0]);
+		p(towctrans_l(lu[c][0], tu, es_CO_UTF_8) == lu[c][1]);
+		p(towupper_l(lu[c][0], es_CO_UTF_8) == lu[c][1]);
+	}
+
+}
+
+
+
+void test_string() 
+{
+	char *nl = setlocale(LC_ALL, "es_CO.UTF-8");
+	locale_t es_CO_UTF_8 = uselocale(NULL);
+	printf("locale %s\n", nl);
+
+	p(strcoll_l("b", "é", es_CO_UTF_8) < 0);
+	wchar_t wcsb[1000];
+	mbstowcs(wcsb, "b", 1000);
+	wchar_t wcse[1000];
+	mbstowcs(wcse, "é", 1000);
+	p(wcscoll_l(wcsb, wcse, es_CO_UTF_8) < 0);
+	
+	mbstowcs(wcsb, "b", 1000);
+	mbstowcs(wcse, "é", 1000);
+	p(wcscoll_l(wcsb, wcse, es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"b", L"é", es_CO_UTF_8) < 0);
+	p(strcoll("á", "e") < 0);
+	p(strcoll("ama", "ana") < 0);
+	p(strcoll_l("á", "e", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"b", L"é", es_CO_UTF_8) < 0);
+	p(wcscoll(L"á", L"e") < 0);
+	p(wcscoll_l(L"á", L"e", es_CO_UTF_8) < 0);
+	/* Order in spanish*/
+	p(wcscoll_l(L" ", L"á", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"á", L"b", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"d", L"é", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"é", L"f", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"h", L"í", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"í", L"j", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"n", L"ñ", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"ñ", L"o", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"ñ", L"ó", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"ó", L"p", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"t", L"ú", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"t", L"ü", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"ú", L"v", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"ü", L"v", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"Á", L"B", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"D", L"É", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"É", L"F", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"H", L"Í", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"Í", L"J", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"N", L"Ñ", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"Ñ", L"O", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"Ñ", L"Ó", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"Ó", L"P", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"T", L"Ú", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"T", L"Ü", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"Ú", L"V", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"Ü", L"V", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"", L"Á", es_CO_UTF_8) < 0);
+	p(wcscoll_l(L"á", L"", es_CO_UTF_8) > 0);
+	p(wcscoll_l(L"áá", L"á", es_CO_UTF_8) > 0);
+	
+	wchar_t wa[10], wb[10], we[10], wf[10], wn[10], wegne[10],
+		wo[10];
+
+	p(wcsxfrm_l(wo, L"oro", 1000, es_CO_UTF_8) > 0);
+	printf("oro wo='%ls'\n", wo);
+	p(wcsxfrm_l(wa, L"", 1000, es_CO_UTF_8) >= 0);
+	printf("wa='%ls'\n", wa);
+	p(wcsxfrm_l(wa, L"á", 1000, es_CO_UTF_8) > 0);
+	printf("wa='%ls'\n", wa);
+	p(wcsxfrm_l(wb, L"b", 1000, es_CO_UTF_8) > 0);
+	printf("wb='%ls'\n", wb);
+	p(wcscmp(wa, wb) < 0);
+	p(wcsxfrm_l(we, L"é", 1000, es_CO_UTF_8) > 0);
+	printf("we='%ls'\n", we);
+	p(wcscmp(wb, we) < 0);
+	p(wcsxfrm_l(wf, L"f", 1000, es_CO_UTF_8) > 0);
+	printf("wf='%ls'\n", wf);
+	p(wcscmp(wb, wf) < 0);
+	p(wcscmp(we, wf) < 0);
+	p(wcsxfrm_l(wn, L"n", 1000, es_CO_UTF_8) > 0);
+	printf("wn='%ls'\n", wn);
+	p(wcsxfrm_l(wegne, L"ñ", 1000, es_CO_UTF_8) > 0);
+	printf("wegne='%ls'\n", wegne);
+	p(wcsxfrm_l(wo, L"o", 1000, es_CO_UTF_8) > 0);
+	printf("o wo='%ls'\n", wo);
+	p(wcsxfrm_l(wo, L"oso", 1000, es_CO_UTF_8) > 0);
+	printf("oso wo='%ls'\n", wo);
+	p(wcscmp(wn, wegne) < 0);
+	p(wcscmp(wegne, wo) < 0);
+	
+	char a[1000], b[1000], e[1000], f[1000];
+	size_t sr = 0;
+	__collate_print_tables(NULL);
+	p((sr = strxfrm_l(NULL, "equis", 0, es_CO_UTF_8)) == 5);
+	p(strxfrm_l(NULL, "", 1000, es_CO_UTF_8) == 0);
+	p(strxfrm_l(a, "", 1000, es_CO_UTF_8) == 0 && a[0] == '\0');
+	p(strxfrm_l(a, "á", 1000, es_CO_UTF_8) > 0);
+	p(strxfrm_l(b, "b", 1000, es_CO_UTF_8) > 0);
+	p(strcmp(a, b) < 0);
+	p(strxfrm_l(e, "é", 1000, es_CO_UTF_8) > 0);
+	printf("é e=%s\n", e);
+	p(strcmp(b, e) < 0);
+	p(strxfrm_l(f, "f", 1000, es_CO_UTF_8) > 0);
+	p(strcmp(b, f) < 0);
+	p(strcmp(e, f) < 0);
+	p(strxfrm_l(e, "éa", 1000, es_CO_UTF_8) > 0);
+	printf("e=%s\n", e);
+	p(strxfrm_l(f, "éb", 1000, es_CO_UTF_8) > 0);
+	printf("f=%s\n", f);
+	p(strcmp(e, f) < 0);
+	p(strxfrm_l(f, "oso", 1000, es_CO_UTF_8) > 0);
+	printf("oso f=%s\n", f);
+	p(strcmp(e, f) < 0);
+
+	p(strcasecmp_l("n", "N", es_CO_UTF_8) == 0);
+	p(strcasecmp_l("largo", "largote", es_CO_UTF_8) < 0);
+	p(strcasecmp_l("cortote", "corto", es_CO_UTF_8) > 0);
+	p(strncasecmp_l("n", "N", 1, es_CO_UTF_8) == 0);
+	p(strcasestr_l("nino", "O", es_CO_UTF_8) != NULL);
+	p(wcscasecmp_l(L"ñ", L"Ñ", es_CO_UTF_8) == 0);
+	p(wcscasecmp_l(L"á", L"b", es_CO_UTF_8) < 0);
+	p(wcscasecmp_l(L"a", L"á", es_CO_UTF_8) <= 0);
+	p(wcscasecmp_l(L"", L"á", es_CO_UTF_8) < 0);
+	p(wcscasecmp_l(L"", L"a", es_CO_UTF_8) < 0);
+	p(wcscasecmp_l(L"", L"a", es_CO_UTF_8) < 0);
+	p(wcscasecmp_l(L"á", L"", es_CO_UTF_8) > 0);
+	p(wcscasecmp_l(L"áá", L"á", es_CO_UTF_8) > 0);
+	p(wcscasecmp(L"á", L"b") < 0);
+	p(wcscasecmp(L"a", L"á") <= 0);
+	p(wcsncasecmp_l(L"n", L"N", 1, es_CO_UTF_8) == 0);
+}
+#endif
+
+int main()
+{
+	test_xlocale();
+	test_wchar();
+//	test_ctype();
+//	test_string();
+	
+	return bad != 0;
+}
diff -ruN -x CVS -x obj src53collation/include/Makefile src/include/Makefile
--- src53collation/include/Makefile	Sun Mar 31 21:52:28 2013
+++ src/include/Makefile	Tue Apr 16 14:30:26 2013
@@ -22,7 +22,7 @@
 	stdbool.h stddef.h stdio.h stdlib.h \
 	string.h strings.h struct.h sysexits.h tar.h tgmath.h \
 	time.h ttyent.h tzfile.h unistd.h utime.h utmp.h vis.h \
-	wchar.h wctype.h
+	wchar.h wctype.h xlocale.h
 
 FILES+=	link.h link_aout.h link_elf.h
 
diff -ruN -x CVS -x obj src53collation/include/xlocale.h src/include/xlocale.h
--- src53collation/include/xlocale.h	Wed Dec 31 19:00:00 1969
+++ src/include/xlocale.h	Tue Apr 16 14:28:06 2013
@@ -0,0 +1,429 @@
+/*-
+ * Copyright (c) 2011, 2012 The FreeBSD Foundation
+ * All rights reserved.
+ *
+ * This software was developed by David Chisnall under sponsorship from
+ * the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/include/xlocale.h,v 1.6 2012/11/17 01:49:15 svnexp Exp $
+ * * $FreeBSD: src/include/xlocale/_locale.h,v 1.4 2012/11/17 01:49:16 svnexp Exp $
+ *  $FreeBSD: src/include/xlocale/_string.h,v 1.4 2012/11/17 01:49:16 svnexp Exp  $
+ * $FreeBSD: src/include/xlocale/_inttypes.h,v 1.4 2012/11/17 01:49:16 svnexp Exp $
+ * $FreeBSD: src/include/xlocale/_monetary.h,v 1.4 2012/11/17 01:49:16 svnexp Exp $
+ * $FreeBSD: src/include/xlocale/_stdlib.h,v 1.4 2012/11/17 01:49:16 svnexp Exp $
+ * $FreeBSD: src/include/xlocale/_time.h,v 1.4 2012/11/17 01:49:16 svnexp Exp $
+ * $FreeBSD: src/include/xlocale/_langinfo.h,v 1.4 2012/11/17 01:49:16 svnexp Exp $
+ * $FreeBSD: src/include/xlocale/_stdio.h,v 1.4 2012/11/17 01:49:16 svnexp Exp $
+ * $FreeBSD: src/include/xlocale/_wchar.h,v 1.4 2012/11/17 01:49:16 svnexp Exp $
+ */
+
+#ifndef _XLOCALE_H_
+#define _XLOCALE_H_
+
+#include <locale.h>
+
+#define LC_COLLATE_MASK  (1<<0)
+#define LC_CTYPE_MASK    (1<<1)
+#define LC_MESSAGES_MASK (1<<2)
+#define LC_MONETARY_MASK (1<<3)
+#define LC_NUMERIC_MASK  (1<<4)
+#define LC_TIME_MASK     (1<<5)
+#define LC_ALL_MASK      (LC_COLLATE_MASK | LC_CTYPE_MASK | LC_MESSAGES_MASK | \
+			  LC_MONETARY_MASK | LC_NUMERIC_MASK | LC_TIME_MASK)
+#define LC_GLOBAL_LOCALE ((locale_t)-1)
+
+#ifndef _LOCALE_T_DEFINED
+#define _LOCALE_T_DEFINED
+typedef struct	_xlocale *locale_t;
+#endif
+
+#if !defined(_WCHAR_T_DEFINED_) && !defined(__cplusplus)
+#include <wchar.h>
+#endif
+
+
+locale_t	 duplocale(locale_t base);
+int		 freelocale(locale_t loc);
+locale_t	 newlocale(int mask, const char *locale, locale_t base);
+const char	*querylocale(int mask, locale_t loc);
+locale_t	 uselocale(locale_t loc);
+
+
+#ifdef _STRING_H_
+
+/* POSIX2008 functions */
+int	 strcoll_l(const char *, const char *, locale_t);
+int	 wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
+size_t	 strxfrm_l(char *, const char *, size_t, locale_t);
+
+/* XLOCALE */ 
+int	 strcasecmp_l(const char *, const char *, locale_t);
+char	*strcasestr_l(const char *, const char *, locale_t);
+int	 strncasecmp_l(const char *, const char *, size_t, locale_t);
+
+#endif /* _STRING_H_ */
+
+
+#ifdef _INTTYPES_H_
+
+/*
+ * Extended locale versions of the locale-aware functions from inttypes.h.
+ * Include <inttypes.h> before <xlocale.h> to expose these.
+ */
+intmax_t	strtoimax_l(const char * __restrict, char ** __restrict,
+		    int, locale_t);
+uintmax_t	strtoumax_l(const char * __restrict, char ** __restrict, int,
+		    locale_t);
+intmax_t	wcstoimax_l(const wchar_t * __restrict, wchar_t ** __restrict,
+		    int , locale_t);
+uintmax_t	wcstoumax_l(const wchar_t * __restrict, wchar_t ** __restrict,
+		    int, locale_t);
+#endif /* _INTTYPES_H_ */
+
+
+#ifdef _MONETARY_H_
+
+#ifndef _XLOCALE_MONETARY_H
+#define _XLOCALE_MONETARY_H
+
+ssize_t strfmon_l(char *, size_t, locale_t, const char *, ...);
+/*    __strfmonlike(4, 5); */
+
+#endif /* _XLOCALE_MONETARY_H */
+#endif /* _MONETARY_H_ */
+
+#ifdef _STDLIB_H_
+
+/*
+ * Extended locale versions of the locale-aware functions from stdlib.h.
+ *
+ * Include <stdlib.h> before <xlocale.h> to expose these.
+ */
+double			 atof_l(const char *, locale_t);
+int			 atoi_l(const char *, locale_t);
+long			 atol_l(const char *, locale_t);
+long long		 atoll_l(const char *, locale_t);
+int			 mblen_l(const char *, size_t, locale_t);
+size_t			 mbstowcs_l(wchar_t * __restrict,
+			    const char * __restrict, size_t, locale_t);
+int			 mbtowc_l(wchar_t * __restrict,
+			    const char * __restrict, size_t, locale_t);
+double			 strtod_l(const char *, char **, locale_t);
+float			 strtof_l(const char *, char **, locale_t);
+long			 strtol_l(const char *, char **, int, locale_t);
+long double		 strtold_l(const char *, char **, locale_t);
+long long		 strtoll_l(const char *, char **, int, locale_t);
+unsigned long		 strtoul_l(const char *, char **, int, locale_t);
+unsigned long long	 strtoull_l(const char *, char **, int, locale_t);
+size_t			 wcstombs_l(char * __restrict,
+			    const wchar_t * __restrict, size_t, locale_t);
+int			 wctomb_l(char *, wchar_t, locale_t);
+
+int			 ___mb_cur_max_l(locale_t);
+#define MB_CUR_MAX_L(x) (___mb_cur_max_l(x))
+
+#endif /* _STDLIB_H_ */
+
+#ifdef _TIME_H_
+
+/* POSIX2008 */
+size_t	 strftime_l(char * __restrict, size_t, const char * __restrict,
+	    const struct tm * __restrict, locale_t); /* __strftimelike(3, 0); */
+
+/* XLOCALE */
+char	*strptime_l(const char * __restrict, const char * __restrict,
+           struct tm * __restrict, locale_t);
+
+#endif /* _TIME_H_ */
+
+#ifdef _LANGINFO_H_
+
+char	*nl_langinfo_l(nl_item, locale_t);
+
+#endif /* _LANGINFO_H */
+
+#if defined(_CTYPE_H_) || defined(_WCTYPE_H)
+
+#include <sys/types.h>
+
+#ifndef	_WCTYPE_T_DEFINED_
+#define	_WCTYPE_T_DEFINED_
+typedef	__wctype_t	wctype_t;
+#endif
+
+#ifndef	_WINT_T_DEFINED_
+#define	_WINT_T_DEFINED_
+typedef	__wint_t	wint_t;
+#endif
+
+#ifndef _WCTRANS_T_DEFINED_
+#define _WCTRANS_T_DEFINED_
+typedef __wctrans_t     wctrans_t;
+#endif
+
+#ifndef _RUNE_T_DEFINED_
+#define _RUNE_T_DEFINED_
+typedef uint32_t        rune_t;
+#endif
+
+
+inline int iswctype_l(wint_t, wctype_t, locale_t);
+
+inline int isalnum_l(int, locale_t);
+
+inline int isalpha_l(int, locale_t);
+
+inline int isblank_l(int, locale_t);
+
+inline int iscntrl_l(int, locale_t);
+
+inline int isdigit_l(int, locale_t);
+
+inline int isgraph_l(int, locale_t);
+
+inline int ishexnumber_l(int, locale_t);
+
+inline int isideogram_l(int, locale_t);
+
+inline int islower_l(int, locale_t);
+
+inline int isnumber_l(int, locale_t);
+
+inline int isphonogram_l(int, locale_t);
+
+inline int isprint_l(int, locale_t);
+
+inline int ispunct_l(int, locale_t);
+
+inline int isrune_l(int, locale_t);
+
+inline int isspace_l(int, locale_t);
+
+inline int isspecial_l(int, locale_t);
+
+inline int isupper_l(int, locale_t);
+
+inline int isxdigit_l(int, locale_t);
+
+inline int iswalnum_l(wint_t, locale_t);
+
+inline int iswalpha_l(wint_t, locale_t);
+
+inline int iswblank_l(wint_t, locale_t);
+
+inline int iswcntrl_l(wint_t, locale_t);
+
+inline int iswdigit_l(wint_t, locale_t);
+
+inline int iswgraph_l(wint_t, locale_t);
+
+inline int iswhexnumber_l(wint_t, locale_t);
+
+inline int iswideogram_l(wint_t, locale_t);
+
+inline int iswlower_l(wint_t, locale_t);
+
+inline int iswnumber_l(wint_t, locale_t);
+
+inline int iswphonogram_l(wint_t, locale_t);
+
+inline int iswprint_l(wint_t, locale_t);
+
+inline int iswpunct_l(wint_t, locale_t);
+
+inline int iswrune_l(wint_t, locale_t);
+
+inline int iswspace_l(wint_t, locale_t);
+
+inline int iswspecial_l(wint_t, locale_t);
+
+inline int iswupper_l(wint_t, locale_t);
+
+inline int iswxdigit_l(wint_t, locale_t);
+
+inline wint_t towlower_l(wint_t, locale_t);
+
+inline wint_t towupper_l(wint_t, locale_t);
+
+inline int __wcwidth_l(rune_t, locale_t);
+
+int iswctype_l(wint_t, wctype_t, locale_t);
+
+wctype_t wctype_l(const char *, locale_t);
+
+wint_t towctrans_l(wint_t, wctrans_t, locale_t);
+
+wint_t nextwctype_l(wint_t, wctype_t, locale_t);
+
+wctrans_t wctrans_l(const char *, locale_t);
+
+inline int digittoint_l(int, locale_t);
+
+inline int tolower_l(int, locale_t);
+
+inline int toupper_l(int, locale_t);
+
+inline int _tolower_l(int, locale_t);
+
+inline int _toupper_l(int, locale_t);
+
+#endif /* defined(_CTYPE_H_) || defined(_WCTYPE_H) */
+
+
+#ifdef _STDIO_H_
+
+int	 asprintf_l(char **, locale_t, const char *, ...); /* __printflike(3, 4); */
+int	 dprintf_l(int, locale_t, const char * __restrict, ...);
+	    /* __printflike(3, 4); */
+int	 fprintf_l(FILE * __restrict, locale_t, const char * __restrict, ...);
+	    /*__printflike(3, 4); */
+int	 fscanf_l(FILE * __restrict, locale_t, const char * __restrict, ...);
+	    /*__scanflike(3, 4);*/
+int	 printf_l(locale_t, const char * __restrict, ...);
+		/* __printflike(2, 3); */
+int	 scanf_l(locale_t, const char * __restrict, ...);
+		/* __scanflike(2, 3); */
+int	 snprintf_l(char * __restrict, size_t, locale_t,
+	    const char * __restrict, ...); /* __printflike(4, 5); */
+int	 sprintf_l(char * __restrict, locale_t, const char * __restrict, ...);
+	    /* __printflike(3, 4); */
+int	 sscanf_l(const char * __restrict, locale_t, const char * __restrict,
+	    ...); /* __scanflike(3, 4); */
+int	 vfprintf_l(FILE * __restrict, locale_t, const char * __restrict,
+	    __va_list); /* __printflike(3, 0); */
+int	 vprintf_l(locale_t, const char * __restrict, __va_list);
+	    /*__printflike(2, 0); */
+int	 vsprintf_l(char * __restrict, locale_t, const char * __restrict,
+	    __va_list); /* __printflike(3, 0); */
+int	 vfscanf_l(FILE * __restrict, locale_t, const char * __restrict,
+	    __va_list); /* __scanflike(3, 0); */
+int	 vscanf_l(locale_t, const char * __restrict, __va_list);
+	    /*__scanflike(2, 0);*/
+int	 vsnprintf_l(char * __restrict, size_t, locale_t,
+	    const char * __restrict, __va_list); /* __printflike(4, 0); */
+int	 vsscanf_l(const char * __restrict, locale_t, const char * __restrict,
+	    __va_list); /* __scanflike(3, 0); */
+int	 vdprintf_l(int, locale_t, const char * __restrict, __va_list);
+	    /* __printflike(3, 0); */
+int	 vasprintf_l(char **, locale_t, const char *, __va_list);
+	    /* __printflike(3, 0); */
+#endif
+
+
+#ifdef _WCHAR_H_
+
+/* POSIX2008 */
+int			 wcscasecmp_l(const wchar_t *, const wchar_t *,
+			   locale_t);
+int			 wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t,
+			   locale_t);
+int			 wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
+size_t			 wcsxfrm_l(wchar_t * __restrict,
+			   const wchar_t * __restrict, size_t, locale_t);
+
+/* XLOCALE */
+wint_t			 btowc_l(int, locale_t);
+wint_t			 fgetwc_l(FILE *, locale_t);
+wchar_t			*fgetws_l(wchar_t * __restrict, int, FILE * __restrict,
+			    locale_t);
+wint_t			 fputwc_l(wchar_t, FILE *, locale_t);
+int			 fputws_l(const wchar_t * __restrict, FILE * __restrict,
+			   locale_t);
+int			 fwprintf_l(FILE * __restrict, locale_t,
+			    const wchar_t * __restrict, ...);
+int			 fwscanf_l(FILE * __restrict, locale_t,
+			    const wchar_t * __restrict, ...);
+wint_t			 getwc_l(FILE *, locale_t);
+wint_t			 getwchar_l(locale_t);
+size_t			 mbrlen_l(const char * __restrict, size_t,
+			   mbstate_t * __restrict, locale_t);
+size_t			 mbrtowc_l(wchar_t * __restrict,
+			    const char * __restrict, size_t,
+			    mbstate_t * __restrict, locale_t);
+int			 mbsinit_l(const mbstate_t *, locale_t);
+size_t			 mbsrtowcs_l(wchar_t * __restrict,
+			    const char ** __restrict, size_t,
+			    mbstate_t * __restrict, locale_t);
+wint_t			 putwc_l(wchar_t, FILE *, locale_t);
+wint_t			 putwchar_l(wchar_t, locale_t);
+int			 swprintf_l(wchar_t * __restrict, size_t n, locale_t,
+			    const wchar_t * __restrict, ...);
+int			 swscanf_l(const wchar_t * __restrict, locale_t,
+			   const wchar_t * __restrict, ...);
+wint_t			 ungetwc_l(wint_t, FILE *, locale_t);
+int			 vfwprintf_l(FILE * __restrict, locale_t,
+			    const wchar_t * __restrict, __va_list);
+int			 vswprintf_l(wchar_t * __restrict, size_t n, locale_t,
+			    const wchar_t * __restrict, __va_list);
+int			 vwprintf_l(locale_t, const wchar_t * __restrict,
+			    __va_list);
+size_t			 wcrtomb_l(char * __restrict, wchar_t,
+			    mbstate_t * __restrict, locale_t);
+size_t			 wcsftime_l(wchar_t * __restrict, size_t,
+			    const wchar_t * __restrict,
+			    const struct tm * __restrict, locale_t);
+size_t			 wcsrtombs_l(char * __restrict,
+			    const wchar_t ** __restrict, size_t,
+			    mbstate_t * __restrict, locale_t);
+double			 wcstod_l(const wchar_t * __restrict,
+			    wchar_t ** __restrict, locale_t);
+long			 wcstol_l(const wchar_t * __restrict,
+			    wchar_t ** __restrict, int, locale_t);
+unsigned long		 wcstoul_l(const wchar_t * __restrict,
+			    wchar_t ** __restrict, int, locale_t);
+int			 wcswidth_l(const wchar_t *, size_t, locale_t);
+int			 wctob_l(wint_t, locale_t);
+int			 wcwidth_l(wchar_t, locale_t);
+int			 wprintf_l(locale_t, const wchar_t * __restrict, ...);
+int			 wscanf_l(locale_t, const wchar_t * __restrict, ...);
+int			 vfwscanf_l(FILE * __restrict, locale_t,
+			    const wchar_t * __restrict, __va_list);
+int			 vswscanf_l(const wchar_t * __restrict, locale_t,
+			    const wchar_t *__restrict, __va_list);
+int			 vwscanf_l(locale_t, const wchar_t * __restrict,
+			    __va_list);
+float			 wcstof_l(const wchar_t * __restrict,
+			    wchar_t ** __restrict, locale_t);
+long double		 wcstold_l(const wchar_t * __restrict,
+			    wchar_t ** __restrict, locale_t);
+long long		 wcstoll_l(const wchar_t * __restrict,
+			    wchar_t ** __restrict, int, locale_t);
+unsigned long long	 wcstoull_l(const wchar_t * __restrict,
+			    wchar_t ** __restrict, int, locale_t);
+size_t			 mbsnrtowcs_l(wchar_t * __restrict,
+			    const char ** __restrict, size_t, size_t,
+			    mbstate_t * __restrict, locale_t);
+size_t			 wcsnrtombs_l(char * __restrict,
+			    const wchar_t ** __restrict, size_t, size_t,
+			    mbstate_t * __restrict, locale_t);
+
+#endif /* _WCHAR_H */
+
+
+
+__BEGIN_DECLS
+struct lconv	*localeconv_l(locale_t);
+__END_DECLS
+
+#endif
