--- src53xlocale1/lib/libc/gen/isctype.c	Mon Aug  8 03:05:34 2005
+++ src/lib/libc/gen/isctype.c	Mon Apr  8 18:33:50 2013
@@ -32,11 +32,42 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
+/**
+ * Public domain according to Colombian Legislation. 
+ * http://www.pasosdejesus.org/dominio_publico_colombia.html
+ * 2013. vtamara@pasosdeJesus.org
+ *
+ * $adJ$
+ */
 
+
 #define _ANSI_LIBRARY
 #include <ctype.h>
 #include <stdio.h>
+#include <xlocale.h>
 
+#include "../locale/mblocal.h"
+#include "../locale/rune.h"
+#include "../locale/runetype.h"
+#include "../locale/xlocale_private.h"
+
+__inline int
+__sbmaskrune_l(rune_t __c, unsigned long __f, locale_t __loc)
+{
+	int __limit;
+	FIX_LOCALE(__loc);
+	struct xlocale_ctype *ct = XLOCALE_CTYPE(__loc);
+	_RuneLocale *runes = ct->runes;
+	return (__c < 0 || __c >= ct->__mb_sb_limit) ? 0 :
+		runes->rl_runetype[__c] & __f;
+}
+
+__inline int
+__sbistype_l(rune_t __c, unsigned long __f, locale_t __loc)
+{
+	return (!!__sbmaskrune_l(__c, __f, __loc));
+}
+
 #undef isalnum
 int
 isalnum(int c)
@@ -45,6 +76,12 @@
 }
 DEF_STRONG(isalnum);
 
+__inline int isalnum_l(int __c, locale_t __l)
+{
+	return __sbistype_l(__c, _CTYPE_A|_CTYPE_D, __l);
+}
+DEF_STRONG(isalnum_l);
+
 #undef isalpha
 int
 isalpha(int c)
@@ -53,6 +90,12 @@
 }
 DEF_STRONG(isalpha);
 
+__inline int isalpha_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_A, __l); 
+}
+DEF_STRONG(isalpha_l);
+
 #undef isblank
 int
 isblank(int c)
@@ -61,6 +104,12 @@
 }
 DEF_STRONG(isblank);
 
+__inline int isblank_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_B, __l); 
+}
+DEF_STRONG(isblank_l);
+
 #undef iscntrl
 int
 iscntrl(int c)
@@ -69,6 +118,13 @@
 }
 DEF_STRONG(iscntrl);
 
+__inline int iscntrl_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_C, __l);
+}
+DEF_STRONG(iscntrl_l);
+
+
 #undef isdigit
 int
 isdigit(int c)
@@ -77,6 +133,12 @@
 }
 DEF_STRONG(isdigit);
 
+__inline int isdigit_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_D, __l); 
+}
+DEF_STRONG(isdigit_l);
+
 #undef isgraph
 int
 isgraph(int c)
@@ -85,6 +147,25 @@
 }
 DEF_STRONG(isgraph);
 
+__inline int isgraph_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_G, __l); 
+}
+DEF_STRONG(isgraph_l);
+
+__inline int ishexnumber_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_X, __l); 
+}
+DEF_WEAK(isgraph_l);
+
+__inline int isideogram_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_I, __l);
+}
+DEF_WEAK(isideogram_l);
+
+
 #undef islower
 int
 islower(int c)
@@ -93,6 +174,24 @@
 }
 DEF_STRONG(islower);
 
+__inline int islower_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_L, __l);
+}
+DEF_STRONG(islower_l);
+
+__inline int isnumber_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_D, __l);
+}
+DEF_STRONG(isnumber_l);
+
+__inline int isphonogram_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_Q, __l);
+}
+DEF_WEAK(isphonogram_l);
+
 #undef isprint
 int
 isprint(int c)
@@ -101,6 +200,13 @@
 }
 DEF_STRONG(isprint);
 
+__inline int isprint_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_R, __l);
+}
+DEF_STRONG(isprint_l);
+
+
 #undef ispunct
 int
 ispunct(int c)
@@ -109,6 +215,19 @@
 }
 DEF_STRONG(ispunct);
 
+__inline int ispunct_l(int __c, locale_t __l)
+{ 
+	return __sbistype_l(__c, _CTYPE_P, __l);
+}
+DEF_STRONG(ispunct_l);
+
+__inline int isrune_l(int __c, locale_t __l) 
+{
+	return __sbistype_l(__c, 0xFFFFFF00L, __l);
+}
+DEF_WEAK(isrune_l);
+
+
 #undef isspace
 int
 isspace(int c)
@@ -117,6 +236,18 @@
 }
 DEF_STRONG(isspace);
 
+__inline int isspace_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_S, __l);
+}
+DEF_STRONG(isspace_l);
+
+__inline int isspecial_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_T, __l);
+}
+DEF_STRONG(isspecial_l);
+
 #undef isupper
 int
 isupper(int c)
@@ -125,6 +256,12 @@
 }
 DEF_STRONG(isupper);
 
+__inline int isupper_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_U, __l);
+}
+DEF_STRONG(isupper_l);
+
 #undef isxdigit
 int
 isxdigit(int c)
@@ -133,7 +270,12 @@
 }
 DEF_STRONG(isxdigit);
 
-#undef isascii
+__inline int isxdigit_l(int __c, locale_t __l) 
+{ 
+	return __sbistype_l(__c, _CTYPE_X, __l); 
+}
+DEF_STRONG(isxdigit_l);
+
 int
 isascii(int c)
 {
@@ -161,3 +303,9 @@
 {
 	return (c - 'A' + 'a');
 }
+
+__inline int digittoint_l(int __c, locale_t __l)
+{ 
+	return __sbmaskrune_l((__c), 0xFF, __l); 
+}
+DEF_STRONG(digittoint_l);
diff -ruN -x .#* -x *patch -x obj -x CVS -x *~ -x *.orig -x *.rej src53xlocale1/lib/libc/gen/tolower_.c src/lib/libc/gen/tolower_.c
--- src53xlocale1/lib/libc/gen/tolower_.c	Mon Aug  8 03:05:34 2005
+++ src/lib/libc/gen/tolower_.c	Thu Apr  4 10:46:17 2013
@@ -7,7 +7,11 @@
 #define _ANSI_LIBRARY
 #include <ctype.h>
 #include <stdio.h>
+
 #include "ctype_private.h"
+#include "../locale/mblocal.h"
+#include "../locale/runetype.h"
+#include "../locale/xlocale_private.h"
 
 const short _C_tolower_[1 + CTYPE_NUM_CHARS] = {
 	EOF,
@@ -59,3 +63,15 @@
 	return((_tolower_tab_ + 1)[c]);
 }
 DEF_STRONG(tolower);
+
+
+__inline int tolower_l(int __c, locale_t __l)
+{
+	FIX_LOCALE(__l);
+	struct xlocale_ctype *__ct = XLOCALE_CTYPE(__l);
+	_RuneLocale *__runes = __ct->runes;
+
+	return (__c < 0 || __c >= __ct->__mb_sb_limit) ? __c :
+		__runes->rl_maplower[__c];
+}
+DEF_STRONG(tolower_l);
diff -ruN -x .#* -x *patch -x obj -x CVS -x *~ -x *.orig -x *.rej src53xlocale1/lib/libc/gen/toupper_.c src/lib/libc/gen/toupper_.c
--- src53xlocale1/lib/libc/gen/toupper_.c	Tue Aug  9 03:36:48 2005
+++ src/lib/libc/gen/toupper_.c	Thu Apr  4 10:46:39 2013
@@ -9,7 +9,11 @@
 #include <stdio.h>
 
 #include "ctype_private.h"
+#include "../locale/mblocal.h"
+#include "../locale/runetype.h"
+#include "../locale/xlocale_private.h"
 
+
 const short _C_toupper_[1 + CTYPE_NUM_CHARS] = {
 	EOF,
 	0x00,	0x01,	0x02,	0x03,	0x04,	0x05,	0x06,	0x07,
@@ -60,3 +64,14 @@
 	return((_toupper_tab_ + 1)[c]);
 }
 DEF_STRONG(toupper);
+
+__inline int toupper_l(int __c, locale_t __l)
+{
+	FIX_LOCALE(__l);
+	struct xlocale_ctype *__ct = XLOCALE_CTYPE(__l);
+	_RuneLocale *__runes = __ct->runes;
+
+	return (__c < 0 || __c >= __ct->__mb_sb_limit) ? __c :
+		__runes->rl_mapupper[__c];
+}
+DEF_STRONG(toupper_l);
diff -ruN -x .#* -x *patch -x obj -x CVS -x *~ -x *.orig -x *.rej src54-x4/lib/libc/gen/toupper_.c src/lib/libc/gen/toupper_.c
--- src54-x4/lib/libc/locale/Makefile.inc	Thu Dec  5 19:12:05 2013
+++ src/lib/libc/locale/Makefile.inc	Thu Dec  5 19:17:22 2013
@@ -10,7 +10,7 @@
 	wcstoul.c wcstoll.c wcstoull.c wcstoimax.c wcstoumax.c \
 	setrunelocale.c runeglue.c rune.c runetable.c ___runetype_mb.c \
 	_wctrans.c wcsxfrm.c loadtextcat.c collate.c \
-	fix_grouping.c none.c xlocale.c
+	fix_grouping.c none.c xlocale.c nextwctype.c
 
 MAN+=	nl_langinfo.3 setlocale.3 iswalnum.3 towlower.3 \
 	btowc.3 mblen.3 mbrlen.3 mbrtowc.3 mbsinit.3 mbsrtowcs.3 \
diff -ruN -x .#* -x *patch -x obj -x CVS -x *~ -x *.orig -x *.rej src53xlocale1/lib/libc/locale/___runetype_mb.c src/lib/libc/locale/___runetype_mb.c
--- src53xlocale1/lib/libc/locale/___runetype_mb.c	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/___runetype_mb.c	Thu Apr  4 09:52:18 2013
@@ -34,11 +34,14 @@
  */
 
 #include <wctype.h>
+
+#include "mblocal.h"
 #include "rune.h"
 #include "rune_local.h"
+#include "xlocale_private.h"
 
 _RuneType
-___runetype_mb(wint_t c)
+___runetype_mb_l(wint_t c, locale_t l)
 {
 	rune_t c0;
 	uint32_t x;
@@ -49,7 +52,11 @@
 		return (0U);
 
 	c0 = (rune_t)c; /* XXX assumes wint_t = int */
-	rr = &_CurrentRuneLocale->rl_runetype_ext;
+	FIX_LOCALE(l);
+		
+	_RuneLocale *runes = XLOCALE_CTYPE(l)->runes;
+	rr = &(runes->rl_runetype_ext);
+
 	base = rr->rr_rune_ranges;
 	for (x = rr->rr_nranges; x; x >>= 1) {
 		re = base + (x >> 1);
@@ -66,3 +73,10 @@
 
 	return (0U);
 }
+
+_RuneType
+___runetype_mb(wint_t c)
+{
+	return ___runetype_mb_l(c, __get_locale());
+}
+
diff -ruN -x obj -x CVS -x *~ -x *orig -x *rej src53xlocale1/lib/libc/locale/ctype_l.3 src/lib/libc/locale/ctype_l.3
--- src53xlocale1/lib/libc/locale/ctype_l.3	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/ctype_l.3	Mon Apr  8 14:00:01 2013
@@ -0,0 +1,141 @@
+.\" Copyright (c) 2011 The FreeBSD Foundation
+.\" All rights reserved.
+.\"
+.\" This documentation was written by David Chisnall under sponsorship from
+.\" the FreeBSD Foundation.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD$
+.\"
+.Dd January 29, 2013
+.Dt CTYPE_L 3
+.Os
+.Sh NAME
+.Nm digittoint_l ,
+.Nm isalnum_l ,
+.Nm isalpha_l ,
+.Nm isascii_l ,
+.Nm isblank_l ,
+.Nm iscntrl_l ,
+.Nm isdigit_l ,
+.Nm isgraph_l ,
+.Nm ishexnumber_l ,
+.Nm isideogram_l ,
+.Nm islower_l ,
+.Nm isnumber_l ,
+.Nm isphonogram_l ,
+.Nm isprint_l ,
+.Nm ispunct_l ,
+.Nm isrune_l ,
+.Nm isspace_l ,
+.Nm isspecial_l ,
+.Nm isupper_l ,
+.Nm isxdigit_l 
+.Nd character classification functions
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.In ctype.h
+.Ft int
+.Fn digittoint_l "int c" "locale_t loc"
+.Ft int
+.Fn isalnum_l "int c" "locale_t loc"
+.Ft int
+.Fn isalpha_l "int c" "locale_t loc"
+.Ft int
+.Fn isascii_l "int c" "locale_t loc"
+.Ft int
+.Fn iscntrl_l "int c" "locale_t loc"
+.Ft int
+.Fn isdigit_l "int c" "locale_t loc"
+.Ft int
+.Fn isgraph_l "int c" "locale_t loc"
+.Ft int
+.Fn ishexnumber_l "int c" "locale_t loc"
+.Ft int
+.Fn isideogram_l "int c" "locale_t loc"
+.Ft int
+.Fn islower_l "int c" "locale_t loc"
+.Ft int
+.Fn isnumber_l "int c" "locale_t loc"
+.Ft int
+.Fn isphonogram_l "int c" "locale_t loc"
+.Ft int
+.Fn isspecial_l "int c" "locale_t loc"
+.Ft int
+.Fn isprint_l "int c" "locale_t loc"
+.Ft int
+.Fn ispunct_l "int c" "locale_t loc"
+.Ft int
+.Fn isrune_l "int c" "locale_t loc"
+.Ft int
+.Fn isspace_l "int c" "locale_t loc"
+.Ft int
+.Fn isupper_l "int c" "locale_t loc"
+.Ft int
+.Fn isxdigit_l "int c" "locale_t loc"
+.Sh DESCRIPTION
+The above functions perform character tests and conversions on the integer
+.Fa c
+in the locale
+.Fa loc .
+They behave in the same way as the versions without the _l suffix, but use the
+specified locale rather than the global locale.
+See the specific manual pages for more information.
+.Sh SEE ALSO
+.Xr digittoint 3 ,
+.Xr isalnum 3 ,
+.Xr isalpha 3 ,
+.Xr isascii 3 ,
+.Xr isblank 3 ,
+.Xr iscntrl 3 ,
+.Xr isdigit 3 ,
+.Xr isgraph 3 ,
+.Xr isideogram 3 ,
+.Xr islower 3 ,
+.Xr isphonogram 3 ,
+.Xr isprint 3 ,
+.Xr ispunct 3 ,
+.Xr isrune 3 ,
+.Xr isspace 3 ,
+.Xr isspecial 3 ,
+.Xr isupper 3 ,
+.Xr isxdigit 3 ,
+.Xr wctype 3 ,
+.Xr xlocale 3
+.Sh STANDARDS
+These functions conform to
+.St -p1003.1-2008 ,
+except for
+.Fn digittoint_l ,
+.Fn isascii_l ,
+.Fn ishexnumber_l ,
+.Fn isideogram_l ,
+.Fn isnumber_l ,
+.Fn isphonogram_l ,
+.Fn isrune_l
+and
+.Fn isspecial_l
+which are
+.Fx
+extensions.
diff -ruN -x obj -x CVS -x *~ -x *orig -x *rej src53xlocale1/lib/libc/locale/iswalnum_l.3 src/lib/libc/locale/iswalnum_l.3
--- src53xlocale1/lib/libc/locale/iswalnum_l.3	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/iswalnum_l.3	Mon Apr  8 14:00:18 2013
@@ -0,0 +1,160 @@
+.\" Copyright (c) 2012 Isabell Long <issyl0@FreeBSD.org>
+.\" All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD$
+.\"
+.Dd July 25, 2012
+.Dt ISWALNUM_L 3
+.Os
+.Sh NAME
+.Nm iswalnum_l ,
+.Nm iswalpha_l ,
+.Nm iswcntrl_l ,
+.Nm iswctype_l ,
+.Nm iswdigit_l ,
+.Nm iswgraph_l ,
+.Nm iswlower_l ,
+.Nm iswprint_l ,
+.Nm iswpunct_l ,
+.Nm iswspace_l ,
+.Nm iswupper_l ,
+.Nm iswxdigit_l ,
+.Nm wctype_l ,
+.Nm iswblank_l ,
+.Nm iswhexnumber_l ,
+.Nm iswideogram_l ,
+.Nm iswnumber_l ,
+.Nm iswphonogram_l ,
+.Nm iswrune_l ,
+.Nm iswspecial_l ,
+.Nm nextwctype_l ,
+.Nm towctrans_l ,
+.Nm wctrans_l
+.Nd wide character classification utilities
+.Sh LIBRARY
+.Lb libc
+.Sh SYNOPSIS
+.In wctype.h
+.Ft int
+.Fn iswalnum_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswalpha_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswcntrl_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswctype_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswdigit_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswgraph_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswlower_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswprint_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswpunct_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswspace_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswupper_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswxdigit_l "wint_t wc" "locale_t loc"
+.Ft wctype_t
+.Fn wctype_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswblank_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswhexnumber_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswideogram_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswnumber_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswphonogram_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswrune_l "wint_t wc" "locale_t loc"
+.Ft int
+.Fn iswspecial_l "wint_t wc" "locale_t loc"
+.Ft wint_t
+.Fn nextwctype_l "wint_t wc" "locale_t loc"
+.Ft wint_t
+.Fn towctrans_l "wint_t wc" "wctrans_t" "locale_t loc"
+.Ft wctrans_t
+.Fn wctrans_l "const char *" "locale_t loc"
+.Sh DESCRIPTION
+The above functions are character classification utility functions,
+for use with wide characters
+.Vt ( wchar_t
+or
+.Vt wint_t )
+in the locale
+.Fa loc .
+They behave in the same way as the versions without the _l suffix, but use
+the specified locale rather than the global or per-thread locale.
+These functions may be implemented as inline functions in
+.In wctype.h
+and as functions in the C library.
+See the specific manual pages for more information.
+.Sh RETURN VALUES
+These functions return the same things as their non-locale versions.
+If the locale is invalid, their behaviors are undefined.
+.Sh SEE ALSO
+.Xr iswalnum 3 ,
+.Xr iswalpha 3 ,
+.Xr iswblank 3 ,
+.Xr iswcntrl 3 ,
+.Xr iswctype 3 ,
+.Xr iswdigit 3 ,
+.Xr iswgraph 3 ,
+.Xr iswhexnumber 3 ,
+.Xr iswideogram 3 ,
+.Xr iswlower 3 ,
+.Xr iswnumber 3 ,
+.Xr iswphonogram 3 ,
+.Xr iswprint 3 ,
+.Xr iswpunct 3 ,
+.Xr iswrune 3 ,
+.Xr iswspace 3 ,
+.Xr iswspecial 3 ,
+.Xr iswupper 3 ,
+.Xr iswxdigit 3 ,
+.Xr nextwctype 3 ,
+.Xr towctrans 3 ,
+.Xr wctrans 3 ,
+.Xr wctype 3
+.Sh STANDARDS
+These functions conform to
+.St -p1003.1-2008 ,
+except for
+.Fn iswascii_l ,
+.Fn iswhexnumber_l ,
+.Fn iswideogram_l ,
+.Fn iswphonogram_l ,
+.Fn iswrune_l ,
+.Fn iswspecial_l
+and
+.Fn nextwctype_l
+which are
+.Fx
+extensions.
diff -ruN src59-orig/lib/libc/locale/iswctype.c src/lib/libc/locale/iswctype.c
--- src59-orig/lib/libc/locale/iswctype.c	Sun Sep 13 06:38:08 2015
+++ src/lib/libc/locale/iswctype.c	Sat May 14 06:17:15 2016
@@ -34,22 +34,34 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
+/**
+ * Public domain according to Colombian Legislation.
+ * http://www.pasosdejesus.org/dominio_publico_colombia.html
+ * 2013. vtamara@pasosdeJesus.org
+ *
+ * $adJ$
+ */
 
 #include <wchar.h>
 #include <wctype.h>
 #include <ctype.h>
 #include <errno.h>
 #include <string.h>
+
+#include "mblocal.h"
 #include "rune.h"
 #include "runetype.h"
 #include "rune_local.h"
 #include "_wctrans_local.h"
+#include "xlocale_private.h"
 
 static inline _RuneType __runetype_w(wint_t);
 static inline int __isctype_w(wint_t, _RuneType);
 static inline wint_t __toupper_w(wint_t);
 static inline wint_t __tolower_w(wint_t);
 
+int iswspace_l(wint_t, locale_t); 
+
 static inline _RuneType
 __runetype_w(wint_t c)
 {
@@ -59,12 +71,29 @@
 		rl->rl_runetype[c] : ___runetype_mb(c));
 }
 
+
+static inline _RuneType
+__runetype_w_l(wint_t c, locale_t l)
+{
+	FIX_LOCALE(l);
+	_RuneLocale *rl = XLOCALE_CTYPE(l)->runes;
+
+	return (_RUNE_ISCACHED(c) ?          
+	    rl->rl_runetype[c] : ___runetype_mb_l(c, l));
+}
+
 static inline int
 __isctype_w(wint_t c, _RuneType f)
 {
 	return (!!(__runetype_w(c) & f));
 }
 
+static inline int
+__isctype_w_l(rune_t __c, unsigned long __f, locale_t __loc)
+{
+	return (!!(__runetype_w_l(__c, __loc) & __f));
+}
+
 static inline wint_t
 __toupper_w(wint_t c)
 {
@@ -72,23 +101,53 @@
 }
 
 static inline wint_t
+__toupper_w_l(wint_t c, locale_t l)
+{
+	FIX_LOCALE(l);
+	_RuneLocale *_runes = XLOCALE_CTYPE(l)->runes;
+	return (_towctrans(c, _wctrans_upper(_runes)));
+}
+
+static inline wint_t
 __tolower_w(wint_t c)
 {
 	return (_towctrans(c, _wctrans_lower(_CurrentRuneLocale)));
 }
 
+
+static inline wint_t
+__tolower_w_l(wint_t c, locale_t l)
+{
+	FIX_LOCALE(l);
+	_RuneLocale *_runes = XLOCALE_CTYPE(l)->runes;
+	return (_towctrans(c, _wctrans_lower(_runes)));
+}
+
 int
 iswalnum(wint_t c)
 {
 	return (__isctype_w((c), _CTYPE_A|_CTYPE_D));
 }
 
+int 
+iswalnum_l(wint_t __c, locale_t __l)
+{
+	return __isctype_w_l(__c, _CTYPE_A|_CTYPE_D, __l);
+}
+
 int
 iswalpha(wint_t c)
 {
 	return (__isctype_w((c), _CTYPE_A));
 }
 
+
+int 
+iswalpha_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_A, __l); 
+}
+
 int
 iswblank(wint_t c)
 {
@@ -96,41 +155,112 @@
 }
 
 int
+iswblank_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_B, __l); 
+}
+
+int
 iswcntrl(wint_t c)
 {
 	return (__isctype_w((c), _CTYPE_C));
 }
 
+int 
+iswcntrl_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_C, __l);
+}
+
 int
 iswdigit(wint_t c)
 {
 	return (__isctype_w((c), _CTYPE_D));
 }
 
+int 
+iswdigit_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_D, __l); 
+}
+
 int
 iswgraph(wint_t c)
 {
 	return (__isctype_w((c), _CTYPE_G));
 }
 
+int 
+iswgraph_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_G, __l); 
+}
+
+int 
+iswhexnumber_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_X, __l); 
+}
+
+int 
+iswideogram_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_I, __l);
+}
+
 int
 iswlower(wint_t c)
 {
 	return (__isctype_w((c), _CTYPE_L));
 }
 
+int 
+iswlower_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_L, __l);
+}
+
+int 
+iswnumber_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_D, __l);
+}
+
+int 
+iswphonogram_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_Q, __l);
+}
+
 int
 iswprint(wint_t c)
 {
 	return (__isctype_w((c), _CTYPE_R));
 }
 
+int 
+iswprint_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_R, __l);
+}
+
 int
 iswpunct(wint_t c)
 {
 	return (__isctype_w((c), _CTYPE_P));
 }
 
+int iswpunct_l(wint_t __c, locale_t __l)
+{ 
+	return __isctype_w_l(__c, _CTYPE_P, __l);
+}
+ 
+int 
+iswrune_l(wint_t __c, locale_t __l) 
+{
+	return __isctype_w_l(__c, 0xFFFFFF00L, __l);
+}
+
 int
 iswspace(wint_t c)
 {
@@ -138,6 +268,19 @@
 }
 DEF_STRONG(iswspace);
 
+int 
+iswspace_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_S, __l);
+}
+DEF_STRONG(iswspace_l);
+
+int 
+iswspecial_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_T, __l);
+}
+
 int
 iswupper(wint_t c)
 {
@@ -145,18 +288,37 @@
 }
 DEF_STRONG(iswupper);
 
+int 
+iswupper_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_U, __l);
+}
+DEF_STRONG(iswupper_l);
+
 int
 iswxdigit(wint_t c)
 {
 	return (__isctype_w((c), _CTYPE_X));
 }
 
+int 
+iswxdigit_l(wint_t __c, locale_t __l) 
+{ 
+	return __isctype_w_l(__c, _CTYPE_X, __l); 
+}
+
 wint_t
 towupper(wint_t c)
 {
 	return (__toupper_w(c));
 }
 
+__inline wint_t
+towupper_l(wint_t __c, locale_t __l)
+{
+	return (__toupper_w_l(__c, __l));
+}
+
 wint_t
 towlower(wint_t c)
 {
@@ -164,6 +326,13 @@
 }
 DEF_STRONG(towlower);
 
+wint_t
+towlower_l(wint_t __c, locale_t __l)
+{
+	return (__tolower_w_l(__c, __l));
+}
+DEF_STRONG(towlower_l);
+
 int
 wcwidth(wchar_t c)
 {
@@ -171,8 +340,17 @@
 		return (((unsigned)__runetype_w(c) & _CTYPE_SWM) >> _CTYPE_SWS);
 	return -1;
 }
-DEF_WEAK(wcwidth);
+DEF_STRONG(wcwidth);
 
+int wcwidth_l(wchar_t c, locale_t __l)
+{
+	if (__isctype_w_l((c), _CTYPE_R, __l))
+		return (((unsigned)__runetype_w_l(c, __l) & _CTYPE_SWM) 
+				>> _CTYPE_SWS);
+	return -1;
+}
+DEF_WEAK(wcwidth_l);
+
 wctrans_t
 wctrans(const char *charclass)
 {
@@ -189,6 +367,23 @@
 	return ((wctrans_t)NULL);
 }
 
+wctrans_t
+wctrans_l(const char *charclass, locale_t l)
+{
+	int i;
+	FIX_LOCALE(l);
+	_RuneLocale *rl = XLOCALE_CTYPE(l)->runes;
+
+	if (rl->rl_wctrans[_WCTRANS_INDEX_LOWER].te_name==NULL)
+		_wctrans_init(rl);
+
+	for (i=0; i<_WCTRANS_NINDEXES; i++)
+		if (!strcmp(rl->rl_wctrans[i].te_name, charclass))
+			return ((wctrans_t)&rl->rl_wctrans[i]);
+
+	return ((wctrans_t)NULL);
+}
+
 wint_t
 towctrans(wint_t c, wctrans_t desc)
 {
@@ -199,6 +394,22 @@
 	return (_towctrans(c, (_WCTransEntry *)desc));
 }
 
+wint_t
+towctrans_l(wint_t wc, wctrans_t desc, locale_t locale)
+{
+	FIX_LOCALE(locale);
+	int i;
+	if (desc==NULL) {
+		errno = EINVAL;
+		return (wc);
+	}
+	/* Supposing that desc was obtained from locale with wctrans_l,
+	 * as stated in 
+	 * http://pubs.opengroup.org/onlinepubs/9699919799/functions/towctrans.html */
+	return (_towctrans(wc, (_WCTransEntry *)desc));
+}
+
+
 wctype_t
 wctype(const char *property)
 {
@@ -211,6 +422,20 @@
 	return ((wctype_t)NULL);
 }
 
+wctype_t
+wctype_l(const char *property, locale_t l)
+{
+	int i;
+	FIX_LOCALE(l);
+	_RuneLocale *rl = XLOCALE_CTYPE(l)->runes;
+
+	for (i=0; i<_WCTYPE_NINDEXES; i++)
+		if (!strcmp(rl->rl_wctype[i].te_name, property))
+			return ((wctype_t)&rl->rl_wctype[i]);
+	return ((wctype_t)NULL);
+}
+
+
 int
 iswctype(wint_t c, wctype_t charclass)
 {
@@ -224,3 +449,10 @@
 
 	return (__isctype_w(c, ((_WCTypeEntry *)charclass)->te_mask));
 }
+
+__inline int
+iswctype_l(wint_t wc, wctype_t charclass, locale_t locale)
+{
+	return __isctype_w_l(wc, ((_WCTypeEntry *)charclass)->te_mask, locale);
+}
+
diff -ruN -x .#* -x *patch -x obj -x CVS -x *~ -x *.orig -x *.rej src53xlocale1/lib/libc/locale/nextwctype.3 src/lib/libc/locale/nextwctype.3
--- src53xlocale1/lib/libc/locale/nextwctype.3	Tue Apr  2 06:11:30 2013
+++ src/lib/libc/locale/nextwctype.3	Thu Apr  4 17:37:32 2013
@@ -25,11 +25,12 @@
 .\"
 .\" From FreeBSD
 .\"
-.Dd July 21, 2005
+.Dd April 4, 2013
 .Dt NEXTWCTYPE 3
 .Os
 .Sh NAME
-.Nm nextwctype
+.Nm nextwctype ,
+.Nm nextwctype_l
 .Nd "iterate through character classes"
 .Sh LIBRARY
 .Lb libc
@@ -37,10 +38,14 @@
 .In wctype.h
 .Ft wint_t
 .Fn nextwctype "wint_t ch" "wctype_t wct"
+.Ft wint_t
+.Fn nextwctype_l "wint_t ch" "wctype_t wct" "locale_t l"
 .Sh DESCRIPTION
 The
 .Fn nextwctype
-function determines the next character after
+and
+.Fn nextwctype_l
+functions determine the next character after
 .Fa ch
 that is a member of character class
 .Fa wct .
@@ -48,6 +53,13 @@
 .Fa ch
 is \-1, the search begins at the first member of
 .Fa wct .
+.Pp
+The function
+.Fn nextwctype
+uses the current locale, while the function
+.Fn nextwctype_l
+uses the locale provided as parameter, see
+.Xr xlocale 3
 .Sh RETURN VALUES
 The
 .Fn nextwctype
@@ -60,6 +72,7 @@
 function would suffice.
 .Sh SEE ALSO
 .Xr wctype 3
+.Xr xlocale 3
 .Sh HISTORY
 The
 .Fn nextwctype
diff -ruN -x .#* -x *patch -x obj -x CVS -x *~ -x *.orig -x *.rej src53xlocale1/lib/libc/locale/nextwctype.c src/lib/libc/locale/nextwctype.c
--- src53xlocale1/lib/libc/locale/nextwctype.c	Wed Dec 31 19:00:00 1969
+++ src/lib/libc/locale/nextwctype.c	Thu Apr  4 17:32:11 2013
@@ -0,0 +1,112 @@
+/*-
+ * Copyright (c) 2004 Tim J. Robbins.
+ * All rights reserved.
+ *
+ * Copyright (c) 2011 The FreeBSD Foundation
+ * All rights reserved.
+ * Portions of this software were developed by David Chisnall
+ * under sponsorship from the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+
+#include <wchar.h>
+#include <wctype.h>
+#include <errno.h>
+
+#include "locale/xlocale_private.h"
+#include "mblocal.h"
+#include "runetype.h"
+
+wint_t
+nextwctype_l(wint_t wc, wctype_t wct, locale_t locale)
+{
+	if (wct == NULL) {
+		errno = EINVAL; 
+		return -1;
+	}
+	unsigned long wctm = ((_WCTypeEntry *)wct)->te_mask;
+	size_t lim;
+	FIX_LOCALE(locale);
+	_RuneLocale *runes = XLOCALE_CTYPE(locale)->runes;
+	_RuneRange *rr = &(runes->rl_runetype_ext);
+	_RuneEntry *base, *re;
+	int noinc;
+
+	noinc = 0;
+	if (wc < _CACHED_RUNES) {
+		wc++;
+		while (wc < _CACHED_RUNES) {
+			if (runes->rl_wctype[wc].te_mask & wctm)
+				return (wc);
+			wc++;
+		}
+		wc--;
+	}
+	if (rr->rr_rune_ranges != NULL && wc < rr->rr_rune_ranges[0].re_min) {
+		wc = rr->rr_rune_ranges[0].re_min;
+		noinc = 1;
+	}
+
+	/* Binary search -- see bsearch.c for explanation. */
+	base = rr->rr_rune_ranges;
+	for (lim = rr->rr_nranges; lim != 0; lim >>= 1) {
+		re = base + (lim >> 1);
+		if (re->re_min <= wc && wc <= re->re_max)
+			goto found;
+		else if (wc > re->re_max) {
+			base = re + 1;
+			lim--;
+		}
+	}
+	return (-1);
+found:
+	if (!noinc)
+		wc++;
+	if (re->re_min <= wc && wc <= re->re_max) {
+		if (re->re_rune_types != NULL) {
+			for (; wc <= re->re_max; wc++)
+				if (re->re_rune_types[wc - re->re_min] & wctm)
+					return (wc);
+		} else if (re->re_map & wctm)
+			return (wc);
+	}
+	while (++re < rr->rr_rune_ranges + rr->rr_nranges) {
+		wc = re->re_min;
+		if (re->re_rune_types != NULL) {
+			for (; wc <= re->re_max; wc++)
+				if (re->re_rune_types[wc - re->re_min] & wctm)
+					return (wc);
+		} else if (re->re_map & wctm)
+			return (wc);
+	}
+	return (-1);
+}
+DEF_WEAK(nextwctype_l);
+
+wint_t
+nextwctype(wint_t wc, wctype_t wct)
+{
+	return nextwctype_l(wc, wct, __get_locale());
+}
diff -ruN -x .#* -x *patch -x obj -x CVS -x *~ -x *.orig -x *.rej src53xlocale1/lib/libc/string/wcswidth.c src/lib/libc/string/wcswidth.c
--- src53xlocale1/lib/libc/string/wcswidth.c	Wed Apr  3 12:10:19 2013
+++ src/lib/libc/string/wcswidth.c	Thu Apr  4 17:24:33 2013
@@ -31,14 +31,16 @@
 
 #include <wchar.h>
 
+#include "../locale/xlocale_private.h"
+
 int
-wcswidth(const wchar_t *s, size_t n)
+wcswidth_l(const wchar_t *s, size_t n, locale_t l)
 {
 	int w, q;
 
 	w = 0;
 	while (n && *s) {
-		q = wcwidth(*s);
+		q = wcwidth_l(*s, l);
 		if (q == -1)
 			return (-1);
 		w += q;
@@ -48,4 +50,11 @@
 
 	return w;
 }
-DEF_WEAK(wcswidth);
+DEF_WEAK(wcswidth_l);
+
+int
+wcswidth(const wchar_t *s, size_t n)
+{
+	return wcswidth_l(s, n, __get_locale());
+}
+DEF_STRONG(wcswidth);
diff -ruN -x *.o -x obj -x CVS -x *~ src53xlocale2/regress/lib/libc/locale/check_xlocale/check_xlocale.c src/regress/lib/libc/locale/check_xlocale/check_xlocale.c
--- src53xlocale2/regress/lib/libc/locale/check_xlocale/check_xlocale.c	Mon Apr  8 21:20:56 2013
+++ src/regress/lib/libc/locale/check_xlocale/check_xlocale.c	Tue Apr  9 05:20:20 2013
@@ -147,10 +147,147 @@
 
 }
 
+void test_ctype() {
+	char *nl = setlocale(LC_ALL, "es_CO.UTF-8");
+	locale_t tloc;
+	locale_t es_CO_UTF_8;
+	size_t s;
+	wchar_t ws[100];
+
+	printf("locale %s\n", nl);
+	tloc = uselocale(NULL);
+	es_CO_UTF_8 = duplocale(tloc);
+	
+	setlocale(LC_ALL, "POSIX");
+
+	p((s = mbstowcs_l(ws, "niño", 10, es_CO_UTF_8)) > 0 && 
+	    wcsncmp(ws, L"niño", 10) == 0);
+	p((s = wcswidth_l(ws, 10, es_CO_UTF_8)) == 4);
+	p((s = wcwidth_l(L'a', es_CO_UTF_8)) == 1);
+	p(wctype_l("lower", es_CO_UTF_8) > 0);
+	p(iswctype(L'a', wctype("lower")));
+	p(iswctype_l(L'á', wctype_l("lower", es_CO_UTF_8), es_CO_UTF_8));
+	p(iswctype_l(L'ñ', wctype_l("lower", es_CO_UTF_8), es_CO_UTF_8));
+	p(!iswctype_l(L'Ñ', wctype_l("lower", es_CO_UTF_8), es_CO_UTF_8));
+	p(isalnum_l('a', es_CO_UTF_8));
+	/* Something like: p(isalnum_l('á', es_CO_UTF_8));
+	 * would produce warning multi-character constant since it
+	 * is not portable and in OpenBSD will not suppose by default it is 
+	 * UTF-8.
+	 */
+	p(isalnum_l('1', es_CO_UTF_8));
+	p(iswalnum_l(L'ñ', es_CO_UTF_8));
+	p(iswalnum_l(L'1', es_CO_UTF_8));
+	p(!iswalnum_l(L' ', es_CO_UTF_8));
+	p(isalpha_l('a', es_CO_UTF_8));
+	p(!isalpha_l('1', es_CO_UTF_8));
+	p(iswalpha_l(L'ñ', es_CO_UTF_8));
+	p(!iswalpha_l(L'1', es_CO_UTF_8));
+	p(iscntrl_l('\n', es_CO_UTF_8));
+	p(!iscntrl_l(' ', es_CO_UTF_8));
+	p(iswcntrl(L'\n'));
+	p(iswcntrl_l(L'\n', es_CO_UTF_8));
+	p(!iswcntrl_l(L'n', es_CO_UTF_8));
+	p(isdigit_l('1', es_CO_UTF_8));
+	p(!isdigit_l(' ', es_CO_UTF_8));
+	p(iswdigit_l(L'1', es_CO_UTF_8));
+	p(!iswdigit_l(L'ñ', es_CO_UTF_8));
+	p(isgraph_l('a', es_CO_UTF_8));
+	p(!isgraph_l('\0', es_CO_UTF_8));
+	p(iswgraph_l(L'ñ', es_CO_UTF_8));
+	p(!iswgraph_l(L'\0', es_CO_UTF_8));
+	p(islower_l('a', es_CO_UTF_8));
+	p(!islower_l('A', es_CO_UTF_8));
+	p(iswlower_l(L'ñ', es_CO_UTF_8));
+	p(!iswlower_l(L'Ñ', es_CO_UTF_8));
+	p(iswprint_l(L'ñ', es_CO_UTF_8));
+	p(!iswprint_l(L'\0', es_CO_UTF_8));
+	p(ispunct_l('.', es_CO_UTF_8));
+	p(!ispunct_l(' ', es_CO_UTF_8));
+	p(iswpunct_l(L'.', es_CO_UTF_8));
+	p(iswpunct_l(L'.', es_CO_UTF_8));
+	p(!iswpunct_l(L'ñ', es_CO_UTF_8));
+	p(isspace_l(' ', es_CO_UTF_8));
+	p(!isspace_l('n', es_CO_UTF_8));
+	p(iswspace_l(L' ', es_CO_UTF_8));
+	p(!iswspace_l(L'ñ', es_CO_UTF_8));
+	p(isupper_l('N', es_CO_UTF_8));
+	p(!isupper_l('n', es_CO_UTF_8));
+	p(iswupper_l(L'Ñ', es_CO_UTF_8));
+	p(iswupper_l(L'Ñ', es_CO_UTF_8));
+	p(!iswupper_l(L'ñ', es_CO_UTF_8));
+	p(iswxdigit_l(L'a', es_CO_UTF_8));
+	p(iswxdigit_l(L'1', es_CO_UTF_8));
+	p(iswxdigit_l(L'f', es_CO_UTF_8));
+	p(!iswxdigit_l(L'g', es_CO_UTF_8));
+	p(isxdigit_l('f', es_CO_UTF_8));
+	p(!isxdigit_l('g', es_CO_UTF_8));
+	//p(digittoint_l(L'1', es_CO_UTF_8) == 1);
+	p(isblank_l(' ', es_CO_UTF_8));
+	p(!isblank_l('a', es_CO_UTF_8));
+	p(iswblank_l(L'\t', es_CO_UTF_8));
+	p(!iswblank_l(L'ñ', es_CO_UTF_8));
+	p(ishexnumber_l('a', es_CO_UTF_8));
+	p(!ishexnumber_l(' ', es_CO_UTF_8));
+	p(iswhexnumber_l(L'a', es_CO_UTF_8));
+	p(!iswhexnumber_l(L' ', es_CO_UTF_8));
+	p(!isideogram_l(' ', es_CO_UTF_8));
+	//p(iswideogram_l(0x3006, es_CO_UTF_8));
+	p(!iswideogram_l(L' ', es_CO_UTF_8));
+	p(isnumber_l('1', es_CO_UTF_8));
+	p(!isnumber_l(' ', es_CO_UTF_8));
+	p(iswnumber_l(L'1', es_CO_UTF_8));
+	p(!iswnumber_l(L' ', es_CO_UTF_8));
+	p(!isphonogram_l(' ', es_CO_UTF_8));
+	p(iswphonogram_l(0x0f00, es_CO_UTF_8));
+	p(!iswphonogram_l(L' ', es_CO_UTF_8));
+	p(isprint_l('1', es_CO_UTF_8));
+	p(!isprint_l('\0', es_CO_UTF_8));
+	p(isrune_l('1', es_CO_UTF_8));
+	p(!isrune_l(EOF, es_CO_UTF_8));
+	p(iswrune_l(L'1', es_CO_UTF_8));
+	p(!iswrune_l(WEOF, es_CO_UTF_8));
+	p(!isspecial_l('a', es_CO_UTF_8));
+	p(iswspecial_l(0x00b2, es_CO_UTF_8));
+	p(!iswspecial_l(L'\0', es_CO_UTF_8));
+	p(nextwctype(-1, wctype("graph")) > 0);
+	p(tolower_l('A', es_CO_UTF_8) == 'a');
+	p(tolower('A') == 'a');
+	p(_tolower('A') == 'a');
+	p(towlower_l(L'Á', es_CO_UTF_8) == L'á');
+	p(towupper_l(L'á', es_CO_UTF_8) == L'Á');
+	p(towupper(L'a') == L'A');
+	p(toupper_l('a', es_CO_UTF_8) == 'A');
+	p(toupper('a') == 'A');
+	p(_toupper('a') == 'A');
+	p(wctrans_l("invalido", es_CO_UTF_8) == 0);
+	wchar_t lu[7][2] = {{ L'ñ', L'Ñ'},
+		{L'á', L'Á'},
+		{L'é', L'É'},
+		{L'í', L'Í'},
+		{L'ó', L'Ó'},
+		{L'ú', L'Ú'},
+		{L'ü', L'Ü'}
+	};
+	wctrans_t tl;
+	p((tl = wctrans_l("tolower", es_CO_UTF_8)) != 0);
+	wctrans_t tu;
+	p((tu = wctrans_l("toupper", es_CO_UTF_8)) != 0);
+	int c;
+	for(c=0; c<7; c++) {
+		p(towctrans_l(lu[c][1], tl, es_CO_UTF_8) == lu[c][0]);
+		p(towlower_l(lu[c][1], es_CO_UTF_8) == lu[c][0]);
+		p(towctrans_l(lu[c][0], tu, es_CO_UTF_8) == lu[c][1]);
+		p(towupper_l(lu[c][0], es_CO_UTF_8) == lu[c][1]);
+	}
+
+}
+
 int main()
 {
 	test_xlocale();
 	test_wchar();
+	test_ctype();
 	
 	return bad != 0;
 }
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/gen/tolower.3 src53xlocale2/lib/libc/gen/tolower.3
--- src53xlocale1/lib/libc/gen/tolower.3	Fri Mar 22 08:37:38 2013
+++ src53xlocale2/lib/libc/gen/tolower.3	Fri Apr 12 11:46:27 2013
@@ -36,7 +36,9 @@
 .Os
 .Sh NAME
 .Nm tolower ,
-.Nm _tolower
+.Nm tolower_l ,
+.Nm _tolower ,
+.Nm _tolower_l
 .Nd upper case to lower case letter conversion
 .Sh SYNOPSIS
 .In ctype.h
@@ -44,27 +46,58 @@
 .Fn tolower "int c"
 .Ft int
 .Fn _tolower "int c"
+.In xlocale.h
+.Ft int
+.Fn tolower_l "int c" "locale_t l"
+.Ft int
+.Fn _tolower_l "int c" "locale_t l"
 .Sh DESCRIPTION
-The
+The functions
 .Fn tolower
-function converts an upper-case letter to the corresponding lower-case
+and
+.Fn tolower_l
+convert an upper-case letter to the corresponding lower-case
 letter.
-The
+The functions
 .Fn _tolower
-function is identical to
+and
+.Fn _tolower_l
+are identical to
 .Fn tolower
+and
+.Fn tolower_l
 except that
 .Ar c
 must be an upper-case letter.
 .Sh RETURN VALUES
 If the argument to the
 .Fn tolower
-function is an upper-case letter, the corresponding lower-case letter
+and
+.Fn tolower_l
+functions is an upper-case letter, the corresponding lower-case letter
 is returned if there is one; otherwise the argument is returned unchanged.
 If the argument to the
 .Fn _tolower
-function is an upper-case letter, the corresponding lower-case letter
+and
+.Fn _tolower_l
+functions is an upper-case letter, the corresponding lower-case letter
 is returned; otherwise the output is undefined.
+.Pp
+The behavior of the functions
+.Fn tolower
+and
+.Fn _tolower
+is affected by the
+.Dv LC_CTYPE
+category of the current locale, while
+the behavior of the functions
+.Fn tolower_l
+and
+.Fn _tolower_l
+is affected by the
+.Dv LC_CTYPE
+category of the locale provided as parameter, see
+.Xr xlocale 3 .
 .\" In the
 .\" .Em ``C''
 .\" locale,
@@ -91,13 +124,13 @@
 .Xr stdio 3 ,
 .Xr toascii 3 ,
 .Xr toupper 3 ,
-.Xr ascii 7
+.Xr ascii 7 ,
+.Xr setlocale 3
+.Xr xlocale 3
 .Sh STANDARDS
-The
-.Fn tolower
-and
-.Fn _tolower
+These
 functions conform to
+POSIX2008,
 .St -ansiC .
 .Sh CAVEATS
 The argument to
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/gen/toupper.3 src53xlocale2/lib/libc/gen/toupper.3
--- src53xlocale1/lib/libc/gen/toupper.3	Fri Mar 22 08:37:38 2013
+++ src53xlocale2/lib/libc/gen/toupper.3	Fri Apr 12 11:46:27 2013
@@ -36,7 +36,9 @@
 .Os
 .Sh NAME
 .Nm toupper ,
-.Nm _toupper
+.Nm toupper_l ,
+.Nm _toupper ,
+.Nm _toupper_l
 .Nd lower case to upper case letter conversion
 .Sh SYNOPSIS
 .In ctype.h
@@ -44,27 +46,58 @@
 .Fn toupper "int c"
 .Ft int
 .Fn _toupper "int c"
+.In xlocale.h
+.Ft int
+.Fn toupper_l "int c" "locale_t l"
+.Ft int
+.Fn _toupper_l "int c" "locale_t l"
 .Sh DESCRIPTION
-The
+The functions
 .Fn toupper
-function converts a lower-case letter to the corresponding
+and
+.Fn toupper_l
+convert a lower-case letter to the corresponding
 upper-case letter.
-The
+The functions
 .Fn _toupper
-function is identical to
+and
+.Fn _toupper_l
+are identical to
 .Fn toupper
+and
+.Fn toupper_l
 except that
 .Ar c
 must be a lower-case letter.
 .Sh RETURN VALUES
 If the argument to the
 .Fn toupper
+and
+.Fn toupper_l
 function is a lower-case letter, the corresponding upper-case letter
 is returned if there is one; otherwise the argument is returned unchanged.
 If the argument to the
 .Fn _toupper
+and
+.Fn _toupper_l
 function is a lower-case letter, the corresponding upper-case letter
 is returned; otherwise the output is undefined.
+.Pp
+The behavior of the functions
+.Fn toupper
+and
+.Fn _toupper
+is affected by the
+.Dv LC_CTYPE
+category of the current locale, while
+the behavior of the functions
+.Fn toupper_l
+and
+.Fn _toupper_l
+is affected by the
+.Dv LC_CTYPE
+category of the locale provided as parameter, see
+.Xr xlocale 3 .
 .\" In the
 .\" .Em ``C''
 .\" locale,
@@ -91,7 +124,9 @@
 .Xr stdio 3 ,
 .Xr toascii 3 ,
 .Xr tolower 3 ,
-.Xr ascii 7
+.Xr ascii 7 ,
+.Xr setlocale 3 ,
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn toupper
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/ctype_l.3 src53xlocale2/lib/libc/locale/ctype_l.3
--- src53xlocale1/lib/libc/locale/ctype_l.3	Mon Apr  8 21:21:23 2013
+++ src53xlocale2/lib/libc/locale/ctype_l.3	Fri Apr 12 12:01:41 2013
@@ -50,7 +50,7 @@
 .Nm isspace_l ,
 .Nm isspecial_l ,
 .Nm isupper_l ,
-.Nm isxdigit_l 
+.Nm isxdigit_l
 .Nd character classification functions
 .Sh LIBRARY
 .Lb libc
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/duplocale.3 src53xlocale2/lib/libc/locale/duplocale.3
--- src53xlocale1/lib/libc/locale/duplocale.3	Mon Apr  8 21:20:56 2013
+++ src53xlocale2/lib/libc/locale/duplocale.3	Fri Apr 12 12:16:31 2013
@@ -27,14 +27,12 @@
 .\"
 .\" $FreeBSD: src/lib/libc/locale/duplocale.3,v 1.6 2012/11/17 01:49:29 svnexp Exp $
 .\"
-.Dd September 17 2011
+.Dd $Mdocdate: September 17 2011 $
 .Dt DUPLOCALE 3
 .Os
 .Sh NAME
 .Nm duplocale
 .Nd duplicate an locale
-.Sh LIBRARY
-.Lb libc
 .Sh SYNOPSIS
 .In xlocale.h
 .Ft locale_t
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/freelocale.3 src53xlocale2/lib/libc/locale/freelocale.3
--- src53xlocale1/lib/libc/locale/freelocale.3	Mon Apr  8 21:20:56 2013
+++ src53xlocale2/lib/libc/locale/freelocale.3	Fri Apr 12 12:16:22 2013
@@ -26,7 +26,7 @@
 .\" SUCH DAMAGE.
 .\"
 .\" $FreeBSD: src/lib/libc/locale/freelocale.3,v 1.4 2012/11/17 01:49:29 svnexp Exp $
-.Dd September 17 2011
+.Dd $Mdocdate: September 17 2011 $
 .Dt FREELOCALE 3
 .Os
 .Sh NAME
@@ -35,8 +35,6 @@
 .Xr duplocale 3
 or
 .Xr newlocale 3
-.Sh LIBRARY
-.Lb libc
 .Sh SYNOPSIS
 .In xlocale.h
 .Ft int
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/mbsrtowcs.3 src53xlocale2/lib/libc/locale/mbsrtowcs.3
--- src53xlocale1/lib/libc/locale/mbsrtowcs.3	Mon Apr  8 21:20:56 2013
+++ src53xlocale2/lib/libc/locale/mbsrtowcs.3	Fri Apr 12 12:02:06 2013
@@ -41,11 +41,13 @@
 .In wchar.h
 .Ft size_t
 .Fn mbsrtowcs "wchar_t * restrict dst" "const char ** restrict src" "size_t len" \
+"mbstate_t * restrict ps"
 .Ft size_t
 .Fn mbsrtowcs_l "wchar_t * restrict dst" "const char ** restrict src" "size_t len" \
 "mbstate_t * restrict ps" "locale_t l"
 .Ft size_t
 .Fn mbsnrtowcs "wchar_t * restrict dst" "const char ** restrict src" "size_t nmc" \
+"size_t len" "mbstate_t * restrict ps"
 .Ft size_t
 .Fn mbsnrtowcs_l "wchar_t * restrict dst" "const char ** restrict src" "size_t nmc" \
 "size_t len" "mbstate_t * restrict ps" "locale_t l"
@@ -74,7 +76,7 @@
 .El
 .Pp
 The
-.Fn mbsnrtowcs 
+.Fn mbsnrtowcs
 and
 .Fn mbsnrtowcs_l
 functions are equivalent to
@@ -117,7 +119,7 @@
 .Fn mbsnrtowcs_l
 functions is affected by the
 .Dv LC_CTYPE
-category of the locale provided as parameter, see 
+category of the locale provided as parameter, see
 .Xr xlocale 3
 .Pp
 There are two special cases:
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/newlocale.3 src53xlocale2/lib/libc/locale/newlocale.3
--- src53xlocale1/lib/libc/locale/newlocale.3	Mon Apr  8 21:20:56 2013
+++ src53xlocale2/lib/libc/locale/newlocale.3	Fri Apr 12 12:16:13 2013
@@ -25,15 +25,13 @@
 .\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 .\" SUCH DAMAGE.
 .\"
-.\" From FreeBSD src/lib/libc/locale/newlocale.3,v 1.8 2012/11/17 01:49:30 svnexp Exp 
-.Dd September 17 2011
+.\" From FreeBSD src/lib/libc/locale/newlocale.3,v 1.8 2012/11/17 01:49:30 svnexp Exp
+.Dd $Mdocdate: September 17 2011 $
 .Dt NEWLOCALE 3
 .Os
 .Sh NAME
 .Nm newlocale
 .Nd Creates a new locale
-.Sh LIBRARY
-.Lb libc
 .Sh SYNOPSIS
 .In xlocale
 .Ft locale_t
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/querylocale.3 src53xlocale2/lib/libc/locale/querylocale.3
--- src53xlocale1/lib/libc/locale/querylocale.3	Mon Apr  8 21:20:56 2013
+++ src53xlocale2/lib/libc/locale/querylocale.3	Fri Apr 12 12:15:40 2013
@@ -25,16 +25,14 @@
 .\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 .\" SUCH DAMAGE.
 .\"
-.\" From FreeBSD: src/lib/libc/locale/querylocale.3,v 1.4 2012/11/17 01:49:30 svnexp Exp 
+.\" From FreeBSD: src/lib/libc/locale/querylocale.3,v 1.4 2012/11/17 01:49:30 svnexp Exp
 .\"
-.Dd September 17 2011
+.Dd $Mdocdate: September 17 2011 $
 .Dt QUERYLOCALE 3
 .Os
 .Sh NAME
 .Nm querylocale
 .Nd Look up the locale name for a specified category
-.Sh LIBRARY
-.Lb libc
 .Sh SYNOPSIS
 .In xlocale.h
 .Ft const char *
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src56-orig/lib/libc/locale/towlower.3 src/lib/libc/locale/towlower.3
--- src56-orig/lib/libc/locale/towlower.3	Mon Mar 25 18:28:42 2013
+++ src/lib/libc/locale/towlower.3	Fri Apr 12 12:02:28 2013
@@ -39,7 +39,9 @@
 .Os
 .Sh NAME
 .Nm towlower ,
-.Nm towupper
+.Nm towlower_l ,
+.Nm towupper ,
+.Nm towupper_l
 .Nd wide-character case letter conversion utilities
 .Sh SYNOPSIS
 .In wctype.h
@@ -47,18 +49,45 @@
 .Fn towlower "wint_t wc"
 .Ft wint_t
 .Fn towupper "wint_t wc"
+.In xlocale.h
+.Ft wint_t
+.Fn towlower_l "wint_t wc" "locale_t l"
+.Ft wint_t
+.Fn towupper_l "wint_t wc" "locale_t l"
 .Sh DESCRIPTION
 The
 .Fn towlower
-function converts an upper-case wide character to the corresponding lower-case
+and
+.Fn towlower_l
+functions convert an upper-case wide character to the corresponding lower-case
 letter.
 The
 .Fn towupper
-function converts an lower-case wide character to the corresponding upper-case
+and
+.Fn towupper_l
+functions convert an lower-case wide character to the corresponding upper-case
 letter.
+.Pp
+The behavior of the functions
+.Fn towupper
+and
+.Fn towlower
+is affected by the
+.Dv LC_CTYPE
+category of the current locale, while
+the behavior of the functions
+.Fn towupper_l
+and
+.Fn towlower_l
+is affected by the
+.Dv LC_CTYPE
+category of the locale provided as parameter, see
+.Xr xlocale 3 .
 .Sh RETURN VALUES
 If the argument is an upper/lower-case letter, the
 .Fn tolower
+and
+.Fn tolower_l
 function returns the corresponding counterpart if there is
 one; otherwise the argument is returned unchanged.
 .Sh SEE ALSO
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/uselocale.3 src53xlocale2/lib/libc/locale/uselocale.3
--- src53xlocale1/lib/libc/locale/uselocale.3	Mon Apr  8 21:20:56 2013
+++ src53xlocale2/lib/libc/locale/uselocale.3	Fri Apr 12 12:15:27 2013
@@ -27,14 +27,12 @@
 .\"
 .\" $FreeBSD: src/lib/libc/locale/uselocale.3,v 1.4 2012/11/17 01:49:30 svnexp Exp $
 .\"
-.Dd September 17 2011
+.Dd $Mdocdate: September 17 2011 $
 .Dt USELOCALE 3
 .Os
 .Sh NAME
 .Nm uselocale
 .Nd Sets a thread-local locale
-.Sh LIBRARY
-.Lb libc
 .Sh SYNOPSIS
 .In xlocale.h
 .Ft locale_t
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wcscoll.3 src53xlocale2/lib/libc/locale/wcscoll.3
--- src53xlocale1/lib/libc/locale/wcscoll.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/wcscoll.3	Fri Apr 12 12:07:57 2013
@@ -38,13 +38,17 @@
 .Os
 .\" ----------------------------------------------------------------------
 .Sh NAME
-.Nm wcscoll
+.Nm wcscoll ,
+.Nm wcscoll_l
 .Nd compare wide strings according to current collation
 .\" ----------------------------------------------------------------------
 .Sh SYNOPSIS
-.Fd #include <wchar.h>
+.In wchar.h
 .Ft int
 .Fn wcscoll "const wchar_t *s1" "const wchar_t *s2"
+.In xlocale.h
+.Ft int
+.Fn wcscoll_l "const wchar_t *s1" "const wchar_t *s2" "locale_t loc"
 .\" ----------------------------------------------------------------------
 .Sh DESCRIPTION
 The
@@ -53,7 +57,10 @@
 .Fa s1
 and
 .Fa s2
-according to the current locale collation order.
+according to the current locale collation order. The
+.Fn wcscoll_l
+function does the same but using the locale given as parameter.
+.Pp
 In the
 .Dq Li C
 locale,
@@ -64,8 +71,10 @@
 .Sh RETURN VALUES
 The
 .Fn wcscoll
-function
-returns an integer greater than, equal to, or less than 0,
+and
+.Fn wcscoll_l
+functions
+return an integer greater than, equal to, or less than 0,
 if
 .Fa s1
 is greater than, equal to, or less than
@@ -74,15 +83,15 @@
 No return value is reserved to indicate errors;
 callers should set
 .Va errno
-to 0 before calling
-.Fn wcscoll .
-If it is non-zero upon return from
-.Fn wcscoll ,
+to 0 before calling these functions.
+If it is non-zero upon return from these function
 an error has occurred.
 .\" ----------------------------------------------------------------------
 .Sh ERRORS
 The
 .Fn wcscoll
+and
+.Fn wcscoll_l
 function will fail if:
 .Bl -tag -width Er
 .It Bq Er EILSEQ
@@ -96,6 +105,7 @@
 .Xr strcoll 3 ,
 .Xr wcscmp 3 ,
 .Xr wcsxfrm 3
+.Xr xlocale 3
 .\" ----------------------------------------------------------------------
 .Sh STANDARDS
 The
@@ -106,9 +116,8 @@
 .Pq Dq ISO C99 .
 .Pp
 The
-.Fn wcsnrtombs
-function conforms to
-.St -p1003.1-2008 .
+.Fn wcscoll_l
+function is a Darwin extension.
 .\" ----------------------------------------------------------------------
 .Sh BUGS
 The current implementation is enough only for single byte encodings and UTF-8
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wcsrtombs.3 src53xlocale2/lib/libc/locale/wcsrtombs.3
--- src53xlocale1/lib/libc/locale/wcsrtombs.3	Mon Apr  8 21:20:56 2013
+++ src53xlocale2/lib/libc/locale/wcsrtombs.3	Fri Apr 12 12:12:43 2013
@@ -41,13 +41,15 @@
 .In wchar.h
 .Ft size_t
 .Fn wcsrtombs "const char * restrict dst" "const wchar_t ** restrict src" \
+"size_t len" "mbstate_t * restrict ps"
 .Ft size_t
 .Fn wcsrtombs_l "const char * restrict dst" "const wchar_t ** restrict src" \
 "size_t len" "mbstate_t * restrict ps" "locale_t l"
 .Ft size_t
 .Fn wcsnrtombs "const char * restrict dst" "const wchar_t ** restrict src" \
+"size_t nwc" "size_t len" "mbstate_t * restrict ps"
 .Ft size_t
-.Fn wcsnrtombs "const char * restrict dst" "const wchar_t ** restrict src" \
+.Fn wcsnrtombs_l "const char * restrict dst" "const wchar_t ** restrict src" \
 "size_t nwc" "size_t len" "mbstate_t * restrict ps" "locale_t l"
 .\" ----------------------------------------------------------------------
 .Sh DESCRIPTION
@@ -122,7 +124,6 @@
 .Dv LC_CTYPE
 category of the locale provided as parameter, see
 .Xr xlocale 3
-
 .Pp
 There are two special cases:
 .Bl -tag -width 012345678901
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wcsxfrm.3 src53xlocale2/lib/libc/locale/wcsxfrm.3
--- src53xlocale1/lib/libc/locale/wcsxfrm.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/wcsxfrm.3	Fri Apr 12 12:12:05 2013
@@ -37,7 +37,9 @@
 .Dt WCSXFRM 3
 .Os
 .Sh NAME
-.Nm wcsxfrm
+.Nm wcsxfrm ,
+and
+.Nm wcsxfrm_l
 .Nd transform a wide string under locale
 .Sh LIBRARY
 .Lb libc
@@ -45,10 +47,12 @@
 .In wchar.h
 .Ft size_t
 .Fn wcsxfrm "wchar_t * restrict dst" "const wchar_t * restrict src" "size_t n"
+.Ft size_t
+.Fn wcsxfrm_l "wchar_t * restrict dst" "const wchar_t * restrict src" "size_t n" "locale_t loc"
 .Sh DESCRIPTION
 The
 .Fn wcsxfrm
-function transforms a null-terminated wide character string pointed to by
+function transform a null-terminated wide character string pointed to by
 .Fa src
 according to the current locale collation order
 then copies the transformed string
@@ -76,6 +80,10 @@
 is equivalent to comparing
 two original strings with
 .Fn wcscoll .
+The function
+.Fn wcsxfrm_l
+does the same but uses the locale provided as parameter, see
+.Xr xlocale 3 .
 .Sh RETURN VALUES
 Upon successful completion,
 .Fn wcsxfrm
@@ -90,7 +98,8 @@
 .Xr setlocale 3 ,
 .Xr strxfrm 3 ,
 .Xr wcscmp 3 ,
-.Xr wcscoll 3
+.Xr wcscoll 3 ,
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn wcsxfrm
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wctob.3 src53xlocale2/lib/libc/locale/wctob.3
--- src53xlocale1/lib/libc/locale/wctob.3	Mon Apr  8 21:20:56 2013
+++ src53xlocale2/lib/libc/locale/wctob.3	Fri Apr 12 12:05:48 2013
@@ -49,9 +49,9 @@
 functions converts a wide character
 .Fa wc
 to a corresponding single byte character in the initial shift state of
-the current locale in the case of 
+the current locale in the case of
 .Fn wctob
-or of the locale provided as parameter to 
+or of the locale provided as parameter to
 .Fn wctob_l ,
 see
 .Xr xlocale 3
@@ -62,7 +62,7 @@
 .Dv LC_CTYPE
 category of the current locale. While the behavior of
 .Fn wctob_l
-depends on the 
+depends on the
 .Dv LC_CTYPE
 category of the provided locale.
 .\" ----------------------------------------------------------------------
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/string/strcasecmp.3 src53xlocale2/lib/libc/string/strcasecmp.3
--- src53xlocale1/lib/libc/string/strcasecmp.3	Mon Mar 25 18:28:29 2013
+++ src53xlocale2/lib/libc/string/strcasecmp.3	Fri Apr 12 11:57:00 2013
@@ -36,7 +36,9 @@
 .Os
 .Sh NAME
 .Nm strcasecmp ,
-.Nm strncasecmp
+.Nm strcasecmp_l ,
+.Nm strncasecmp ,
+.Nm strncasecmp_l
 .Nd compare strings, ignoring case
 .Sh SYNOPSIS
 .In string.h
@@ -44,11 +46,17 @@
 .Fn strcasecmp "const char *s1" "const char *s2"
 .Ft int
 .Fn strncasecmp "const char *s1" "const char *s2" "size_t len"
+.In xlocale.h
+.Ft int
+.Fn strcasecmp_l "const char *s1" "const char *s2" "locale_t l"
+.Ft int
+.Fn strncasecmp_l "const char *s1" "const char *s2" "size_t len" "locale_t l"
 .Sh DESCRIPTION
 The
-.Fn strcasecmp
-and
-.Fn strncasecmp
+.Fn strcasecmp ,
+.Fn strcasecmp_l ,
+.Fn strncasecmp ,
+.Fn strncasecmp_l
 functions compare the NUL-terminated strings
 .Fa s1
 and
@@ -60,13 +68,22 @@
 .Fa s2
 after translation of each corresponding character to lower-case.
 The strings themselves are not modified.
-The comparison is done using unsigned characters, so that
-.Sq Li \e200
-is greater than
-.Ql \e0 .
+The comparison is done using the classification for lowercase and uppercase
+of the global locale in the case of
+.Fn strcasecmp
+and
+.Fn strncasecmp
+and of the given locale for the functions
+.Fn strcasecmp_l
+and
+.Fn strncasecmp_l
+see
+.Xr xlocale 3
 .Pp
 .Fn strncasecmp
-compares at most
+and
+.Fn strncasecmp_l
+compare at most
 .Fa len
 characters.
 .Sh SEE ALSO
@@ -76,6 +93,7 @@
 .Xr strcoll 3 ,
 .Xr strxfrm 3 ,
 .Xr wcscasecmp 3
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn strcasecmp
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/string/strcoll.3 src53xlocale2/lib/libc/string/strcoll.3
--- src53xlocale1/lib/libc/string/strcoll.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/string/strcoll.3	Fri Apr 12 11:57:04 2013
@@ -35,12 +35,16 @@
 .Dt STRCOLL 3
 .Os
 .Sh NAME
-.Nm strcoll
-.Nd compare strings according to current collation
+.Nm strcoll ,
+.Nm strcoll_l
+.Nd compare strings according to the collation of a locale
 .Sh SYNOPSIS
 .In string.h
 .Ft int
 .Fn strcoll "const char *s1" "const char *s2"
+.In xlocale.h
+.Ft int
+.Fn strcoll_l "const char *s1" "const char *s2" "locale_t l"
 .Sh DESCRIPTION
 The
 .Fn strcoll
@@ -54,13 +58,19 @@
 .Fa s1
 is greater than, equal to, or less than
 .Fa s2 .
+The
+.Fn strcoll_l
+function behaves in analogous way but using the locale given as
+parameter, see
+.Xr xlocale 3
 .Sh SEE ALSO
 .Xr bcmp 3 ,
 .Xr memcmp 3 ,
 .Xr setlocale 3 ,
 .Xr strcasecmp 3 ,
 .Xr strcmp 3 ,
-.Xr strxfrm 3
+.Xr strxfrm 3 ,
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn strcoll
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/string/strstr.3 src53xlocale2/lib/libc/string/strstr.3
--- src53xlocale1/lib/libc/string/strstr.3	Mon Mar 25 18:28:29 2013
+++ src53xlocale2/lib/libc/string/strstr.3	Fri Apr 12 11:57:50 2013
@@ -35,7 +35,9 @@
 .Dt STRSTR 3
 .Os
 .Sh NAME
-.Nm strstr , strcasestr
+.Nm strstr ,
+.Nm strcasestr ,
+.Nm strcasestr_l
 .Nd locate a substring in a string
 .Sh SYNOPSIS
 .In string.h
@@ -43,6 +45,9 @@
 .Fn strstr "const char *big" "const char *little"
 .Ft char *
 .Fn strcasestr "const char *big" "const char *little"
+.In xlocale.h
+.Ft char *
+.Fn strcasestr_l "const char *big" "const char *little" "locale_t l"
 .Sh DESCRIPTION
 The
 .Fn strstr
@@ -55,7 +60,13 @@
 .Fn strcasestr
 function is similar to
 .Fn strstr
-but ignores the case of both strings.
+but ignores the case of both strings and uses the current locale.
+.Pp
+.Fn strcasestr_l
+funcion is similar to
+.Fn strcasestr
+but uses the locale provided as parameter, see
+.Xr xlocale 3
 .Sh RETURN VALUES
 If
 .Fa little
@@ -81,7 +92,8 @@
 .Xr strsep 3 ,
 .Xr strspn 3 ,
 .Xr strtok 3 ,
-.Xr wcsstr 3
+.Xr wcsstr 3 ,
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn strstr
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/string/strxfrm.3 src53xlocale2/lib/libc/string/strxfrm.3
--- src53collation/lib/libc/string/strxfrm.3	Mon Apr  1 08:25:36 2013
+++ src53xlocale2/lib/libc/string/strxfrm.3	Tue Apr 16 15:12:03 2013
@@ -35,18 +35,24 @@
 .Dt STRXFRM 3
 .Os
 .Sh NAME
-.Nm strxfrm
+.Nm strxfrm ,
+.Nm strxfrm_l
 .Nd transform a string under locale
 .Sh SYNOPSIS
 .In string.h
 .Ft size_t
 .Fn strxfrm "char *dst" "const char *src" "size_t n"
+.In xlocale.h
+.Ft size_t
+.Fn strxfrm_l "char *dst" "const char *src" "size_t n" "locale_t l"
 .Sh DESCRIPTION
 The idea of
 .Fn strxfrm
+and
+.Fn strxfrm_l
 is to
 .Dq un-localize
-a string: the function transforms
+a string: those function transform
 .Ar src ,
 storing the result in
 .Ar dst ,
@@ -55,12 +61,35 @@
 on transformed strings returns what
 .Xr strcoll 3
 on the original untransformed strings would return.
+.Pp
+.Ar n
+is the maximal amount of bytes that can be written to
+.Ar dst
+, however if
+.Ar n
+is 0 this function returns the amount of bytes that the transformed string
+would require --usefull to allocate space before calling  again.
+.Pp
+The function
+.Fn strcoll
+uses the current locale collation, while
+.Fn strcoll_l
+uses the given locale, see
+.Xr xlocale 3
+.Sh RETURN VALUE
+Length of the string transformed (not counting NUL).  If such lenght is grather
+than
+.Ar n
+the contents of
+.Ar dst
+is unspecified.
 .Sh SEE ALSO
 .Xr bcmp 3 ,
 .Xr memcmp 3 ,
 .Xr setlocale 3 ,
 .Xr strcasecmp 3 ,
 .Xr strcmp 3 ,
+.Xr xlocale 3 ,
 .Xr strcoll 3
 .Sh STANDARDS
 The
@@ -68,10 +97,7 @@
 function conforms to
 .St -ansiC .
 .Sh HISTORY
-The
-.Fn strxfrm
-function first appeared in
-.Bx 4.3 Reno .
+The implementation is derived from FreeBSD
 .\" ----------------------------------------------------------------------
 .Sh BUGS
 The current implementation is enough only for single byte encodings and UTF-8
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/string/wcscasecmp.3 src53xlocale2/lib/libc/string/wcscasecmp.3
--- src53xlocale1/lib/libc/string/wcscasecmp.3	Mon Mar 25 18:28:29 2013
+++ src53xlocale2/lib/libc/string/wcscasecmp.3	Fri Apr 12 11:57:25 2013
@@ -36,7 +36,9 @@
 .Os
 .Sh NAME
 .Nm wcscasecmp ,
-.Nm wcsncasecmp
+.Nm wcscasecmp_l ,
+.Nm wcsncasecmp ,
+.Nm wcsncasecmp_l
 .Nd compare wide strings, ignoring case
 .Sh SYNOPSIS
 .In wchar.h
@@ -44,11 +46,13 @@
 .Fn wcscasecmp "const wchar_t *s1" "const wchar_t *s2"
 .Ft int
 .Fn wcsncasecmp "const wchar_t *s1" "const wchar_t *s2" "size_t len"
+.In xlocale.h
+.Ft int
+.Fn wcscasecmp_l "const wchar_t *s1" "const wchar_t *s2" "locale_t l"
+.Ft int
+.Fn wcsncasecmp_l "const wchar_t *s1" "const wchar_t *s2" "size_t len" "locale_t l"
 .Sh DESCRIPTION
-The
-.Fn wcscasecmp
-and
-.Fn wcsncasecmp
+These
 functions compare the wide strings
 .Fa s1
 and
@@ -62,19 +66,40 @@
 The wide strings themselves are not modified.
 .Pp
 .Fn wcsncasecmp
+and
+.Fn wcsncasecmp_l
 compares at most
 .Fa len
 wide characters.
+.Pp
+The behavior of the functions
+.Fn wcscasecmp
+and
+.Fn wcsncasecmp
+is affected by the
+.Dv LC_CTYPE
+category of the current locale, while
+the behavior of the functions
+.Fn wcscasecmp_l
+and
+.Fn wcsncasecmp_l
+is affected by the
+.Dv LC_CTYPE
+category of the locale provided as parameter, see
+.Xr xlocale 3 .
 .Sh SEE ALSO
 .Xr strcasecmp 3 ,
 .Xr wcscmp 3 ,
-.Xr wmemcmp 3
+.Xr wmemcmp 3 ,
+.Xr setlocale 3 ,
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn wcscasecmp
 and
 .Fn wcsncasecmp
 functions conform to
+POSIX 2008 ,
 .St -p1003.1-2008 .
 .Sh HISTORY
 The
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/mbrlen.3 src53xlocale2/lib/libc/locale/mbrlen.3
--- src53xlocale1/lib/libc/locale/mbrlen.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/mbrlen.3	Fri Apr 12 12:07:57 2013
@@ -30,21 +30,27 @@
 .Os
 .\" ----------------------------------------------------------------------
 .Sh NAME
-.Nm mbrlen
+.Nm mbrlen ,
+.Nm mbrlen_l
 .Nd get number of bytes in a multibyte character (restartable)
 .\" ----------------------------------------------------------------------
 .Sh SYNOPSIS
 .In wchar.h
 .Ft size_t
 .Fn mbrlen "const char * restrict s" "size_t n" "mbstate_t * restrict ps"
+.In xlocale.h
+.Ft size_t
+.Fn mbrlen_l "const char * restrict s" "size_t n" "mbstate_t * restrict ps" "locale_t loc"
 .\" ----------------------------------------------------------------------
 .Sh DESCRIPTION
 The
 .Fn mbrlen
-function usually determines the number of bytes in
+and
+.Fn mbrlen_l
+functions usually determine the number of bytes in
 a multibyte character pointed to by
 .Fa s
-and returns it.
+and return it.
 This function shall only examine max n bytes of the array beginning from
 .Fa s .
 .Pp
@@ -86,7 +92,9 @@
 .Fn mbrlen
 is affected by
 .Dv LC_CTYPE
-category of the current locale.
+category of the current locale, while
+.Fn mbrlen_l
+uses the provided locale.
 .Pp
 There are the special cases:
 .Bl -tag -width 0123456789
@@ -205,3 +213,6 @@
 .\" .St -isoC99 .
 ISO/IEC 9899/1999
 .Pq Dq ISO C99 .
+The function
+.Fn mbrlen_l
+is a Darwin extension.
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/stdio/getwc.3 src53xlocale2/lib/libc/stdio/getwc.3
--- src53xlocale1/lib/libc/stdio/getwc.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/stdio/getwc.3	Fri Apr 12 12:07:57 2013
@@ -41,7 +41,10 @@
 .Sh NAME
 .Nm fgetwc ,
 .Nm getwc ,
-.Nm getwchar
+.Nm getwchar ,
+.Nm fgetwc_l ,
+.Nm getwc_l ,
+.Nm getwchar_l
 .Nd get next wide character from input stream
 .Sh SYNOPSIS
 .In stdio.h
@@ -55,25 +58,34 @@
 .Sh DESCRIPTION
 The
 .Fn fgetwc
-function
-obtains the next input wide character (if present) from the stream pointed at by
+and
+.Fn fgetwc_l
+functions
+obtain the next input wide character (if present) from the stream pointed at by
 .Fa stream ,
 or the next character pushed back on the stream via
 .Xr ungetwc 3 .
 .Pp
 The
 .Fn getwc
-function
-acts essentially identically to
-.Fn fgetwc ,
-but is a macro that expands in-line.
+and
+.Fn getwc_l
+functions
+act essentially identically to
+.Fn fgetwc.
 .Pp
 The
 .Fn getwchar
-function
-is equivalent to
+and
+.Fn getwchar_l
+functions
+are equivalent to
 .Fn getwc
+and
+.Fn getwc_l
 with the argument stdin.
+The functions with postfix "_l" use the encoding of locale provided to read
+from the file, the other functions use the encoding of the current locale.
 .Sh RETURN VALUES
 If successful, these routines return the next wide character
 from the
@@ -101,6 +113,7 @@
 .Xr putwc 3 ,
 .Xr stdio 3 ,
 .Xr ungetwc 3
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn fgetwc ,
@@ -110,3 +123,4 @@
 functions
 conform to
 .St -isoC-99 .
+Then functions with postfix "_l" are Darwin extensions.
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wcwidth.3 src53xlocale2/lib/libc/locale/wcwidth.3
--- src53xlocale1/lib/libc/locale/wcwidth.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/wcwidth.3	Fri Apr 12 12:07:57 2013
@@ -28,32 +28,48 @@
 .Dt WCWIDTH 3
 .Os
 .Sh NAME
-.Nm wcwidth
+.Nm wcwidth ,
+.Nm wcwidth_l
 .Nd number of column positions of a wide-character code
 .Sh SYNOPSIS
 .In wchar.h
 .Ft int
 .Fn wcwidth "wchar_t wc"
+.In xlocale.h 
+.Ft int
+.Fn wcwidth_l "wchar_t wc" "locale_t loc"
 .Sh DESCRIPTION
 The
 .Fn wcwidth
-function determines the number of column positions required to
+and
+.Fn wcwidth_l
+functions determine the number of column positions required to
 display the wide character
+.Fa wc . The
+.Fn wcwidth_l
+function uses the locale provided as parameter, while
+.Fn wcwidth_l
+uses the current locale.
 .Fa wc .
 .Sh RETURN VALUES
 The
 .Fn wcwidth
-function returns 0 if the
+and
+.Fn wcwidth_l
+functions return 0 if the
 .Fa wc
 argument is the NUL wide character (L'\e0'), \-1 if
 .Fa wc
-is not printable, or otherwise it returns the number of column
+is not printable, or otherwise they return the number of column
 positions the character occupies, which may be 0, 1, or 2.
 .Sh SEE ALSO
 .Xr iswprint 3 ,
 .Xr wcswidth 3
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn wcwidth
 function conforms to
-.St -p1003.1-2001 .
+.St -p1003.1-2001 . The
+.Fn wcwidth_l
+function is a Darwin extension.
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/_wcstoul.h src53xlocale2/lib/libc/locale/_wcstoul.h
--- src53xlocale1/lib/libc/locale/_wcstoul.h	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/_wcstoul.h	Fri Apr 12 12:07:57 2013
@@ -40,12 +40,13 @@
  *
  * parameters:
  *	FUNCNAME  : function name
+ *	FUNCNAMEL : function name with postfix _l
  *      uint_type : return type
  *      MAX_VALUE : upper limit of the return type
  */
 
 uint_type
-FUNCNAME(const wchar_t *nptr, wchar_t **endptr, int base)
+FUNCNAMEL(const wchar_t *nptr, wchar_t **endptr, int base, locale_t loc)
 {
 	const wchar_t *s;
 	uint_type acc, cutoff;
@@ -66,7 +67,7 @@
 	s = nptr;
 	do {
 		wc = (wchar_t) *s++;
-	} while (iswspace(wc));
+	} while (iswspace_l(wc, loc));
 	if (wc == L'-') {
 		neg = 1;
 		wc = *s++;
@@ -113,4 +114,11 @@
 		/* LINTED interface specification */
 		*endptr = (wchar_t *)(any ? s - 1 : nptr);
 	return (acc);
+}
+
+
+uint_type
+FUNCNAME(const wchar_t *nptr, wchar_t **endptr, int base)
+{
+	return FUNCNAMEL(nptr, endptr, base, __get_locale());
 }
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/_wcstol.h src53xlocale2/lib/libc/locale/_wcstol.h
--- src53xlocale1/lib/libc/locale/_wcstol.h	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/_wcstol.h	Fri Apr 12 12:07:57 2013
@@ -40,13 +40,15 @@
  *
  * parameters:
  *	FUNCNAME : function name
+ *	FUNCNAMEL : function name with postfix _l
  *      int_type : return type
  *      MIN_VALUE : lower limit of the return type
  *      MAX_VALUE : upper limit of the return type
  */
 
+
 int_type
-FUNCNAME(const wchar_t *nptr, wchar_t **endptr, int base)
+FUNCNAMEL(const wchar_t *nptr, wchar_t **endptr, int base, locale_t loc)
 {
 	const wchar_t *s;
 	int_type acc, cutoff;
@@ -68,7 +70,7 @@
 	s = nptr;
 	do {
 		wc = (wchar_t) *s++;
-	} while (iswspace(wc));
+	} while (iswspace_l(wc, loc));
 	if (wc == L'-') {
 		neg = 1;
 		wc = *s++;
@@ -133,4 +135,11 @@
 		/* LINTED interface specification */
 		*endptr = (wchar_t *)(any ? s - 1 : nptr);
 	return (acc);
+}
+
+
+int_type
+FUNCNAME(const wchar_t *nptr, wchar_t **endptr, int base)
+{
+	return FUNCNAMEL(nptr, endptr, base, __get_locale());
 }
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wcstoumax.c src53xlocale2/lib/libc/locale/wcstoumax.c
--- src53xlocale1/lib/libc/locale/wcstoumax.c	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/wcstoumax.c	Fri Apr 12 12:07:57 2013
@@ -8,10 +8,13 @@
 #include <stdlib.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <xlocale.h>
 
+#include "locale/xlocale_private.h"
 #include "wctoint.h"
 
 #define	FUNCNAME	wcstoumax
+#define	FUNCNAMEL	wcstoumax_l
 typedef uintmax_t	uint_type;
 #define	MAX_VALUE	UINTMAX_MAX
 
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wcstoimax.c src53xlocale2/lib/libc/locale/wcstoimax.c
--- src53xlocale1/lib/libc/locale/wcstoimax.c	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/wcstoimax.c	Fri Apr 12 12:07:57 2013
@@ -8,10 +8,13 @@
 #include <stdlib.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <xlocale.h>
 
+#include "locale/xlocale_private.h"
 #include "wctoint.h"
 
 #define	FUNCNAME	wcstoimax
+#define	FUNCNAMEL	wcstoimax_l
 typedef intmax_t	int_type;
 #define	MIN_VALUE	INTMAX_MIN
 #define	MAX_VALUE	INTMAX_MAX
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wcstoull.c src53xlocale2/lib/libc/locale/wcstoull.c
--- src53xlocale1/lib/libc/locale/wcstoull.c	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/wcstoull.c	Fri Apr 12 12:07:57 2013
@@ -7,10 +7,13 @@
 #include <stdlib.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <xlocale.h>
 
+#include "locale/xlocale_private.h"
 #include "wctoint.h"
 
 #define	FUNCNAME	wcstoull
+#define	FUNCNAMEL	wcstoull_l
 typedef unsigned long long int uint_type;
 #define	MAX_VALUE	ULLONG_MAX
 
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wcstoul.c src53xlocale2/lib/libc/locale/wcstoul.c
--- src53xlocale1/lib/libc/locale/wcstoul.c	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/wcstoul.c	Fri Apr 12 12:07:57 2013
@@ -7,10 +7,13 @@
 #include <stdlib.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <xlocale.h>
 
+#include "locale/xlocale_private.h"
 #include "wctoint.h"
 
 #define	FUNCNAME	wcstoul
+#define	FUNCNAMEL	wcstoul_l
 typedef unsigned long uint_type;
 #define	MAX_VALUE	ULONG_MAX
 
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wcstoll.c src53xlocale2/lib/libc/locale/wcstoll.c
--- src53xlocale1/lib/libc/locale/wcstoll.c	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/wcstoll.c	Fri Apr 12 12:07:57 2013
@@ -7,10 +7,13 @@
 #include <stdlib.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <xlocale.h>
 
+#include "locale/xlocale_private.h"
 #include "wctoint.h"
 
 #define	FUNCNAME	wcstoll
+#define	FUNCNAMEL	wcstoll_l
 typedef long long int int_type;
 #define	MIN_VALUE	LLONG_MIN
 #define	MAX_VALUE	LLONG_MAX
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/locale/wcstol.c src53xlocale2/lib/libc/locale/wcstol.c
--- src53xlocale1/lib/libc/locale/wcstol.c	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/locale/wcstol.c	Fri Apr 12 12:07:57 2013
@@ -7,10 +7,13 @@
 #include <stdlib.h>
 #include <wchar.h>
 #include <wctype.h>
+#include <xlocale.h>
 
+#include "locale/xlocale_private.h"
 #include "wctoint.h"
 
 #define	FUNCNAME	wcstol
+#define	FUNCNAMEL	wcstol_l
 typedef long int_type;
 #define	MIN_VALUE	LONG_MIN
 #define	MAX_VALUE	LONG_MAX
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/string/wcswidth.3 src53xlocale2/lib/libc/string/wcswidth.3
--- src53xlocale1/lib/libc/string/wcswidth.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/string/wcswidth.3	Fri Apr 12 12:07:57 2013
@@ -28,33 +28,47 @@
 .Dt WCSWIDTH 3
 .Os
 .Sh NAME
-.Nm wcswidth
+.Nm wcswidth ,
+.Nm wcswidth_l
 .Nd number of column positions in wide-character string
 .Sh SYNOPSIS
 .In wchar.h
 .Ft int
 .Fn wcswidth "const wchar_t *pwcs" "size_t n"
+.In xlocale.h
+.Ft int
+.Fn wcswidth_l "const wchar_t *pwcs" "size_t n" "locale_t loc"
 .Sh DESCRIPTION
 The
 .Fn wcswidth
-function determines the number of column positions required for the first
+and .Fn wcswidth_l
+functions determine the number of column positions required for the first
 .Fa n
 characters of
 .Fa pwcs ,
 or until a null wide character (L'\e0') is encountered.
+.Pp
+The function
+.Fn wcswidth_l
+uses the locale provided as parameter, whil
+.Fn wcswidth
+uses the currente locale.
 .Sh RETURN VALUES
 The
 .Fn wcswidth
-function returns 0 if
+and
+.Fn wcswidth_l
+functions return 0 if
 .Fa pwcs
 is an empty string (L""),
 \-1 if a non-printing wide character is encountered,
-otherwise it returns the number of column positions occupied.
+otherwise they return the number of column positions occupied.
 .Sh SEE ALSO
 .Xr iswprint 3 ,
 .Xr strlen 3 ,
 .Xr wcslen 3 ,
 .Xr wcwidth 3
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn wcswidth
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/stdio/vdprintf.c src53xlocale2/lib/libc/stdio/vdprintf.c
--- src53xlocale1/lib/libc/stdio/vdprintf.c	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/stdio/vdprintf.c	Fri Apr 12 12:07:57 2013
@@ -39,6 +39,7 @@
 #include <unistd.h>
 
 #include "local.h"
+#include "locale/xlocale_private.h"
 
 static int
 __dwrite(void *cookie, const char *buf, int n)
@@ -48,7 +49,7 @@
 }
 
 int
-vdprintf(int fd, const char * __restrict fmt, va_list ap)
+vdprintf_l(int fd, locale_t loc, const char * __restrict fmt, va_list ap)
 {
 	FILE f;
 	struct __sfileext fext;
@@ -71,3 +72,10 @@
 
 	return fflush(&f) ? EOF : ret;
 }
+
+int
+vdprintf(int fd, const char * __restrict fmt, va_list ap)
+{
+       return vdprintf_l(fd, __get_locale(), fmt, ap);
+}
+
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/stdio/dprintf.c src53xlocale2/lib/libc/stdio/dprintf.c
--- src53xlocale1/lib/libc/stdio/dprintf.c	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/stdio/dprintf.c	Fri Apr 12 12:07:57 2013
@@ -34,6 +34,7 @@
 
 #include <stdio.h>
 #include <stdarg.h>
+#include <xlocale.h>
 
 int
 dprintf(int fd, const char * __restrict fmt, ...)
@@ -43,6 +44,18 @@
 
 	va_start(ap, fmt);
 	ret = vdprintf(fd, fmt, ap);
+	va_end(ap);
+	return ret;
+}
+
+int
+dprintf_l(int fd, locale_t loc, const char * __restrict fmt, ...)
+{
+	va_list ap;
+	int ret;
+
+	va_start(ap, fmt);
+	ret = vdprintf_l(fd, loc, fmt, ap);
 	va_end(ap);
 	return ret;
 }
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/stdio/putwc.3 src53xlocale2/lib/libc/stdio/putwc.3
--- src53xlocale1/lib/libc/stdio/putwc.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/stdio/putwc.3	Fri Apr 12 12:07:57 2013
@@ -41,7 +41,10 @@
 .Sh NAME
 .Nm fputwc ,
 .Nm putwc ,
-.Nm putwchar
+.Nm putwchar ,
+.Nm fputwc_l ,
+.Nm putwc_l ,
+.Nm putwchar_l
 .Nd output a wide character to a stream
 .Sh SYNOPSIS
 .In stdio.h
@@ -52,37 +55,47 @@
 .Fn putwc "wchar_t wc" "FILE *stream"
 .Ft wint_t
 .Fn putwchar "wchar_t wc"
+.In xlocale.h
+.Ft wint_t
+.Fn fputwc_l "wchar_t wc" "FILE *stream" "locale_t loc"
+.Ft wint_t
+.Fn putwc_l "wchar_t wc" "FILE *stream" "locale_t loc"
+.Ft wint_t
+.Fn putwchar_l "wchar_t wc" "locale_t loc"
 .Sh DESCRIPTION
 The
 .Fn fputwc
-function
-writes the wide character
+and
+.Fn fputwc_l
+functions
+write the wide character
 .Fa wc
 to the output stream pointed to by
 .Fa stream .
 .Pp
 .Fn putwc
-acts essentially identically to
-.Fn fputwc ,
-but is a macro that expands in-line.
-It may evaluate
-.Fa stream
-more than once, so arguments given to
-.Fn putwc
-should not be expressions with potential side effects.
+and
+.Fn putwc_l
+act essentially identically to
+.Fn fputwc
+and
+.Fn fputwc_l .
 .Pp
 .Fn putwchar
-is identical to
+and
+.Fn putwchar_l
+are identical to
 .Fn putwc
+and
+.Fn putwc_l
 with an output stream of
 .Em stdout .
+.Pp
+The encoding used is defined by the locale provided as parameter
+in the case of functions with postfix "_l", and by the
+current locale for the other functions.
 .Sh RETURN VALUES
-The functions,
-.Fn fputwc ,
-.Fn putwc
-and
-.Fn putwchar
-return the wide character written.
+These functions return the wide character written.
 If an error occurs, the value
 .Dv WEOF
 is returned.
@@ -91,6 +104,7 @@
 .Xr fopen 3 ,
 .Xr getwc 3 ,
 .Xr stdio 3
+.Xr xlocale 3
 .Sh STANDARDS
 The functions
 .Fn fputwc ,
@@ -99,3 +113,9 @@
 .Fn putwchar ,
 conform to
 .St -isoC-99 .
+The functions
+.Fn fputwc_l ,
+.Fn putwc_l ,
+and
+.Fn putwchar_l
+are Darwin extensions.
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/stdio/fputws.3 src53xlocale2/lib/libc/stdio/fputws.3
--- src53xlocale1/lib/libc/stdio/fputws.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/stdio/fputws.3	Fri Apr 12 12:07:57 2013
@@ -43,25 +43,38 @@
 .Dt FPUTWS 3
 .Os
 .Sh NAME
-.Nm fputws
+.Nm fputws ,
+.Nm fputws_l
 .Nd output a line of wide characters to a stream
 .Sh SYNOPSIS
 .In stdio.h
 .In wchar.h
 .Ft int
 .Fn fputws "const wchar_t * restrict ws" "FILE * restrict fp"
+.In xlocale.h
+.Ft int
+.Fn fputws_l "const wchar_t * restrict ws" "FILE * restrict fp" "locale_t loc"
 .Sh DESCRIPTION
 The
 .Fn fputws
-function writes the wide-character string pointed to by
+and
+.Fn fputws_l
+functions write the wide-character string pointed to by
 .Fa ws
 to the stream pointed to by
 .Fa fp .
+The function 
+.Fn fputws_l
+use the encoding of the locale provided as parameter, while
+.Fn fputws
+use the encoding of the current locale.
 .Sh RETURN VALUES
 The
 .Fn fputws
-function
-returns 0 on success and \-1 on error.
+and
+.Fn fputws_l
+functions
+return 0 on success and \-1 on error.
 .Sh ERRORS
 .Bl -tag -width Er
 .It Bq Er EBADF
@@ -71,9 +84,8 @@
 is not a writable stream.
 .El
 .Pp
-The
-.Fn fputws
-function may also fail and set
+These
+functions may also fail and set
 .Va errno
 for any of the errors specified for the routine
 .Xr write 2 .
@@ -82,8 +94,12 @@
 .Xr fputs 3 ,
 .Xr putwc 3 ,
 .Xr stdio 3
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn fputws
 function conforms to
 .St -p1003.1-2001 .
+The
+.Fn fputws_l
+is a Darwin extension.
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/stdio/wprintf.3 src53xlocale2/lib/libc/stdio/wprintf.3
--- src53xlocale1/lib/libc/stdio/wprintf.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/stdio/wprintf.3	Fri Apr 12 12:07:57 2013
@@ -56,6 +56,19 @@
 .Fn vswprintf "wchar_t * restrict ws" "size_t n" "const wchar_t *restrict format" "va_list ap"
 .Ft int
 .Fn vwprintf "const wchar_t * restrict format" "va_list ap"
+.In xlocale.h
+.Ft int
+.Fn fwprintf_l "FILE * restrict stream" "locale_l loc" "const wchar_t * restrict format" ...
+.Ft int
+.Fn swprintf_l "wchar_t * restrict ws" "size_t n" "locale_l loc" "const wchar_t * restrict format" ...
+.Ft int
+.Fn wprintf_l "locale_l loc" "const wchar_t * restrict format" ...
+.Ft int
+.Fn vfwprintf_l "FILE * restrict stream" "locale_l loc" "const wchar_t * restrict" "va_list ap"
+.Ft int
+.Fn vswprintf_l "wchar_t * restrict ws" "size_t n" "locale_l loc" "const wchar_t *restrict format" "va_list ap"
+.Ft int
+.Fn vwprintf_l "locale_l loc" "const wchar_t * restrict format" "va_list ap"
 .Sh DESCRIPTION
 The
 .Fn wprintf
@@ -63,24 +76,33 @@
 .Fa format
 as described below.
 The
-.Fn wprintf
-and
+.Fn wprintf ,
+.Fn wprintf_l ,
 .Fn vwprintf
+and
+.Fn vwprintf_l
 functions
 write output to
 .Dv stdout ,
 the standard output stream;
 .Fn fwprintf
-and
+.Fn fwprintf_l
 .Fn vfwprintf
+and
+.Fn vfwprintf_l
 write output to the given output
 .Fa stream ;
 .Fn swprintf
-and
+.Fn swprintf_l
 .Fn vswprintf
+and
+.Fn vswprintf_l
 write to the wide character string
 .Fa ws .
 .Pp
+The functions with postfix "_l" use the locale provided as parameter,
+while the other functions use the current locale.
+.Pp
 These functions write the output under the control of a
 .Fa format
 string that specifies how subsequent arguments
@@ -94,9 +116,11 @@
 used to end output to strings).
 .Pp
 The
-.Fn swprintf
-and
+.Fn swprintf ,
+.Fn swprintf_l ,
 .Fn vswprintf
+and
+.Fn vswprintf_l
 functions will fail if
 .Fa n
 or more wide characters were requested to be written,
@@ -210,8 +234,13 @@
 or
 .Cm F )
 should be grouped and separated by thousands using
-the non-monetary separator returned by
-.Xr localeconv 3 .
+the non-monetary separator of the locale provided as
+parameter in the case of functions with postfix _l, or of
+the current locale (returned by
+.Xr localeconv_l 3
+and
+.Xr localeconv 3
+respectively).
 .El
 .It
 An optional decimal digit string specifying a minimum field width.
@@ -555,8 +584,11 @@
 .El
 .Pp
 The decimal point
-character is defined in the program's locale (category
-.Dv LC_NUMERIC ) .
+character is defined in the locale given as parameter
+(category
+.Dv LC_NUMERIC ),
+in the case of functions with "_l", and in the program's locale in
+the case of the other functions.
 .Pp
 In no case does a non-existent or small field width cause truncation of
 a numeric field; if the result of a conversion is wider than the field
@@ -569,6 +601,7 @@
 .Xr putwc 3 ,
 .Xr setlocale 3 ,
 .Xr wcsrtombs 3
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn wprintf ,
@@ -581,3 +614,13 @@
 functions
 conform to
 .St -isoC-99 .
+.Pp
+The
+.Fn wprintf_l ,
+.Fn fwprintf_l ,
+.Fn swprintf_l ,
+.Fn vwprintf_l ,
+.Fn vfwprintf_l
+and
+.Fn vswprintf_l
+are Darwin extensions.
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/stdio/wscanf.3 src53xlocale2/lib/libc/stdio/wscanf.3
--- src53xlocale1/lib/libc/stdio/wscanf.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/stdio/wscanf.3	Fri Apr 12 12:07:57 2013
@@ -43,7 +43,13 @@
 .Nm swscanf ,
 .Nm vwscanf ,
 .Nm vswscanf ,
-.Nm vfwscanf
+.Nm vfwscanf ,
+.Nm wscanf_l ,
+.Nm fwscanf_l ,
+.Nm swscanf_l ,
+.Nm vwscanf_l ,
+.Nm vswscanf_l ,
+.Nm vfwscanf_l
 .Nd wide character input format conversion
 .Sh SYNOPSIS
 .In stdio.h
@@ -61,6 +67,20 @@
 .Fn vswscanf "const wchar_t * restrict str" "const wchar_t * restrict format" "va_list ap"
 .Ft int
 .Fn vfwscanf "FILE * restrict stream" "const wchar_t * restrict format" "va_list ap"
+.In xlocale.h
+.Ft int
+.Fn wscanf_l "locale_t loc" "const wchar_t * restrict format" ...
+.Ft int
+.Fn fwscanf_l "FILE * restrict stream" "locale_t loc" "const wchar_t * restrict format" ...
+.Ft int
+.Fn swscanf_l "const wchar_t * restrict str" "locale_t loc" "const wchar_t * restrict format" ...
+.In stdarg.h
+.Ft int
+.Fn vwscanf_l "locale_t loc" "const wchar_t * restrict format" "va_list ap"
+.Ft int
+.Fn vswscanf_l "const wchar_t * restrict str" "locale_t loc" "const wchar_t * restrict format" "va_list ap"
+.Ft int
+.Fn vfwscanf_l "FILE * restrict stream" "locale_t loc" "const wchar_t * restrict format" "va_list ap"
 .Sh DESCRIPTION
 The
 .Fn wscanf
@@ -72,34 +92,55 @@
 the results of such conversions, if any, are stored through a set of pointer
 arguments.
 .Pp
+To check if a character is space and other locale related operations,
+the functions with postfix "_l" use the locale given as parameter, see
+.Xr xlocale 3 ,
+while the other functions use the currente locale, see
+.Xr setlocale 3 .
+.Pp
 The
 .Fn wscanf
+and
+.Fn wscanf_l
 function reads input from the standard input stream
 .Em stdin ,
 .Fn fwscanf
+and
+.Fn fwscanf_l
 reads input from the supplied stream pointer
 .Fa stream ,
-and
 .Fn swscanf
+and
+.Fn swscanf_l
 reads its input from the wide character string pointed to by
 .Fa str .
 .Pp
 The
 .Fn vfwscanf
-function is analogous to
+and
+.Fn vfwscanf_l
+functions are analogous to
 .Xr vfwprintf 3
-and reads input from the stream pointer
+and
+.Xr vfwprintf_l 3
+and read input from the stream pointer
 .Fa stream
 using a variable argument list of pointers (see
 .Xr stdarg 3 ) .
 The
 .Fn vwscanf
-function scans a variable argument list from the standard input and the
+and
+.Fn vwscanf_l
+functions scan a variable argument list from the standard input and the
 .Fn vswscanf
-function scans it from a wide character string; these are analogous to the
-.Fn vwprintf
 and
+.Fn vswscanf_l
+functions scan it from a wide character string; these are analogous to the
+.Fn vwprintf ,
+.Fn vwprintf_l ,
 .Fn vswprintf
+and
+.Fn vswprintf_l
 functions, respectively.
 .Pp
 Each successive
@@ -390,8 +431,11 @@
 .El
 .Pp
 The decimal point
-character is defined in the program's locale (category
-.Dv LC_NUMERIC ) .
+character is defined by the locale given as parameter
+(category
+.Dv LC_NUMERIC )
+in the case of functions with postfix "_l", and by the program's locale
+for other functions.
 .Pp
 For backwards compatibility, a
 .Dq conversion
@@ -421,6 +465,8 @@
 .Xr wcstol 3 ,
 .Xr wcstoul 3 ,
 .Xr wprintf 3
+.Xr wprintf_l 3 ,
+.Xr xlocale 3
 .Sh STANDARDS
 The functions
 .Fn wscanf ,
@@ -432,6 +478,16 @@
 .Fn vswscanf
 conform to
 .St -isoC-99 .
+.Pp
+The functions
+.Fn wscanf_l ,
+.Fn fwscanf_l ,
+.Fn swscanf_l ,
+.Fn vwscanf_l ,
+.Fn vfwscanf_l ,
+and
+.Fn vswscanf_l
+are Darwin extensions.
 .Sh BUGS
 In addition to the bugs documented in
 .Xr scanf 3 ,
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src53xlocale1/lib/libc/stdio/fgetws.3 src53xlocale2/lib/libc/stdio/fgetws.3
--- src53xlocale1/lib/libc/stdio/fgetws.3	Mon Apr  8 21:20:25 2013
+++ src53xlocale2/lib/libc/stdio/fgetws.3	Fri Apr 12 12:07:57 2013
@@ -43,22 +43,28 @@
 .Dt FGETWS 3
 .Os
 .Sh NAME
-.Nm fgetws
+.Nm fgetws ,
+.Nm fgetws_l ,
 .Nd get a line of wide characters from a stream
 .Sh SYNOPSIS
 .In stdio.h
 .In wchar.h
 .Ft "wchar_t *"
 .Fn fgetws "wchar_t * restrict ws" "int n" "FILE * restrict fp"
+.In xlocale.h
+.Ft "wchar_t *"
+.Fn fgetws_l "wchar_t * restrict ws" "int n" "FILE * restrict fp" "locale_t loc"
 .Sh DESCRIPTION
 The
 .Fn fgetws
-function
-reads at most one less than the number of characters specified by
+and
+.Fn fgetws_l
+functions
+read at most one less than the number of characters specified by
 .Fa n
 from the given
 .Fa fp
-and stores them in the wide-character string
+and store them in the wide-character string
 .Fa ws .
 Reading stops when a newline character is found,
 at end-of-file, or error.
@@ -66,25 +72,33 @@
 If any characters are read and there is no error, a
 .Ql \e0
 character is appended to end the string.
+.Pp
+The
+.Fn fgetws
+function uses the current locale, while
+.Fn fgetws_l
+uses the locale given as parameter.
 .Sh RETURN VALUES
 Upon successful completion,
 .Fn fgetws
-returns
+and
+.Fn fgetws_l
+return
 .Fa ws .
-If end-of-file occurs before any characters are read,
-.Fn fgetws
-returns
+If end-of-file occurs before any characters are read, they
+return
 .Dv NULL
 and the buffer contents remain unchanged.
-If an error occurs,
-.Fn fgetws
-returns
+If an error occurs, they
+return
 .Dv NULL
 and the buffer contents are indeterminate.
 The
 .Fn fgetws
-function
-does not distinguish between end-of-file and error, and callers must use
+and
+.Fn fgetws_l
+functions
+do not distinguish between end-of-file and error, and callers must use
 .Xr feof 3
 and
 .Xr ferror 3
@@ -100,8 +114,10 @@
 multibyte character.
 .El
 .Pp
-The function
+The functions
 .Fn fgetws
+and
+.Fn fgetws_l
 may also fail and set
 .Va errno
 for any of the errors specified for the routines
@@ -114,9 +130,13 @@
 .Xr feof 3 ,
 .Xr ferror 3 ,
 .Xr fgets 3
+.Xr xlocale 3
 .Sh STANDARDS
 The
 .Fn fgetws
 function
 conforms to
 .St -p1003.1-2001 .
+The
+.Fn fgetws_l
+function is a Darwin extension.
diff -ruN -x obj -x CVS -x *orig -x *rej -x *~ src56xlocale1/lib/libc/locale/rune_local.h src56xlocale2/lib/libc/locale/rune_local.h
--- src56xlocale1/lib/libc/locale/rune_local.h	Mon Apr  8 21:20:25 2013
+++ src56xlocale2/lib/libc/locale/rune_local.h	Fri Apr 12 12:07:57 2013
@@ -30,6 +30,8 @@
 #ifndef _RUNE_LOCAL_H_
 #define _RUNE_LOCAL_H_
 
+#include <xlocale.h>
+
 /* rune.c */
 extern _RuneLocale *_Read_RuneMagi(FILE *fp);
 extern void _NukeRune(_RuneLocale *);
@@ -45,5 +47,6 @@
 
 /* ___runetype_mb.c */
 extern _RuneType ___runetype_mb(wint_t);
+extern _RuneType ___runetype_mb_l(wint_t c, locale_t l);
 
 #endif
diff -ruN src59-orig/lib/libc/hidden/ctype.h src/lib/libc/hidden/ctype.h
--- src59-orig/lib/libc/hidden/ctype.h	Thu Jun  9 23:21:42 2016
+++ src/lib/libc/hidden/ctype.h	Sat Aug 20 22:41:28 2016
@@ -18,6 +18,14 @@
 #ifndef _LIBC_CTYPE_H_
 #define _LIBC_CTYPE_H_
 
+#include_next <ctype.h>
+#include_next <xlocale.h>
+
+#if 0
+extern PROTO_NORMAL(_ctype_);
+extern PROTO_NORMAL(_tolower_tab_);
+extern PROTO_NORMAL(_toupper_tab_);
+#endif
 /* sigh: predeclare and rename the functions which we'll declare inline */
 __only_inline int	isalnum(int _c);
 __only_inline int	isalpha(int _c);
@@ -38,30 +46,46 @@
 __only_inline int	_tolower(int _c);
 __only_inline int	_toupper(int _c);
 PROTO_NORMAL(isalnum);
+PROTO_NORMAL(isalnum_l);
 PROTO_NORMAL(isalpha);
+PROTO_NORMAL(isalpha_l);
 PROTO_NORMAL(iscntrl);
+PROTO_NORMAL(iscntrl_l);
 PROTO_NORMAL(isdigit);
 PROTO_NORMAL(isgraph);
+PROTO_NORMAL(isgraph_l);
 PROTO_NORMAL(islower);
+PROTO_NORMAL(islower_l);
 PROTO_NORMAL(isprint);
+PROTO_NORMAL(isprint_l);
 PROTO_NORMAL(ispunct);
+PROTO_NORMAL(ispunct_l);
 PROTO_NORMAL(isspace);
+PROTO_NORMAL(isspace_l);
 PROTO_NORMAL(isupper);
+PROTO_NORMAL(isupper_l);
 PROTO_NORMAL(isxdigit);
+PROTO_NORMAL(isxdigit_l);
 PROTO_NORMAL(tolower);
+PROTO_NORMAL(tolower_l);
 PROTO_NORMAL(toupper);
+PROTO_NORMAL(toupper_l);
 PROTO_NORMAL(isblank);
+PROTO_NORMAL(isblank_l);
 PROTO_NORMAL(isascii);
 PROTO_DEPRECATED(toascii);
 PROTO_STD_DEPRECATED(_tolower);
 PROTO_STD_DEPRECATED(_toupper);
 
-#include_next <ctype.h>
+PROTO_NORMAL(digittoint_l);
+PROTO_NORMAL(isdigit_l);
+PROTO_STD_DEPRECATED(ishexnumber_l);
+PROTO_NORMAL(isideogram_l);
+PROTO_NORMAL(isnumber_l);
+PROTO_NORMAL(isphonogram_l);
+PROTO_NORMAL(isrune_l);
+PROTO_NORMAL(isspecial_l);
+ 
 
-#if 0
-extern PROTO_NORMAL(_ctype_);
-extern PROTO_NORMAL(_tolower_tab_);
-extern PROTO_NORMAL(_toupper_tab_);
-#endif
 
 #endif /* !_LIBC_CTYPE_H_ */
diff -ruN src/lib/libc/hidden/wchar.h.orig src/lib/libc/hidden/wchar.h
--- src/lib/libc/hidden/wchar.h.orig	Sat Aug 20 19:49:11 2016
+++ src/lib/libc/hidden/wchar.h	Sat Aug 20 22:50:10 2016
@@ -90,10 +90,12 @@
 PROTO_NORMAL(wcstoull);
 PROTO_DEPRECATED(wcswcs);
 PROTO_NORMAL(wcswidth);
+PROTO_NORMAL(wcswidth_l);
 PROTO_NORMAL(wcsxfrm);
 PROTO_NORMAL(wctob);
 PROTO_NORMAL(wctob_l);
 PROTO_NORMAL(wcwidth);
+PROTO_NORMAL(wcwidth_l);
 PROTO_NORMAL(wmemchr);
 PROTO_NORMAL(wmemcmp);
 PROTO_NORMAL(wmemcpy);
diff -ruN src59-orig/lib/libc/hidden/wctype.h src/lib/libc/hidden/wctype.h
--- src59-orig/lib/libc/hidden/wctype.h	Thu Jun  9 23:21:42 2016
+++ src/lib/libc/hidden/wctype.h	Sat Aug 20 22:45:54 2016
@@ -19,24 +19,52 @@
 #define _LIBC_WCTYPE_H_
 
 #include_next <wctype.h>
+#include_next <xlocale.h>
 
 PROTO_STD_DEPRECATED(iswalnum);
+PROTO_STD_DEPRECATED(iswalnum_l);
 PROTO_STD_DEPRECATED(iswalpha);
+PROTO_STD_DEPRECATED(iswalpha_l);
 PROTO_STD_DEPRECATED(iswblank);
+PROTO_STD_DEPRECATED(iswblank_l);
 PROTO_STD_DEPRECATED(iswcntrl);
+PROTO_STD_DEPRECATED(iswcntrl_l);
 PROTO_STD_DEPRECATED(iswctype);
+PROTO_STD_DEPRECATED(iswctype_l);
 PROTO_STD_DEPRECATED(iswdigit);
+PROTO_STD_DEPRECATED(iswdigit_l);
 PROTO_STD_DEPRECATED(iswgraph);
+PROTO_STD_DEPRECATED(iswgraph_l);
 PROTO_STD_DEPRECATED(iswlower);
+PROTO_STD_DEPRECATED(iswlower_l);
 PROTO_STD_DEPRECATED(iswprint);
+PROTO_STD_DEPRECATED(iswprint_l);
 PROTO_STD_DEPRECATED(iswpunct);
+PROTO_STD_DEPRECATED(iswpunct_l);
 PROTO_NORMAL(iswspace);
+PROTO_NORMAL(iswspace_l);
 PROTO_NORMAL(iswupper);
+PROTO_NORMAL(iswupper_l);
 PROTO_STD_DEPRECATED(iswxdigit);
+PROTO_STD_DEPRECATED(iswxdigit_l);
 PROTO_STD_DEPRECATED(towctrans);
 PROTO_NORMAL(towlower);
+PROTO_NORMAL(towlower_l);
 PROTO_STD_DEPRECATED(towupper);
+PROTO_STD_DEPRECATED(towupper_l);
 PROTO_STD_DEPRECATED(wctrans);
+PROTO_STD_DEPRECATED(wctrans_l);
 PROTO_STD_DEPRECATED(wctype);
+PROTO_STD_DEPRECATED(wctype_l);
+
+PROTO_DEPRECATED(iswhexnumber_l);
+PROTO_DEPRECATED(iswideogram_l);
+PROTO_DEPRECATED(iswnumber_l);
+PROTO_DEPRECATED(iswphonogram_l);
+PROTO_DEPRECATED(iswrune_l);
+PROTO_DEPRECATED(iswspecial_l);
+
+PROTO_NORMAL(nextwctype_l);
+PROTO_DEPRECATED(towctrans_l);
 
 #endif /* !_LIBC_WCTYPE_H_ */
diff -ruN src/lib/libc/Symbols.list.orig   src/lib/libc/Symbols.list
--- src/lib/libc/Symbols.list.orig	Sun Aug 21 06:45:24 2016
+++ src/lib/libc/Symbols.list	Sun Aug 21 06:49:06 2016
@@ -1679,8 +1679,46 @@
 
 /* xlocale */
 btowc_l
+digittoint_l
 duplocale
 freelocale
+isalnum_l
+isalpha_l
+isblank_l
+iscntrl_l
+isdigit_l
+isgraph_l
+ishexnumber_l
+isideogram_l
+islower_l
+isnumber_l
+isphonogram_l
+isprint_l
+ispunct_l
+isrune_l
+isspace_l
+isspecial_l
+isupper_l
+iswalnum_l
+iswalpha_l
+iswblank_l
+iswcntrl_l
+iswctype_l
+iswdigit_l
+iswgraph_l
+iswhexnumber_l
+iswideogram_l
+iswlower_l
+iswnumber_l
+iswphonogram_l
+iswprint_l
+iswpunct_l
+iswrune_l
+iswspace_l
+iswspecial_l
+iswupper_l
+iswxdigit_l
+isxdigit_l
 mblen_l
 mbrlen_l
 mbrtowc_l
@@ -1690,14 +1728,26 @@
 mbstowcs_l
 mbtowc_l
 newlocale
+nextwctype
+nextwctype_l
 querylocale
+tolower_l
+toupper_l
+towctrans_l
+towlower_l
+towupper_l
 uselocale
 wcrtomb_l
 wcsnrtombs_l
 wcsrtombs_l
 wcstombs_l
+wcswidth_l
 wctob_l
 wctomb_l
+wctrans_l
+wctype_l
+wcwidth_l
+
 
 /* yp */
 yp_all
