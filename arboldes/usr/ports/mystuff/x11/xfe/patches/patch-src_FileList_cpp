$OpenBSD$
--- src/FileList.cpp.orig	Tue Aug 20 10:17:39 2013
+++ src/FileList.cpp	Tue Aug 27 11:20:32 2013
@@ -3,6 +3,9 @@
 #include "i18n.h"
 
 #include <ctype.h>
+#include <locale.h>
+#include <wctype.h>
+#include <wchar.h>
 #include <time.h>
 
 
@@ -46,11 +49,9 @@
 #define HASH2(x,n) (1|(((unsigned int)(x)*17)%((n)-1)))   // Probe Distance [1..n-1]
 
 
-#if defined(linux)
 FXStringDict* fsdevices=NULL; // Devices from fstab
 FXStringDict* mtdevices=NULL; // Mounted devices
 FXStringDict* updevices=NULL; // Responding devices
-#endif
 
 extern FXbool allowPopupScroll;
 extern FXString xdgdatahome;
@@ -163,83 +164,89 @@ FileList::FileList(FXWindow* focuswin, FXComposite *p,
 	forwardhist=NULL;
 	focuswindow=focuswin;
 	
-#if defined(linux)
 
 	// Initialize the fsdevices, mtdevices and updevices lists
 	// if it was not done in DirList (useful for XFileView, XFileQuery and XFileImage) 
-    struct mntent *mnt;
     if (fsdevices==NULL)
-	{
-		// To list file system devices
-    	fsdevices=new FXStringDict();
-		FILE *fstab=setmntent(FSTAB_PATH,"r");
-    	if(fstab)
-    	{
-        	while((mnt=getmntent(fstab)))
-        	{
-            	if(!streq(mnt->mnt_type,MNTTYPE_IGNORE) && !streq(mnt->mnt_type,MNTTYPE_SWAP)
-					&& !streq(mnt->mnt_dir,"/"))
-            	{				
-                	if(!strncmp(mnt->mnt_fsname,"/dev/fd",7))
-                    	fsdevices->insert(mnt->mnt_dir,"floppy");
-                	else if (!strncmp(mnt->mnt_type,"iso",3))
-                    	fsdevices->insert(mnt->mnt_dir,"cdrom");
-                	else if (!strncmp(mnt->mnt_fsname,"/dev/zip",8))
-                    	fsdevices->insert(mnt->mnt_dir,"zip");
-                	else if (streq(mnt->mnt_type,"nfs"))
-                    	fsdevices->insert(mnt->mnt_dir,"nfsdisk");
-                	else if (streq(mnt->mnt_type,"smbfs"))
-                    	fsdevices->insert(mnt->mnt_dir,"smbdisk");
-                	else
-                    	fsdevices->insert(mnt->mnt_dir,"harddisk");
-            	}
-        	}
-        	endmntent(fstab);
-    	}
-	}
-	if (mtdevices==NULL)
-	{
-		// To list mounted devices
-    	mtdevices=new FXStringDict();
-		FILE *mtab=setmntent(MTAB_PATH,"r");
-		if(mtab)
-		{
-			while((mnt=getmntent(mtab)))
-			{
-				// To fix an issue with some Linux distributions
-				FXString mntdir=mnt->mnt_dir;
-				if (mntdir!="/dev/.static/dev" &&   mntdir.rfind(".gvfs",5,mntdir.length())==-1)
-					mtdevices->insert(mnt->mnt_dir,mnt->mnt_type);
-			}
-			endmntent(mtab);
-		}
-	}
-	if (updevices==NULL)
-	{
-		// To mark mount points that are up or down
-    	updevices=new FXStringDict();
- 		struct stat statbuf;
-		FXString mtstate;
-		FILE *mtab=setmntent(MTAB_PATH,"r");
-		if(mtab)
-    	{
-        	while((mnt=getmntent(mtab)))
-			{
-				// To fix an issue with some Linux distributions
-				FXString mntdir=mnt->mnt_dir;
-				if (mntdir!="/dev/.static/dev" &&   mntdir.rfind(".gvfs",5,mntdir.length())==-1)
-				{
-					if (lstatmt(mnt->mnt_dir,&statbuf)==-1)
-						mtstate="down";
-					else
-						mtstate="up";	
-					updevices->insert(mnt->mnt_dir,mtstate.text());
-				}
-			}
-        	endmntent(mtab);
-    	}
-	}
+    {
+        // To list file system devices
+        fsdevices=new FXStringDict();
+#if defined(linux)
+        struct mntent *mnt;
+        FILE *fstab=setmntent(FSTAB_PATH,"r");
+        if(fstab)
+        {
+            while((mnt=getmntent(fstab)))
+            {
+                if(!streq(mnt->mnt_type,MNTTYPE_IGNORE) && !streq(mnt->mnt_type,MNTTYPE_SWAP)
+                        && !streq(mnt->mnt_dir,"/"))
+                {				
+                    if(!strncmp(mnt->mnt_fsname,"/dev/fd",7))
+                        fsdevices->insert(mnt->mnt_dir,"floppy");
+                    else if (!strncmp(mnt->mnt_type,"iso",3))
+                        fsdevices->insert(mnt->mnt_dir,"cdrom");
+                    else if (!strncmp(mnt->mnt_fsname,"/dev/zip",8))
+                        fsdevices->insert(mnt->mnt_dir,"zip");
+                    else if (streq(mnt->mnt_type,"nfs"))
+                        fsdevices->insert(mnt->mnt_dir,"nfsdisk");
+                    else if (streq(mnt->mnt_type,"smbfs"))
+                        fsdevices->insert(mnt->mnt_dir,"smbdisk");
+                    else
+                        fsdevices->insert(mnt->mnt_dir,"harddisk");
+                }
+            }
+            endmntent(fstab);
+        }
 #endif
+    }
+    if (mtdevices==NULL)
+    {
+        // To list mounted devices
+        mtdevices=new FXStringDict();
+#if defined(linux)
+        struct mntent *mnt;
+        FILE *mtab=setmntent(MTAB_PATH,"r");
+        if(mtab)
+        {
+            while((mnt=getmntent(mtab)))
+            {
+                // To fix an issue with some Linux distributions
+                FXString mntdir=mnt->mnt_dir;
+                if (mntdir!="/dev/.static/dev" &&   mntdir.rfind(".gvfs",5,mntdir.length())==-1)
+                    mtdevices->insert(mnt->mnt_dir,mnt->mnt_type);
+            }
+            endmntent(mtab);
+        }
+#endif
+    }
+    if (updevices==NULL)
+    {
+        // To mark mount points that are up or down
+        updevices=new FXStringDict();
+#if defined(linux)
+        struct mntent *mnt;
+        struct stat statbuf;
+        FXString mtstate;
+        FILE *mtab=setmntent(MTAB_PATH,"r");
+        if(mtab)
+        {
+            while((mnt=getmntent(mtab)))
+            {
+                // To fix an issue with some Linux distributions
+                FXString mntdir=mnt->mnt_dir;
+                if (mntdir!="/dev/.static/dev" &&   mntdir.rfind(".gvfs",5,mntdir.length())==-1)
+                {
+                    if (lstatmt(mnt->mnt_dir,&statbuf)==-1)
+                        mtstate="down";
+                    else
+                        mtstate="up";	
+                    updevices->insert(mnt->mnt_dir,mtstate.text());
+                }
+            }
+            endmntent(mtab);
+        }
+#endif
+    }
 	
 	// Trahscan location
 	trashfileslocation=xdgdatahome + PATHSEPSTRING TRASHFILESPATH;
@@ -1896,131 +1903,297 @@ long FileList::onUpdHeader(FXObject*,FXSelector,void*)
 }
 
 
-// Compare file names
-int FileList::ascending(const IconItem* pa,const IconItem* pb)
+/** 
+ * Compares fields of p and q, supposing they are single byte strings
+ * without using the current locale.
+ * @param  igncase	Ignore upper/lower-case?
+ * @param  asc		Ascending?  If false is descending order
+ * @param  mixdir	Mix directories with files?
+ * @param  jmp		Field to compare (separated with \t)
+ *
+ * @return 0 if equal, negative if p<q, positive if p>q
+ * If jmp has an invalid value returns 0 and errno will be EINVAL
+ */
+static int compare_nolocale(char *p, char *q, 
+		bool igncase,  bool asc, bool mixdir, int jmp)
 {
+	int rnames, rv = 0, i;
 
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
+	// Compare names
+	while (*p != '\0' && *p > '\t' && *q != '\0' && *q > '\t'
+			&& ((igncase && toLower(*p) == toLower(*q)) ||
+				(!igncase && *p == *q))) {
+		p++;
+		q++;
+	}
+	if (igncase) {
+		rnames = toLower(*p) - toLower(*q);
+	} else {
+		rnames = *p - *q;
+	}
+	if (jmp == 0) {  
+		rv = rnames;
+		goto end;
+	}
 
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
+	// Compare other fields
+	if (jmp == 1) {  // ascendingDir and similar
+		for(i = 1; *p && i; i -= (*p++ == '\t'))
+			;
+		for(i = 1; *q && i; i -= (*q++ == '\t'))
+			;
+	} else if (jmp > 1 && jmp < 8) {  // Jump some fields, 
+		//2->type, 3->ext, 5->user, 6->group, 7->perm,
+		// Adjust the header index depending on the list type
+		if (p[1] == '/')
+		{
+			for(i = jmp + 1; *p && i; i -= (*p++ == '\t'))
+				;
+			for(i = jmp + 1; *q && i; i -= (*q++ == '\t'))
+				;
+		} else {
+			for(i = jmp; *p && i; i -= (*p++ == '\t'))
+				;
+			for(i = jmp; *q && i; i -= (*q++ == '\t'))
+				;
+		}
+	} else if (jmp == 8) { // origPath
+		for(i = 8; *p && i; i -= (*p++ == '\t'))
+			;
+		for(i = 8; *q && i; i -= (*q++ == '\t'))
+			;
+	} else {
+		//assert(jmp>=0 && jmp<9);
+		errno = EINVAL;
+		return 0;
+	}
+	while (*p != '\0' && *p > '\t' && *q != '\0' && *q > '\t'
+			&& ((igncase && toLower(*p) == toLower(*q)) ||
+				(!igncase && *p == *q))) {
+		p++;
+		q++;
+	}
+	if (igncase) {
+		rv = toLower(*p) - toLower(*q);
+	} else {
+		rv = *p - *q;
+	}
+	if (rv == 0) { 
+		rv = rnames;
+	}
+end:
 
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-	
-	while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	// If descending flip
+	if (!asc) {
+		rv = rv * -1;
+	}
+	return rv;
 }
 
 
-// Compare file names, mixing files and directories
-int FileList::ascendingMix(const IconItem* pa,const IconItem* pb)
+
+/**
+ * Compares a field of pa with the same field of pb, if the fields are
+ * equal compare by name
+ * @param  igncase	Ignore upper/lower-case?
+ * @param  asc		Ascending?  If false is descending order
+ * @param  mixdir	Mix directories with files?
+ * @param  jmp		Field to compare (separated with \t)
+ *
+ * @return 0 if equal, negative if pa<pb, positive if pa>pb
+ * Requires to allocate some space, if there is no memory this 
+ * function returns 0 and errno will be ENOMEM
+ * If jmp has an invalid value returns 0 and errno will be EINVAL
+ */
+int FileList::compare(const IconItem* pa,const IconItem* pb, 
+		bool igncase,  bool asc,  bool mixdir, int jmp)
 {
+	
+	int rv = 0; // Value to return
+	register const FileItem *a = (FileItem*)pa;
+	register const FileItem *b = (FileItem*)pb;
+	register char *p = (char *)a->label.text();
+	register char *q = (char *)b->label.text();
 
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
+	// Common cases 
+	// Directory '..' should always be on top
+	if (p[0] == '.' && p[1] == '.' && p[2] == '\t') {
+		return -1;
+	}
+	if (q[0] == '.' && q[1] == '.' && q[2] == '\t') {
+		return 1;
+	}
 
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
+	if (!mixdir) {
+		int diff = (int)b->isDirectory() - (int)a->isDirectory();
+		if (diff) {
+			return diff;
+		}
+	}
 
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
+	// Prepare wide char strings
+	wchar_t *aw = NULL;
+	wchar_t *bw = NULL;
+	size_t an, bn;
+	an = mbstowcs(NULL, (const char *)p, 0);
+	if (an == (size_t) - 1) {
+		return compare_nolocale(p, q, igncase, asc, mixdir, jmp);
+	} 
+	aw = (wchar_t *)calloc(an + 1, sizeof(wchar_t));
+	if (aw == NULL) {
+		errno = ENOMEM;
+		return 0;
+	}
+	mbstowcs(aw, p, an + 1);
+	bn = mbstowcs(NULL, (const char *)q, 0);
+	if (bn == (size_t) - 1) {
+		free(aw);
+		return compare_nolocale(p, q, igncase, asc, mixdir, jmp);
+	} 
+	bw = (wchar_t *)calloc(bn + 1, sizeof(wchar_t)) ;
+	if (bw == NULL) {
+		errno = ENOMEM;
+		free(aw);
+		return 0;
+	}
+	mbstowcs(bw, q, bn + 1);
+
+	/*fprintf(stderr, "compare(aw=%ls, bw=%ls, igncase=%i, asc=%i, "
+			"mixdir=%i, jmp=%i) "
+			"an=%i, bn=%i\n", aw, bw, igncase, asc, mixdir,
+			jmp, an, bn); */
 	
-	while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	// Compare names
+	// Find where to stop comparision
+	register wchar_t *sa = aw;
+	register wchar_t *sb = bw;
+	register wchar_t *pw = aw;
+	register wchar_t *qw = bw;
+	while (*pw != '\0' && *pw > '\t') {
+		pw++;
+	}
+	while (*qw != '\0' && *qw > '\t') {
+		qw++;
+	}
+	register wchar_t op = *pw;
+	register wchar_t oq = *qw;
+	*pw = '\0';
+	*qw = '\0';
+
+	int rnames = 0;
+	int i = 0;
+	if (igncase) {
+		rnames = wcscasecmp(aw, bw);
+	} else {
+		rnames = wcscoll(aw, bw);
+	}
+	if (jmp == 0) {  
+		rv = rnames;
+		goto end;
+	}
+
+	// Compare other fields
+	// Find where to start comparision
+	*pw = op;
+	*qw = oq;
+	if (jmp == 1) {  // ascendingDir and similar
+		for(i = 1; *pw && i; i -= (*pw++ == '\t'))
+			;
+		for(i = 1; *qw && i; i -= (*qw++ == '\t'))
+			;
+	} else if (jmp > 1 && jmp < 8) {  // Jump some fields, 
+		//2->type, 3->ext, 5->user, 6->group, 7->perm,
+		if (pw[1] == '/')
+		{
+			for(i = jmp + 1; *pw && i; i -= (*pw++ == '\t'))
+				;
+			for(i = jmp + 1; *qw && i; i -= (*qw++ == '\t'))
+				;
+		} else {
+			for(i = jmp; *pw && i; i -= (*pw++ == '\t'))
+				;
+			for(i = jmp; *qw && i; i -= (*qw++ == '\t'))
+				;
+		}
+	} else if (jmp == 8) { // origPath
+		for(i = 8; *pw && i; i -= (*pw++ == '\t'))
+			;
+		for(i = 8; *qw && i; i -= (*qw++ == '\t'))
+			;
+	} else {
+		//assert(jmp>=0 && jmp<9);
+		errno = EINVAL;
+		rv = 0;
+		goto end;
+	}
+	sa = pw;
+	sb = qw;
+
+	// Find where to stop comparision
+	while (*pw != '\0' && *pw > '\t') {
+		pw ++;
+	}
+	while (*qw != '\0' && *qw > '\t') {
+		qw++;
+	}
+	*pw = '\0';
+	*qw = '\0';
+
+	// Compare
+	if (igncase) {
+		rv = wcscasecmp(sa, sb);
+	} else {
+		rv = wcscoll(sa, sb);
+	}
+	if (rv == 0) { 
+		rv = rnames;
+	}
+
+end:
+	if (aw != NULL) {
+		free(aw);
+		aw = NULL;
+	}
+	if (bw != NULL) {
+		free(bw);
+		bw = NULL;
+	}
+
+	// If descending flip
+	if (!asc) {
+		rv = rv * -1;
+	}
+	return rv;
 }
 
-// Compare file names, case insensitive
-int FileList::ascendingCase(const IconItem* pa,const IconItem* pb)
+
+// Compare file names
+int FileList::ascending(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
+	return compare(pa, pb, false, true, false, 0);
+}
 
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
 
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
+// Compare file names, mixing files and directories
+int FileList::ascendingMix(const IconItem* pa,const IconItem* pb)
+{
 
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return 1;
-        if(toLower(*p) < toLower(*q))
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, true, true, 0);
 }
 
+	
+	
+// Compare file names, case insensitive
+int FileList::ascendingCase(const IconItem* pa,const IconItem* pb)
+{
+	return compare(pa, pb, true, true, false, 0);
+}
 
+
 // Compare file names, case insensitive, mixing files and directories
 int FileList::ascendingCaseMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return 1;
-        if(toLower(*p) < toLower(*q))
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, true, true, 0);
 }
 
 
@@ -2028,372 +2201,94 @@ int FileList::ascendingCaseMix(const IconItem* pa,cons
 int FileList::ascendingDir(const IconItem* pa,const IconItem* pb)
 {
 
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-	
-    register int i;
-    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-	while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, true, false, 1);
 }
 
 
 // Compare directory names, mixing files and directories
 int FileList::ascendingDirMix(const IconItem* pa,const IconItem* pb)
 {
+	return compare(pa, pb, false, true, true, 1);
+} 
 
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    register int i;
-    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-	while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
-}
-
 // Compare directory names, case insensitive
 int FileList::ascendingDirCase(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;
-    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return 1;
-        if(toLower(*p) < toLower(*q))
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, true, false, 1);
 }
 
 
 // Compare directory names, case insensitive, mixing files and directories
 int FileList::ascendingDirCaseMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    register int i;
-    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return 1;
-        if(toLower(*p) < toLower(*q))
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, true, true, 1);
 }
 
 
 // Compare file types
 int FileList::ascendingType(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-	
-    register int i;
-    
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=2; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=2; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 2);
 }
 
 
 // Compare file types, mixing files and directories
 int FileList::ascendingTypeMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=2; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=2; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 2);
 }
 
 
 // Compare file extension
 int FileList::ascendingExt(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-     register int i;
-	
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=4; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=4; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 3);
 }
 
 
 // Compare file extension, mixing files and directories
 int FileList::ascendingExtMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=4; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=4; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 3);
 }
 
 
 // Compare file size - Warning: only returns the sign of the comparison!!!
 int FileList::ascendingSize(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
+	register const FileItem *a=(FileItem*)pa;
+	register const FileItem *b=(FileItem*)pb;
+	register const unsigned char *p=(const unsigned char*)a->label.text();
+	register const unsigned char *q=(const unsigned char*)b->label.text();
 
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();	
-	
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
+	// Directory '..' should always be on top
+	if (p[0]=='.' && p[1]=='.' && p[2]=='\t') {
+		return -1;
+	}
+	if (q[0]=='.' && q[1]=='.' && q[2]=='\t') {
+		return 1;
+	}
 
 	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
 	register int sum=(int)b->isDirectory() + (int)a->isDirectory();
 
-    if(diff)
-        return diff;
-    if(sum==2)
+	if(diff) {
+		return diff;
+	}
+	if(sum==2) {
 		return ascendingCase(pa,pb);
-		
+	}
+
 	register FXlong l=a->size - b->size;
-    if(l)
-    {
-        if (l>=0)
-            return 1;
-        else
-            return -1;
-    }
-    return ascendingCase(pa,pb);
+	if(l)
+	{
+		if (l>=0) {
+			return 1;
+		} else {
+			return -1;
+		}
+	}
+	return ascendingCase(pa,pb);
 }
 
 
@@ -2401,36 +2296,42 @@ int FileList::ascendingSize(const IconItem* pa,const I
 // Mixing files and directories
 int FileList::ascendingSizeMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
+	register const FileItem *a=(FileItem*)pa;
+	register const FileItem *b=(FileItem*)pb;
+	register const unsigned char *p=(const unsigned char*)a->label.text();
+	register const unsigned char *q=(const unsigned char*)b->label.text();
 
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
 	register int adir=(int)a->isDirectory();
 	register int bdir=(int)b->isDirectory();
 
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
+	// Directory '..' should always be on top
+	if (p[0]=='.' && p[1]=='.' && p[2]=='\t') {
+		return -1;
+	}
+	if (q[0]=='.' && q[1]=='.' && q[2]=='\t') {
+		return 1;
+	}
 
-	if (adir && bdir)
+	if (adir && bdir) {
 		return ascendingCaseMix(pa,pb);
-	if(adir && !bdir)
+	}
+	if(adir && !bdir) {
 		return -1;
-	if(!adir && bdir)
+	}
+	if(!adir && bdir) {
 		return 1;
+	}
 
-    register FXlong l=a->size - b->size;
-    if(l)
-    {
-        if (l>=0)
-            return 1;
-        else
-            return -1;
-    }
-    return ascendingCaseMix(pa,pb);
+	register FXlong l=a->size - b->size;
+	if(l)
+	{
+		if (l>=0) {
+			return 1;
+		} else {
+			return -1;
+		}
+	}
+	return ascendingCaseMix(pa,pb);
 }
 
 
@@ -2485,52 +2386,7 @@ int FileList::ascendingTimeMix(const IconItem* pa,cons
 // Compare file user
 int FileList::ascendingUser(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=5; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=5; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 5);
 }
 
 
@@ -2538,254 +2394,35 @@ int FileList::ascendingUser(const IconItem* pa,const I
 // Compare file user, mixing files and directories
 int FileList::ascendingUserMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=5; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=5; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 5);
 }
 
 
 // Compare file group
 int FileList::ascendingGroup(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-	if(diff)
-        return diff;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 6);
 }
 
 
 // Compare file group, mixing files and directories
 int FileList::ascendingGroupMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 6);
 }
 
 
 // Compare file permissions
 int FileList::ascendingPerm(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-     register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=8; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=8; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 7);
 }
 
 
 // Compare file permissions, mixing files and directories
 int FileList::ascendingPermMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-     register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=8; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=8; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 7);
 }
 
 
@@ -2839,528 +2476,96 @@ int FileList::ascendingDeltimeMix(const IconItem* pa,c
 // Compare original path
 int FileList::ascendingOrigpath(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-     register int i;
-
-	for(i=8; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=8; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 8);
 }
 
 // Compare original path, mixing files and directories
 int FileList::ascendingOrigpathMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-     register int i;
-
-	for(i=8; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=8; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 8);
 }
 
 // Reversed compare file name, case insensitive
 int FileList::descendingCase(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return -1;
-        if(toLower(*p) < toLower(*q))
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, false, false, 0);
 }
 
 
 // Reversed compare file name, case insensitive, mixing files and directories
 int FileList::descendingCaseMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return -1;
-        if(toLower(*p) < toLower(*q))
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, false, true, 0);
 }
 
 
 // Reversed compare file name
 int FileList::descending(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-	
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, false, false, 0);
 }
 
 
 // Reversed compare file name, mixing files and directories
 int FileList::descendingMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, false, true, 0);
 }
 
 
 // Reversed compare directory names, case insensitive
 int FileList::descendingDirCase(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return -1;
-        if(toLower(*p) < toLower(*q))
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, false, false, 1);
 }
 
 
 // Reversed compare directory names, case insensitive, mixing files and directories
 int FileList::descendingDirCaseMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    register int i;    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return -1;
-        if(toLower(*p) < toLower(*q))
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, false, true, 1);
 }
 
 
 // Reversed compare directory names
 int FileList::descendingDir(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-	
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, false, false, 1);
 }
 
 
 // Reversed compare directory names, mixing files and directories
 int FileList::descendingDirMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    register int i;    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, false, true, 1);
 }
 
 
 // Reversed compare file type
 int FileList::descendingType(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=2; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=2; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 2);
 }
 
 
 // Reversed compare file type, mixing files and directories
 int FileList::descendingTypeMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=2; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=2; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 2);
 }
 
 
 // Reversed compare file extension
 int FileList::descendingExt(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=4; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=4; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 3);
 }
 
 
 // Reversed compare file extension, mixing files and directories
 int FileList::descendingExtMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=4; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=4; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 3);
 }
 
 
@@ -3483,257 +2688,35 @@ int FileList::descendingTimeMix(const IconItem* pa,con
 // Reversed compare file user
 int FileList::descendingUser(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=5; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=5; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 5);
 }
 
 
 // Reversed compare file user, mixing files and directories
 int FileList::descendingUserMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=5; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=5; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 5);
 }
 
 
 // Reversed compare file group
 int FileList::descendingGroup(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 6);
 }
 
 
 // Reversed compare file group, mixing files and directories
 int FileList::descendingGroupMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 6);
 }
 
 
 // Reversed compare file permission
 int FileList::descendingPerm(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=8; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=8; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 7);
 }
 
 
@@ -3741,49 +2724,7 @@ int FileList::descendingPerm(const IconItem* pa,const 
 // Reversed compare file permission, mixing files and directories
 int FileList::descendingPermMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=8; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=8; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 7);
 }
 
 
@@ -3837,39 +2778,7 @@ int FileList::descendingDeltimeMix(const IconItem* pa,
 // Reversed compare original path
 int FileList::descendingOrigpath(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;
-
-	for(i=8; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=8; *q && i; i-=(*q++=='\t'))
-		;
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 8);
 }
 
 
@@ -3877,35 +2786,7 @@ int FileList::descendingOrigpath(const IconItem* pa,co
 // Reversed original path, mixing files and directories
 int FileList::descendingOrigpathMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	for(i=8; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=8; *q && i; i-=(*q++=='\t'))
-		;
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 8);
 }
 
 
@@ -4685,9 +3566,8 @@ fnd:          	*pn=item;
 					item->cdate=filectime;
 					item->deldate=deldate;
 
-#if defined(linux)
 					// Mounted devices may have a specific icon
-					if(mtdevices->find(pathname.text()))
+					if(mtdevices != NULL && mtdevices->find(pathname.text()))
 					{
 						filetype=_("Mount point");
 						
@@ -4704,7 +3584,7 @@ fnd:          	*pn=item;
 					}
 
 					// Devices found in fstab may have a specific icon
-					if(fsdevices->find(pathname.text()))
+					if(fsdevices != NULL && fsdevices->find(pathname.text()))
 					{
 						filetype=_("Mount point");
 						
@@ -4739,7 +3619,6 @@ fnd:          	*pn=item;
 							item->setMiniIcon(zipicon);
 						}
 					}
-#endif
 
 					// Update item label
 					// NB : Item del is empty if we are not in trash can
