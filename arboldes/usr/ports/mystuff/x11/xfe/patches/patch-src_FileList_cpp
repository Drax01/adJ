$OpenBSD$
--- src/FileList.cpp.orig	Tue Feb  5 07:26:35 2013
+++ src/FileList.cpp	Thu Feb 21 07:36:19 2013
@@ -3,6 +3,9 @@
 #include "i18n.h"
 
 #include <ctype.h>
+#include <locale.h>
+#include <wctype.h>
+#include <wchar.h>
 #include <time.h>
 
 
@@ -1896,131 +1899,297 @@ long FileList::onUpdHeader(FXObject*,FXSelector,void*)
 }
 
 
-// Compare file names
-int FileList::ascending(const IconItem* pa,const IconItem* pb)
+/** 
+ * Compares fields of p and q, supposing they are single byte strings
+ * without using the current locale.
+ * @param  igncase	Ignore upper/lower-case?
+ * @param  asc		Ascending?  If false is descending order
+ * @param  mixdir	Mix directories with files?
+ * @param  jmp		Field to compare (separated with \t)
+ *
+ * @return 0 if equal, negative if p<q, positive if p>q
+ * If jmp has an invalid value returns 0 and errno will be EINVAL
+ */
+static int compare_nolocale(char *p, char *q, 
+		bool igncase,  bool asc, bool mixdir, int jmp)
 {
+	int rnames, rv = 0, i;
 
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
+	// Compare names
+	while (*p != '\0' && *p > '\t' && *q != '\0' && *q > '\t'
+			&& ((igncase && toLower(*p) == toLower(*q)) ||
+				(!igncase && *p == *q))) {
+		p++;
+		q++;
+	}
+	if (igncase) {
+		rnames = toLower(*p) - toLower(*q);
+	} else {
+		rnames = *p - *q;
+	}
+	if (jmp == 0) {  
+		rv = rnames;
+		goto end;
+	}
 
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
+	// Compare other fields
+	if (jmp == 1) {  // ascendingDir and similar
+		for(i = 1; *p && i; i -= (*p++ == '\t'))
+			;
+		for(i = 1; *q && i; i -= (*q++ == '\t'))
+			;
+	} else if (jmp > 1 && jmp < 8) {  // Jump some fields, 
+		//2->type, 3->ext, 5->user, 6->group, 7->perm,
+		// Adjust the header index depending on the list type
+		if (p[1] == '/')
+		{
+			for(i = jmp + 1; *p && i; i -= (*p++ == '\t'))
+				;
+			for(i = jmp + 1; *q && i; i -= (*q++ == '\t'))
+				;
+		} else {
+			for(i = jmp; *p && i; i -= (*p++ == '\t'))
+				;
+			for(i = jmp; *q && i; i -= (*q++ == '\t'))
+				;
+		}
+	} else if (jmp == 8) { // origPath
+		for(i = 8; *p && i; i -= (*p++ == '\t'))
+			;
+		for(i = 8; *q && i; i -= (*q++ == '\t'))
+			;
+	} else {
+		//assert(jmp>=0 && jmp<9);
+		errno = EINVAL;
+		return 0;
+	}
+	while (*p != '\0' && *p > '\t' && *q != '\0' && *q > '\t'
+			&& ((igncase && toLower(*p) == toLower(*q)) ||
+				(!igncase && *p == *q))) {
+		p++;
+		q++;
+	}
+	if (igncase) {
+		rv = toLower(*p) - toLower(*q);
+	} else {
+		rv = *p - *q;
+	}
+	if (rv == 0) { 
+		rv = rnames;
+	}
+end:
 
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-	
-	while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	// If descending flip
+	if (!asc) {
+		rv = rv * -1;
+	}
+	return rv;
 }
 
 
-// Compare file names, mixing files and directories
-int FileList::ascendingMix(const IconItem* pa,const IconItem* pb)
+
+/**
+ * Compares a field of pa with the same field of pb, if the fields are
+ * equal compare by name
+ * @param  igncase	Ignore upper/lower-case?
+ * @param  asc		Ascending?  If false is descending order
+ * @param  mixdir	Mix directories with files?
+ * @param  jmp		Field to compare (separated with \t)
+ *
+ * @return 0 if equal, negative if pa<pb, positive if pa>pb
+ * Requires to allocate some space, if there is no memory this 
+ * function returns 0 and errno will be ENOMEM
+ * If jmp has an invalid value returns 0 and errno will be EINVAL
+ */
+int FileList::compare(const IconItem* pa,const IconItem* pb, 
+		bool igncase,  bool asc,  bool mixdir, int jmp)
 {
+	
+	int rv = 0; // Value to return
+	register const FileItem *a = (FileItem*)pa;
+	register const FileItem *b = (FileItem*)pb;
+	register char *p = (char *)a->label.text();
+	register char *q = (char *)b->label.text();
 
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
+	// Common cases 
+	// Directory '..' should always be on top
+	if (p[0] == '.' && p[1] == '.' && p[2] == '\t') {
+		return -1;
+	}
+	if (q[0] == '.' && q[1] == '.' && q[2] == '\t') {
+		return 1;
+	}
 
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
+	if (!mixdir) {
+		int diff = (int)b->isDirectory() - (int)a->isDirectory();
+		if (diff) {
+			return diff;
+		}
+	}
 
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
+	// Prepare wide char strings
+	wchar_t *aw = NULL;
+	wchar_t *bw = NULL;
+	size_t an, bn;
+	an = mbstowcs(NULL, (const char *)p, 0);
+	if (an == (size_t) - 1) {
+		return compare_nolocale(p, q, igncase, asc, mixdir, jmp);
+	} 
+	aw = (wchar_t *)calloc(an + 1, sizeof(wchar_t));
+	if (aw == NULL) {
+		errno = ENOMEM;
+		return 0;
+	}
+	mbstowcs(aw, p, an + 1);
+	bn = mbstowcs(NULL, (const char *)q, 0);
+	if (bn == (size_t) - 1) {
+		free(aw);
+		return compare_nolocale(p, q, igncase, asc, mixdir, jmp);
+	} 
+	bw = (wchar_t *)calloc(bn + 1, sizeof(wchar_t)) ;
+	if (bw == NULL) {
+		errno = ENOMEM;
+		free(aw);
+		return 0;
+	}
+	mbstowcs(bw, q, bn + 1);
+
+	/*fprintf(stderr, "compare(aw=%ls, bw=%ls, igncase=%i, asc=%i, "
+			"mixdir=%i, jmp=%i) "
+			"an=%i, bn=%i\n", aw, bw, igncase, asc, mixdir,
+			jmp, an, bn); */
 	
-	while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	// Compare names
+	// Find where to stop comparision
+	register wchar_t *sa = aw;
+	register wchar_t *sb = bw;
+	register wchar_t *pw = aw;
+	register wchar_t *qw = bw;
+	while (*pw != '\0' && *pw > '\t') {
+		pw++;
+	}
+	while (*qw != '\0' && *qw > '\t') {
+		qw++;
+	}
+	register wchar_t op = *pw;
+	register wchar_t oq = *qw;
+	*pw = '\0';
+	*qw = '\0';
+
+	int rnames = 0;
+	int i = 0;
+	if (igncase) {
+		rnames = wcscasecmp(aw, bw);
+	} else {
+		rnames = wcscoll(aw, bw);
+	}
+	if (jmp == 0) {  
+		rv = rnames;
+		goto end;
+	}
+
+	// Compare other fields
+	// Find where to start comparision
+	*pw = op;
+	*qw = oq;
+	if (jmp == 1) {  // ascendingDir and similar
+		for(i = 1; *pw && i; i -= (*pw++ == '\t'))
+			;
+		for(i = 1; *qw && i; i -= (*qw++ == '\t'))
+			;
+	} else if (jmp > 1 && jmp < 8) {  // Jump some fields, 
+		//2->type, 3->ext, 5->user, 6->group, 7->perm,
+		if (pw[1] == '/')
+		{
+			for(i = jmp + 1; *pw && i; i -= (*pw++ == '\t'))
+				;
+			for(i = jmp + 1; *qw && i; i -= (*qw++ == '\t'))
+				;
+		} else {
+			for(i = jmp; *pw && i; i -= (*pw++ == '\t'))
+				;
+			for(i = jmp; *qw && i; i -= (*qw++ == '\t'))
+				;
+		}
+	} else if (jmp == 8) { // origPath
+		for(i = 8; *pw && i; i -= (*pw++ == '\t'))
+			;
+		for(i = 8; *qw && i; i -= (*qw++ == '\t'))
+			;
+	} else {
+		//assert(jmp>=0 && jmp<9);
+		errno = EINVAL;
+		rv = 0;
+		goto end;
+	}
+	sa = pw;
+	sb = qw;
+
+	// Find where to stop comparision
+	while (*pw != '\0' && *pw > '\t') {
+		pw ++;
+	}
+	while (*qw != '\0' && *qw > '\t') {
+		qw++;
+	}
+	*pw = '\0';
+	*qw = '\0';
+
+	// Compare
+	if (igncase) {
+		rv = wcscasecmp(sa, sb);
+	} else {
+		rv = wcscoll(sa, sb);
+	}
+	if (rv == 0) { 
+		rv = rnames;
+	}
+
+end:
+	if (aw != NULL) {
+		free(aw);
+		aw = NULL;
+	}
+	if (bw != NULL) {
+		free(bw);
+		bw = NULL;
+	}
+
+	// If descending flip
+	if (!asc) {
+		rv = rv * -1;
+	}
+	return rv;
 }
 
-// Compare file names, case insensitive
-int FileList::ascendingCase(const IconItem* pa,const IconItem* pb)
+
+// Compare file names
+int FileList::ascending(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
+	return compare(pa, pb, false, true, false, 0);
+}
 
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
 
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
+// Compare file names, mixing files and directories
+int FileList::ascendingMix(const IconItem* pa,const IconItem* pb)
+{
 
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return 1;
-        if(toLower(*p) < toLower(*q))
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, true, true, 0);
 }
 
+	
+	
+// Compare file names, case insensitive
+int FileList::ascendingCase(const IconItem* pa,const IconItem* pb)
+{
+	return compare(pa, pb, true, true, false, 0);
+}
 
+
 // Compare file names, case insensitive, mixing files and directories
 int FileList::ascendingCaseMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return 1;
-        if(toLower(*p) < toLower(*q))
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, true, true, 0);
 }
 
 
@@ -2028,372 +2197,94 @@ int FileList::ascendingCaseMix(const IconItem* pa,cons
 int FileList::ascendingDir(const IconItem* pa,const IconItem* pb)
 {
 
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-	
-    register int i;
-    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-	while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, true, false, 1);
 }
 
 
 // Compare directory names, mixing files and directories
 int FileList::ascendingDirMix(const IconItem* pa,const IconItem* pb)
 {
+	return compare(pa, pb, false, true, true, 1);
+} 
 
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    register int i;
-    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-	while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
-}
-
 // Compare directory names, case insensitive
 int FileList::ascendingDirCase(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;
-    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return 1;
-        if(toLower(*p) < toLower(*q))
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, true, false, 1);
 }
 
 
 // Compare directory names, case insensitive, mixing files and directories
 int FileList::ascendingDirCaseMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    register int i;
-    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return 1;
-        if(toLower(*p) < toLower(*q))
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, true, true, 1);
 }
 
 
 // Compare file types
 int FileList::ascendingType(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-	
-    register int i;
-    
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=2; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=2; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 2);
 }
 
 
 // Compare file types, mixing files and directories
 int FileList::ascendingTypeMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=2; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=2; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 2);
 }
 
 
 // Compare file extension
 int FileList::ascendingExt(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-     register int i;
-	
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=4; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=4; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 3);
 }
 
 
 // Compare file extension, mixing files and directories
 int FileList::ascendingExtMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=4; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=4; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 3);
 }
 
 
 // Compare file size - Warning: only returns the sign of the comparison!!!
 int FileList::ascendingSize(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
+	register const FileItem *a=(FileItem*)pa;
+	register const FileItem *b=(FileItem*)pb;
+	register const unsigned char *p=(const unsigned char*)a->label.text();
+	register const unsigned char *q=(const unsigned char*)b->label.text();
 
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();	
-	
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
+	// Directory '..' should always be on top
+	if (p[0]=='.' && p[1]=='.' && p[2]=='\t') {
+		return -1;
+	}
+	if (q[0]=='.' && q[1]=='.' && q[2]=='\t') {
+		return 1;
+	}
 
 	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
 	register int sum=(int)b->isDirectory() + (int)a->isDirectory();
 
-    if(diff)
-        return diff;
-    if(sum==2)
+	if(diff) {
+		return diff;
+	}
+	if(sum==2) {
 		return ascendingCase(pa,pb);
-		
+	}
+
 	register FXlong l=a->size - b->size;
-    if(l)
-    {
-        if (l>=0)
-            return 1;
-        else
-            return -1;
-    }
-    return ascendingCase(pa,pb);
+	if(l)
+	{
+		if (l>=0) {
+			return 1;
+		} else {
+			return -1;
+		}
+	}
+	return ascendingCase(pa,pb);
 }
 
 
@@ -2401,36 +2292,42 @@ int FileList::ascendingSize(const IconItem* pa,const I
 // Mixing files and directories
 int FileList::ascendingSizeMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
+	register const FileItem *a=(FileItem*)pa;
+	register const FileItem *b=(FileItem*)pb;
+	register const unsigned char *p=(const unsigned char*)a->label.text();
+	register const unsigned char *q=(const unsigned char*)b->label.text();
 
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
 	register int adir=(int)a->isDirectory();
 	register int bdir=(int)b->isDirectory();
 
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
+	// Directory '..' should always be on top
+	if (p[0]=='.' && p[1]=='.' && p[2]=='\t') {
+		return -1;
+	}
+	if (q[0]=='.' && q[1]=='.' && q[2]=='\t') {
+		return 1;
+	}
 
-	if (adir && bdir)
+	if (adir && bdir) {
 		return ascendingCaseMix(pa,pb);
-	if(adir && !bdir)
+	}
+	if(adir && !bdir) {
 		return -1;
-	if(!adir && bdir)
+	}
+	if(!adir && bdir) {
 		return 1;
+	}
 
-    register FXlong l=a->size - b->size;
-    if(l)
-    {
-        if (l>=0)
-            return 1;
-        else
-            return -1;
-    }
-    return ascendingCaseMix(pa,pb);
+	register FXlong l=a->size - b->size;
+	if(l)
+	{
+		if (l>=0) {
+			return 1;
+		} else {
+			return -1;
+		}
+	}
+	return ascendingCaseMix(pa,pb);
 }
 
 
@@ -2485,52 +2382,7 @@ int FileList::ascendingTimeMix(const IconItem* pa,cons
 // Compare file user
 int FileList::ascendingUser(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=5; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=5; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 5);
 }
 
 
@@ -2538,254 +2390,35 @@ int FileList::ascendingUser(const IconItem* pa,const I
 // Compare file user, mixing files and directories
 int FileList::ascendingUserMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=5; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=5; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 5);
 }
 
 
 // Compare file group
 int FileList::ascendingGroup(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-	if(diff)
-        return diff;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 6);
 }
 
 
 // Compare file group, mixing files and directories
 int FileList::ascendingGroupMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 6);
 }
 
 
 // Compare file permissions
 int FileList::ascendingPerm(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-     register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=8; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=8; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 7);
 }
 
 
 // Compare file permissions, mixing files and directories
 int FileList::ascendingPermMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-     register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=8; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=8; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 7);
 }
 
 
@@ -2839,528 +2472,96 @@ int FileList::ascendingDeltimeMix(const IconItem* pa,c
 // Compare original path
 int FileList::ascendingOrigpath(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-     register int i;
-
-	for(i=8; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=8; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCase(pa,pb);
+	return compare(pa, pb, false, true, false, 8);
 }
 
 // Compare original path, mixing files and directories
 int FileList::ascendingOrigpathMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-     register int i;
-
-	for(i=8; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=8; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(*p > *q)
-            return 1;
-        if(*p < *q)
-            return -1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, true, true, 8);
 }
 
 // Reversed compare file name, case insensitive
 int FileList::descendingCase(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return -1;
-        if(toLower(*p) < toLower(*q))
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, false, false, 0);
 }
 
 
 // Reversed compare file name, case insensitive, mixing files and directories
 int FileList::descendingCaseMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return -1;
-        if(toLower(*p) < toLower(*q))
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, false, true, 0);
 }
 
 
 // Reversed compare file name
 int FileList::descending(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-	
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, false, false, 0);
 }
 
 
 // Reversed compare file name, mixing files and directories
 int FileList::descendingMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, false, true, 0);
 }
 
 
 // Reversed compare directory names, case insensitive
 int FileList::descendingDirCase(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-	register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return -1;
-        if(toLower(*p) < toLower(*q))
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, false, false, 1);
 }
 
 
 // Reversed compare directory names, case insensitive, mixing files and directories
 int FileList::descendingDirCaseMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    register int i;    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(toLower(*p) > toLower(*q))
-            return -1;
-        if(toLower(*p) < toLower(*q))
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, true, false, true, 1);
 }
 
 
 // Reversed compare directory names
 int FileList::descendingDir(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-	
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, false, false, 1);
 }
 
 
 // Reversed compare directory names, mixing files and directories
 int FileList::descendingDirMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    register int i;    
-	for(i=1; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=1; *q && i; i-=(*q++=='\t'))
-		;
-
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return 0;
+	return compare(pa, pb, false, false, true, 1);
 }
 
 
 // Reversed compare file type
 int FileList::descendingType(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=2; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=2; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 2);
 }
 
 
 // Reversed compare file type, mixing files and directories
 int FileList::descendingTypeMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=2; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=2; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 2);
 }
 
 
 // Reversed compare file extension
 int FileList::descendingExt(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=4; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=4; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 3);
 }
 
 
 // Reversed compare file extension, mixing files and directories
 int FileList::descendingExtMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=4; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=4; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=3; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=3; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 3);
 }
 
 
@@ -3483,257 +2684,35 @@ int FileList::descendingTimeMix(const IconItem* pa,con
 // Reversed compare file user
 int FileList::descendingUser(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=5; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=5; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 5);
 }
 
 
 // Reversed compare file user, mixing files and directories
 int FileList::descendingUserMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=5; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=5; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 5);
 }
 
 
 // Reversed compare file group
 int FileList::descendingGroup(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 6);
 }
 
 
 // Reversed compare file group, mixing files and directories
 int FileList::descendingGroupMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=6; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=6; *q && i; i-=(*q++=='\t'))
-			;
-	}
-
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 6);
 }
 
 
 // Reversed compare file permission
 int FileList::descendingPerm(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=8; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=8; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 7);
 }
 
 
@@ -3741,49 +2720,7 @@ int FileList::descendingPerm(const IconItem* pa,const 
 // Reversed compare file permission, mixing files and directories
 int FileList::descendingPermMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-    register const unsigned char *r=(const unsigned char*)a->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	// Adjust the header index depending on the list type
-	for(i=1; *r && i; i-=(*r++=='\t'))
-		;
-	if (r[0]=='/')
-	{
-		for(i=8; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=8; *q && i; i-=(*q++=='\t'))
-			;
-	}
-	else
-	{
-		for(i=7; *p && i; i-=(*p++=='\t'))
-			;
-		for(i=7; *q && i; i-=(*q++=='\t'))
-			;
-	}
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 7);
 }
 
 
@@ -3837,39 +2774,7 @@ int FileList::descendingDeltimeMix(const IconItem* pa,
 // Reversed compare original path
 int FileList::descendingOrigpath(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int diff=(int)b->isDirectory() - (int)a->isDirectory();
-    if(diff)
-        return diff;
-
-    register int i;
-
-	for(i=8; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=8; *q && i; i-=(*q++=='\t'))
-		;
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCase(pa,pb);
+	return compare(pa, pb, false, false, false, 8);
 }
 
 
@@ -3877,35 +2782,7 @@ int FileList::descendingOrigpath(const IconItem* pa,co
 // Reversed original path, mixing files and directories
 int FileList::descendingOrigpathMix(const IconItem* pa,const IconItem* pb)
 {
-    register const FileItem *a=(FileItem*)pa;
-    register const FileItem *b=(FileItem*)pb;
-    register const unsigned char *p=(const unsigned char*)a->label.text();
-    register const unsigned char *q=(const unsigned char*)b->label.text();
-
-    // Directory '..' should always be on top
-    if (p[0]=='.' && p[1]=='.' && p[2]=='\t')
-        return -1;
-    if (q[0]=='.' && q[1]=='.' && q[2]=='\t')
-        return 1;
-
-    register int i;
-
-	for(i=8; *p && i; i-=(*p++=='\t'))
-		;
-	for(i=8; *q && i; i-=(*q++=='\t'))
-		;
-    while(1)
-    {
-        if(*p > *q)
-            return -1;
-        if(*p < *q)
-            return 1;
-        if(*p<='\t')
-            break;
-        p++;
-        q++;
-    }
-    return -ascendingCaseMix(pa,pb);
+	return compare(pa, pb, false, false, true, 8);
 }
 
 
